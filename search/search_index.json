{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to pyBrellaSampling WIKI","text":"<p>To access the source code, visit github.</p> <p>This is the wiki for all things pyBrellaSampling. The code is developed and maintained by Ross Amory at the University of Nottingham as part of a BBSRC sponsored PhD. </p>"},{"location":"#overview","title":"Overview","text":"<p>pyBrellaSampling can be grouped into 3 major components. Primarily it is a tool to help with the automation of QM/MM umbrella sampling and is called through the <code>pyBrella</code> command. This is due to the complexity of setting up these calculations and the lack of automatic tools that work with HPC systems.</p> <p>The code can however be used to run standalone MD and QM/MM simulations through the <code>Standalone</code> command. This was due to the backend of this process already being implemented for the Umbrella sampling code, and so adapting new functionality was relatively simple. </p> <p>Finally the code can be used to perform a QM benchmark in order to help chose which QM method to use when performing QM/MM umbrella sampling. It is called using the <code>Benchmark</code> command. Again there are few tools that exist that automate the process of performing a wide scope QM benchmark. </p>"},{"location":"UserVars/","title":"User variables and global configuration","text":""},{"location":"UserVars/#md-global-variables","title":"MD global variables","text":"<p>These are the default variables parsed to NAMD. Some of these can be effected by input files however some are never changed.</p> MM_Variables.py<pre><code>MM_DefaultVars = {  \"parmfile\" : \"complex.parm7\",\n                    \"ambercoor\": \"start.rst7\",\n                    \"bincoordinates\" : None,\n                    \"DCDfile\" : \"output\",\n                    \"DCDfreq\" : 1,\n                    \"restartname\" : \"output\",\n                    \"restartfreq\" : 1,              # Energy output and calculation also printed at this rate.\n                    \"outputname\" : \"output\",\n                    \"outputTiming\" : \"100\", \n                    \"amber\" : \"on\",\n                    \"switching\" : \"off\",\n                    \"exclude\" : \"scaled1-4\",\n                    \"1-4scaling\" : 0.833333333,\n                    \"scnb\" : 2.0,\n                    \"readexclusions\" : \"yes\",\n                    \"cutoff\" : 8.0,\n                    \"watermodel\" : \"tip3\",\n                    \"pairListdist\" : 11,\n                    \"LJcorrection\" : \"on\",\n                    \"ZeroMomentum\" : \"off\",\n                    \"rigidBonds\" : \"all\",\n                    \"rigidTolerance\" : \"1.0e-8\",\n                    \"rigidIterations\" : 100,\n                    \"timeStep\" : 2,                 # In fs\n                    \"fullElectFrequency\" : 1,\n                    \"nonBondedFreq\" : 1,\n                    \"stepspercycle\" : 10,\n                    \"PME\" : \"off\",\n                    \"PMEGridSizeX\" : 300,\n                    \"PMEGridSizeY\" : 300,\n                    \"PMEGridSizeZ\" : 300,\n                    \"PMETolerance\" : \"1.0e-6\",\n                    \"PMEInterpOrder\" : 4,\n                    \"cellBasisVector1\" : \"135.913174 0.0 0.0\",\n                    \"cellBasisVector2\" : \"-45.30439133333333 128.1401693173162 0.0\",\n                    \"cellBasisVector3\" : \"-45.30439133333333 -64.0700846586581 -110.97264187403509\",\n                    \"cellOrigin\" : \"0 0 0\",\n                    \"cellBasisVector\" : 135.913174, #### Base if all 3 are calculated...\n                    \"langevin\" : \"on\",\n                    \"langevinDamping\" : 5,\n                    \"langevinTemp\" : 300,\n                    \"langevinHydrogen\" : \"off\",\n                    \"temperature\" : 300,\n                    \"BerendsenPressure\" : \"off\",\n                    \"qmForces\" : \"off\",\n                    \"CUDASOAintegrate\" : \"off\",\n                    \"run\" : 1000,\n                    \"minimize\" : 0,\n                    \"qmParamPDB\" : \"syst-qm.pdb\",\n                    \"qmColumn\" : \"beta\",\n                    \"qmBondColumn\" : \"occ\",\n                    \"QMsimsPerNode\" : 1,\n                    \"QMElecEmbed\" : \"on\",\n                    \"QMSwitching\" : \"on\",\n                    \"QMSwitchingType\" : \"shift\",\n                    \"QMPointChargeScheme\" : \"round\",\n                    \"QMBondScheme\" : \"cs\",\n                    \"qmBaseDir\" : \"/dev/shm/RUNDIR\",\n                    \"qmConfigLine\" : \"! PBE 6-31G* EnGrad D3BJ TightSCF \\n output PrintLevel Mini Print\\[ P_Mulliken \\] 1 Print\\[P_AtCharges_M\\] 1 end\",\n                    \"qmMult\" : \"1 1\",\n                    \"qmCharge\" : \"1 0\",\n                    \"qmSoftware\" : \"orca\",\n                    \"qmExecPath\" : \"~/Software/ORCA/orca\",\n                    \"QMOutStride\" : 1,\n                    \"qmEnergyStride\" : 1,\n                    \"QMPositionOutStride\" : 1,\n                    \"colvars\" : \"off\",\n                    \"colvarsConfig\" : \"colvars.conf\",\n                    }\n</code></pre>"},{"location":"setup/","title":"Installation process","text":""},{"location":"setup/#install","title":"Install","text":"<p>To install pyBrellaSampling, first clone the repo into a directory:</p> <pre><code>gh repo clone pcyra2/pyBrellaSampling\n</code></pre> <p>Then move some script files out of the source directory: <pre><code>cp pyBrellaSampling/setup.py .\ncp pyBrellaSampling/requirements.txt .\n</code></pre></p> <p>Next create the conda environment:</p> <pre><code>conda create -n pyBrellaSampling --file requirements.txt -c conda-forge\nconda activate pyBrellaSampling\n</code></pre> <p>Finally install the environment:</p> <pre><code>pip install -e .\n</code></pre> <p>Warning</p> <p>Warning, to re-compile this documentation, you also need to instal mkdocs-coverage... sadly this isnt a conda package so install it using: <pre><code>pip install mkdocs-coverage\n</code></pre></p>"},{"location":"setup/#pre-requisits","title":"Pre-requisits","text":""},{"location":"setup/#orca","title":"ORCA","text":"<p>To use any QMMM functionality or benchmarking, ORCA must be installed. You can obtain this here</p>"},{"location":"setup/#namd","title":"NAMD","text":"<p>For all dynamics simulations, we use NAMD which can be found here. Two versions of NAMD are recommended:</p> <ul> <li>a CUDA-GPU accelorated version for running standard MD</li> <li>a CPU version for running QM/MM</li> </ul>"},{"location":"setup/#wham","title":"WHAM","text":"<p>You must also have the WHAM code from the Grossfield Lab in order to perform WHAM calculations for Umbrella Sampling.</p>"},{"location":"setup/#configure","title":"Configure","text":"<p>It is important now to configure the default variables!  Go into the UserVars directory within the source.</p> <pre><code>cd pyBrellaSampling/UserVars\n</code></pre> <p>Here you MUST edit the HPC_Config.py and SoftwarePaths.py files.</p> <p>The <code>HPC_Config</code> file needs configuring so that your HPC variables like QoS are configured correctly. This allows for SLURM scripts to be generated correctly.</p> HPC_Config.py<pre><code>HPC_Config = {\n    \"None\" : {\n        \"HostName\" : \"\", # str: Hostname of the HPC\n        \"MaxWallTime\" : 0, # int: Maximum calculation time in hours\n        \"Partition\" : \"None\", # str: Partition to run calc on.\n        \"MaxCores\" : 0, # Maximum number of cores per node \n        \"QualityofService\" : \"None\", # str: Account QoS or None if not needed\n        \"Account\" : \"None\", # str: SLURM account or None if not needed\n        \"SoftwareLines\" : [\"\",], # list: List of lines required to set up environment\n    },\n    \"sulis\" : {\n        \"HostName\" : \"login01.sulis.hpc\", # str: Hostname of the HPC\n        \"MaxWallTime\" : 48, # int: Maximum calculation time in hours\n        \"Partition\" : \"compute\", # str: Partition to run calc on.\n        \"MaxCores\" : 128, # Maximum number of cores per node \n        \"QualityofService\" : \"None\", # str: Account QoS or None if not needed\n        \"Account\" : \"su120\", # str: SLURM account or None if not needed\n        \"SoftwareLines\" : [\"module load GCC/11.2.0\", \n                           \"module load OpenMPI/4.1.1\", \n                           \"module load ORCA/5.0.4\"], # list: List of lines required to set up environment\n    },\n}\n</code></pre> <p>The <code>SoftwarePaths</code> file needs the absolute paths of the ORCA executable, and CPU and GPU version of NAMD in order to run. </p> SoftwarePaths.py<pre><code># ORCA path\nORCA_PATH = \"/home/pcyra2/Software/ORCA/5.0.4/orca\" \n\n#NAMD paths\nNAMD_CPU = \"/home/pcyra2/Software/NAMD/NAMD_3.0b4_Linux-x86_64-multicore/namd3\"\n\nNAMD_GPU = \"/home/pcyra2/Software/NAMD/NAMD_3.0b4_Linux-x86_64-multicore-CUDA/namd3\"\n</code></pre> Other configs. <p>Here you can also edit the other files in the directory. This allows you to:</p> <pre><code>- Tune your MD parameters (MM_Variables.py)  \n- List available QM methods to ORCA for benchmarking (QM_Methods.py)\n- Change the Default inputs for each calculation type (if you always use the same QM method for example.) (Defaultinputs.py)\n</code></pre> <p>Final stage (optional)</p> <p>Within the source directory, run: <pre><code>mkdocs build\n</code></pre></p> <p>This will compile the documentation webpage and update the current configuration below.</p>"},{"location":"setup/#current-configuration","title":"Current Configuration:","text":"Defaultinputs.py<pre><code>Umbrella_Inp = {\n###--------------------------General---------------------------------###                \n    \"WorkDir\" : \"./\",# str: relative or absolute path to calculation\n    \"Verbosity\" : 0, # int: 0=Errors, 1=Warnings, 2=Info, 3=Debug\n    \"DryRun\" : True, # bool: Whether to actually run calculations\n###--------------------------Calcuation------------------------------### \n    \"CoresPerJob\" : 10, # int: Number of CPU cores for the calc.\n    \"MemoryPerJob\" : 10, # int: Ammount of RAM for the calc.\n    \"MaxStepsPerCalc\" : 1000, # int: Maximum number of steps per calculation\n###--------------------------QM--------------------------------------### \n    \"QM\" : False, # bool: To select the use of qmmm, requires the use of a qm file. \n    \"QmFile\" : \"None\", # str:  Name of qm file containing qm parms. \n    \"QmSelection\" : \"resname CTN POP MG\", # str: vmd selection algebra for the QM region\n    \"QmCharge\" : 1, # int: Net charge of QM system\n    \"QmSpin\" : 0, # int: Spin state of QM system\n    \"QmMethod\" : \"PBE\", # str: ORCA QM method\n    \"QmBasis\" : \"6-31+G*\", # str: ORCA QM basis set.\n    \"QmArgs\" : \"MINIPRINT D3BJ TightSCF CFLOAT\", # str: extra information to parse to ORCA\n###--------------------------Umbrella--------------------------------###\n    \"Stage\" : \"inpfile\", # str: Stage of calculation\n    \"UmbrellaFile\" : \"None\", # str: file containing qm information.\n    \"UmbrellaMin\" : 1.3, # float: Minimum Umbrella distance.\n    \"UmbrellaWidth\" : 0.05, # float: Width of the umbrella bin in either Ang or Deg.\n    \"UmbrellaBins\" : 54, # int: Number of Umbrella bins. \n    \"PullForce\" : 5000, # float: Force to pull the variables to each bin\n    \"ConstForce\" : 300, # float: Force to restain the colvar during Umbrella simulations\n    \"StartDistance\" : 1.4, # float: Current value for the colvar (From the equilibrated MD)\n    \"StartFile\" : \"start.rst7\", # str: Amber or NAMD coordinates, start coordinates for THIS simulation.\n    \"ParmFile\" : \"complex.parm7\", # str: Amber parameter file. This must be in the root directory!\n    \"AtomMask\" : \"0,0,0,0\", # str: Atom mask for SMD, comma delimited string of atoms. \n    \"AnalysisFile\" : \"prod\", # str: Variable to perform analysis on (i.e. if you only want to visualise pull files, use pull_1)\n    \"EquilLength\" : 1, # int: Length of equil in ps. eg 1 ps = 2000 steps at 0.5 fs timestep\n    \"ProdLength\" : 4, # int: Length of production in ps. 4 ps = 8000 steps at 0.5 fs timestep\n    }\n\nStandalone_Inp = {\n    \"WorkDir\" : \"./\",# str: relative or absolute path to calculation\n    \"Verbosity\" : 0, # int: 0=Errors, 1=Warnings, 2=Info, 3=Debug\n    \"DryRun\" : True, # bool: Whether to actually run calculations\n    \"CoresPerJob\" : 4, # int: Number of CPU cores for the calc.\n    \"MemoryPerJob\" : 4, # int: Ammount of RAM for the calc.\n    \"Name\" : \"Name\", # str: Name of calculation.\n    \"Ensemble\" : \"min\", # str: min, heat, NVT, NVP\n    \"QM\" : False, # bool: To select the use of qmmm, requires the use of a qm file. \n    \"QmFile\" : \"None\", # str:  Name of qm file containing qm parms. \n    \"QmSelection\" : \"resname CTN POP MG\", # str: vmd selection algebra for the QM region\n    \"QmCharge\" : 1, # int: Net charge of QM system\n    \"QmSpin\" : 0, # int: Spin state of QM system\n    \"QmMethod\" : \"PBE\", # str: ORCA QM method\n    \"QmBasis\" : \"6-31+G*\", # str: ORCA QM basis set.\n    \"QmArgs\" : \"MINIPRINT D3BJ TightSCF CFLOAT\", # str: extra information to parse to ORCA\n    \"MMFile\" : \"None\", # str: file containing qm information.\n    \"Steps\" : 1000, # int: Number of steps to simulate.\n    \"TimeStep\" : 2, # float: timestep in fs. if &gt;1, shake will be turned on. \n    \"ParmFile\" : \"complex.parm7\", # str: parameter file. Currently only amber params supported.\n    \"AmberCoordinates\" : \"start.rst7\", # str: amber coordinate file for use with the parameter files.\n    \"StartFile\" : \"start.rst7\", # str: Amber or NAMD coordinates, start coordinates for THIS simulation.\n    \"RestartOut\" : 10, # int: frequency of updating the restart file.\n    \"TrajOut\" : 50, # int: frequency of updating the trajectory file.\n    \"SMD\" : \"False\", # bool: Whether to use Steered MD.\n    \"SMDFile\" : None, # str: Name of file containing SMD parms\n    \"Force\" : 0, # float: Force to perform SMD\n    \"StartValue\" : 0, # float: start value for SMD\n    \"EndValue\" : 0, # float: end value for SMD\n    \"AtomMask\" : \"0,0,0,0\", # str: Atom mask for SMD, comma delimited string of atoms. \n    \"HPC\" : False, # bool: Run using a SLURM Scheduler. \n}\n\nBenchmark_Inp = {\n    \"Verbosity\" : 0, # int: 0=Errors, 1=Warnings, 2=Info, 3=Debug\n    \"WorkDir\" : \"./\", # str: Path to calculation directory.\n    \"Cores\" : 1, # int: Number of CPU cores\n    \"DryRun\" : True, # bool: Whether to actually run calculations\n    \"Stage\" : \"analysis\", # str: init, calc or analysis\n    \"BenchmarkType\" : \"Energy\", # str: only Energy supported at current.\n    \"CoordinateLoc\" : \"./Coordinates\", # str: location of molecule coordinates\n    \"ReactionList\" : \"reactions.dat\", # str: List of 1 step reactions\n    \"SCF\" : \"TIGHTSCF\", # str: Convergence criteria (As supported by ORCA)\n    \"Grid\" : \"DEFGRID3\", # str: SCF Grid (As supported by ORCA)\n    \"Restart\" : \"NOAUTOSTART\", # str: Whether to use the .gbw restart files (AUTOSTART/NOAUTOSTART)\n    \"Convergence\" : \"NormalConv\", # str: Agressivness of the SCF optimizer. \n    \"Extras\" : \"MINIPRINT\", # str: Extra information to parse to ORCA.\n}\n</code></pre> MM_Variables.py<pre><code>MM_DefaultVars = {  \"parmfile\" : \"complex.parm7\",\n                    \"ambercoor\": \"start.rst7\",\n                    \"bincoordinates\" : None,\n                    \"DCDfile\" : \"output\",\n                    \"DCDfreq\" : 1,\n                    \"restartname\" : \"output\",\n                    \"restartfreq\" : 1,              # Energy output and calculation also printed at this rate.\n                    \"outputname\" : \"output\",\n                    \"outputTiming\" : \"100\", \n                    \"amber\" : \"on\",\n                    \"switching\" : \"off\",\n                    \"exclude\" : \"scaled1-4\",\n                    \"1-4scaling\" : 0.833333333,\n                    \"scnb\" : 2.0,\n                    \"readexclusions\" : \"yes\",\n                    \"cutoff\" : 8.0,\n                    \"watermodel\" : \"tip3\",\n                    \"pairListdist\" : 11,\n                    \"LJcorrection\" : \"on\",\n                    \"ZeroMomentum\" : \"off\",\n                    \"rigidBonds\" : \"all\",\n                    \"rigidTolerance\" : \"1.0e-8\",\n                    \"rigidIterations\" : 100,\n                    \"timeStep\" : 2,                 # In fs\n                    \"fullElectFrequency\" : 1,\n                    \"nonBondedFreq\" : 1,\n                    \"stepspercycle\" : 10,\n                    \"PME\" : \"off\",\n                    \"PMEGridSizeX\" : 300,\n                    \"PMEGridSizeY\" : 300,\n                    \"PMEGridSizeZ\" : 300,\n                    \"PMETolerance\" : \"1.0e-6\",\n                    \"PMEInterpOrder\" : 4,\n                    \"cellBasisVector1\" : \"135.913174 0.0 0.0\",\n                    \"cellBasisVector2\" : \"-45.30439133333333 128.1401693173162 0.0\",\n                    \"cellBasisVector3\" : \"-45.30439133333333 -64.0700846586581 -110.97264187403509\",\n                    \"cellOrigin\" : \"0 0 0\",\n                    \"cellBasisVector\" : 135.913174, #### Base if all 3 are calculated...\n                    \"langevin\" : \"on\",\n                    \"langevinDamping\" : 5,\n                    \"langevinTemp\" : 300,\n                    \"langevinHydrogen\" : \"off\",\n                    \"temperature\" : 300,\n                    \"BerendsenPressure\" : \"off\",\n                    \"qmForces\" : \"off\",\n                    \"CUDASOAintegrate\" : \"off\",\n                    \"run\" : 1000,\n                    \"minimize\" : 0,\n                    \"qmParamPDB\" : \"syst-qm.pdb\",\n                    \"qmColumn\" : \"beta\",\n                    \"qmBondColumn\" : \"occ\",\n                    \"QMsimsPerNode\" : 1,\n                    \"QMElecEmbed\" : \"on\",\n                    \"QMSwitching\" : \"on\",\n                    \"QMSwitchingType\" : \"shift\",\n                    \"QMPointChargeScheme\" : \"round\",\n                    \"QMBondScheme\" : \"cs\",\n                    \"qmBaseDir\" : \"/dev/shm/RUNDIR\",\n                    \"qmConfigLine\" : \"! PBE 6-31G* EnGrad D3BJ TightSCF \\n output PrintLevel Mini Print\\[ P_Mulliken \\] 1 Print\\[P_AtCharges_M\\] 1 end\",\n                    \"qmMult\" : \"1 1\",\n                    \"qmCharge\" : \"1 0\",\n                    \"qmSoftware\" : \"orca\",\n                    \"qmExecPath\" : \"~/Software/ORCA/orca\",\n                    \"QMOutStride\" : 1,\n                    \"qmEnergyStride\" : 1,\n                    \"QMPositionOutStride\" : 1,\n                    \"colvars\" : \"off\",\n                    \"colvarsConfig\" : \"colvars.conf\",\n                    }\n</code></pre> QM_Methods.py<pre><code>Functionals = [\"PBE\", \"PBE0\", \"B3LYP\", \"HF\", \"M062X\", \"wB97M-V\", \"wB97X-D3\", \"MP2\"]\nBasis_Sets = [\"6-31G\", \"6-31G*\", \"6-31+G*\", \"cc-pVDZ\", \"cc-pVTZ\",  \"def2-SVP\"]\nDispersion_Corrections = [\"D3BJ\", \"D3ZERO\", \"\"] ## \"\" blank is for no dispersion to be benchmarked\nDispersionCorrFunc = [\"wB97M-V\", \"wB97X-D3\"]\n</code></pre> HPC_Config.py<pre><code>HPC_Config = {\n    \"None\" : {\n        \"HostName\" : \"\", # str: Hostname of the HPC\n        \"MaxWallTime\" : 0, # int: Maximum calculation time in hours\n        \"Partition\" : \"None\", # str: Partition to run calc on.\n        \"MaxCores\" : 0, # Maximum number of cores per node \n        \"QualityofService\" : \"None\", # str: Account QoS or None if not needed\n        \"Account\" : \"None\", # str: SLURM account or None if not needed\n        \"SoftwareLines\" : [\"\",], # list: List of lines required to set up environment\n    },\n    \"sulis\" : {\n        \"HostName\" : \"login01.sulis.hpc\", # str: Hostname of the HPC\n        \"MaxWallTime\" : 48, # int: Maximum calculation time in hours\n        \"Partition\" : \"compute\", # str: Partition to run calc on.\n        \"MaxCores\" : 128, # Maximum number of cores per node \n        \"QualityofService\" : \"None\", # str: Account QoS or None if not needed\n        \"Account\" : \"su120\", # str: SLURM account or None if not needed\n        \"SoftwareLines\" : [\"module load GCC/11.2.0\", \n                           \"module load OpenMPI/4.1.1\", \n                           \"module load ORCA/5.0.4\"], # list: List of lines required to set up environment\n    },\n\n}\n</code></pre> SoftwarePaths.py<pre><code># ORCA path\nORCA_PATH = \"/home/pcyra2/Software/ORCA/5.0.4/orca\" \n\n#NAMD paths\nNAMD_CPU = \"/home/pcyra2/Software/NAMD/NAMD_3.0b4_Linux-x86_64-multicore/namd3\"\n\nNAMD_GPU = \"/home/pcyra2/Software/NAMD/NAMD_3.0b4_Linux-x86_64-multicore-CUDA/namd3\"\n</code></pre>"},{"location":"Standalone/CodeReference/","title":"Standalone","text":"Source code in <code>Standalone.py</code> <pre><code>def main():\n    starttime = time.time()\n    args = input.StandaloneInput(sys.argv[1:],)\n    verbosity = args[\"Verbosity\"]\n    WorkDir = args[\"WorkDir\"]\n    dr = args[\"DryRun\"]\n    if dr == \"True\" or dr == True:\n        DryRun = True\n    elif dr == \"False\" or dr == False:\n        DryRun = False\n    parmfile = args[\"ParmFile\"]\n    assert path.isfile(f\"{WorkDir}{parmfile}\"), f\"ERROR: {parmfile} does not exist in the working directory!\"\n    globals.init(v=verbosity,wd=WorkDir,dr=DryRun, parm=parmfile)\n    Calc, MM, QM = calc_setup(args)\n    if globals.DryRun == False:\n        calc_run(Calc=Calc, MM=MM, QM=QM, )\n    endtime = time.time()\n    print(f\"Total time is {endtime - starttime}\")\n</code></pre> <p>Controls the inputs of a standalone calculation. </p> <p>Parameters:</p> Name Type Description Default <code>sysargs</code> <code>list</code> <p>CLI inputs (see attributes)</p> required <p>Attributes:</p> Name Type Description <code>--WorkDir</code> <code>str</code> <p>Working Directory</p> <code>--Verbosity</code> <code>int</code> <p>Verbosity: 0 = none, 1 = info</p> <code>--DryRun</code> <code>str</code> <p>Indicates whether programs are executed or not</p> <code>--CoresPerJob</code> <code>int</code> <p>Number of cores per individual calculation</p> <code>--MemoryPerJob</code> <code>int</code> <p>Gb of memory per individual calculation</p> <code>--MDCPUPath</code> <code>str</code> <p>Path to NAMD CPU executable</p> <code>--MDGPUPath</code> <code>str</code> <p>Path to NAMD GPU executable</p> <code>--QmFile</code> <code>str</code> <p>Name of file containing QM information.</p> <code>--QmPath</code> <code>str</code> <p>Path to QM software</p> <code>--QmSelection</code> <code>str</code> <p>Selection algebra for QM atoms</p> <code>--QmCharge</code> <code>int</code> <p>Charge of QM region</p> <code>--QmSpin</code> <code>int</code> <p>Spin of QM region</p> <code>--QmMethod</code> <code>str</code> <p>Qm method</p> <code>--QmBasis</code> <code>str</code> <p>QM basis set</p> <code>--QmArgs</code> <code>str</code> <p>Extra arguments for ORCA calculation</p> <code>--HPC</code> <code>bool</code> <p>Whether to run on a HPC</p> <code>--MaxWallTime</code> <code>int</code> <p>Maximum wall time (Hours) for your jobs (either leave as node max, or set as job length)</p> <code>--HostName</code> <code>str</code> <p>HostName of the HPC</p> <code>--Partition</code> <code>str</code> <p>Calculation partition name</p> <code>--MaxCores</code> <code>int</code> <p>Maximum number of cores available to a node (For array splitting)</p> <code>--QualityofService</code> <code>str</code> <p>Slurm QoS, set to None if not relevant.</p> <code>--Account</code> <code>str</code> <p>Slurm account, (Not username), Set to None if not relevant</p> <code>--SoftwareLines</code> <code>list</code> <p>List of commands like \"module load XXX\" to load software. Keep each line surrounded by quotes.</p> <code>--MMFile</code> <code>str</code> <p>Name of input file containing MD information</p> <code>--Name</code> <code>str</code> <p>Name for the calculation</p> <code>--Ensemble</code> <code>str</code> <p>Ensemble for Calculation</p> <code>--QM</code> <code>bool</code> <p>Whether this is a QMMM calculation or not.</p> <code>--Steps</code> <code>int</code> <p>Number of simulation steps.</p> <code>--TimeStep</code> <code>float</code> <p>Time step for the simulation. We recommend 2 for MM, 0.5 for QMMM</p> <code>--ParmFile</code> <code>str</code> <p>Parameter file name</p> <code>--AmberCoordinates</code> <code>str</code> <p>Amber coordinate file name that relates to the parameter file</p> <code>--StartFile</code> <code>str</code> <p>Either Amber coordinates or NAMD coordinates. These are the coordinates that it starts from.</p> <code>--RestartOut</code> <code>int</code> <p>Frequency to generate a restart file</p> <code>--TrajOut</code> <code>int</code> <p>Frequency to add to the trajectory file</p> <code>--SMD</code> <code>bool</code> <p>Whether to use steered molecular dynamics</p> <code>--Force</code> <code>int</code> <p>Force for Steered MD</p> <code>--StartValue</code> <code>int</code> <p>Start value for SMD</p> <code>--EndValue</code> <code>int</code> <p>End value for SMD. MAKE == Start if wanting constant.</p> <code>--AtomMask</code> <code>str</code> <p>Mask for the restrained atoms.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown variable is parsed</p> <p>Returns:</p> Name Type Description <code>arg_dict</code> <code>dict</code> <p>Dictionary of user variables.</p> Source code in <code>Tools/InputParser.py</code> <pre><code>def StandaloneInput(sysargs: list):\n    \"\"\"\n    Controls the inputs of a standalone calculation. \n\n    Args:\n        sysargs (list): CLI inputs (see attributes)\n\n    Attributes:\n        --WorkDir (str): Working Directory\n        --Verbosity (int): Verbosity: 0 = none, 1 = info\n        --DryRun (str):  Indicates whether programs are executed or not\n        --CoresPerJob (int): Number of cores per individual calculation\n        --MemoryPerJob (int): Gb of memory per individual calculation\n        --MDCPUPath (str): Path to NAMD CPU executable\n        --MDGPUPath (str): Path to NAMD GPU executable\n        --QmFile (str): Name of file containing QM information.\n        --QmPath (str): Path to QM software\n        --QmSelection (str): Selection algebra for QM atoms\n        --QmCharge (int): Charge of QM region\n        --QmSpin (int): Spin of QM region\n        --QmMethod (str): Qm method\n        --QmBasis (str): QM basis set\n        --QmArgs (str): Extra arguments for ORCA calculation\n        --HPC (bool): Whether to run on a HPC\n        --MaxWallTime (int): Maximum wall time (Hours) for your jobs (either leave as node max, or set as job length)\n        --HostName (str): HostName of the HPC\n        --Partition (str): Calculation partition name\n        --MaxCores (int): Maximum number of cores available to a node (For array splitting)\n        --QualityofService (str): Slurm QoS, set to None if not relevant.\n        --Account (str): Slurm account, (Not username), Set to None if not relevant\n        --SoftwareLines (list): List of commands like \"module load XXX\" to load software. Keep each line surrounded by quotes.\n        --MMFile (str): Name of input file containing MD information\n        --Name (str): Name for the calculation\n        --Ensemble (str): Ensemble for Calculation\n        --QM (bool): Whether this is a QMMM calculation or not.\n        --Steps (int): Number of simulation steps.\n        --TimeStep (float): Time step for the simulation. We recommend 2 for MM, 0.5 for QMMM\n        --ParmFile (str): Parameter file name\n        --AmberCoordinates (str): Amber coordinate file name that relates to the parameter file\n        --StartFile (str): Either Amber coordinates or NAMD coordinates. These are the coordinates that it starts from.\n        --RestartOut (int): Frequency to generate a restart file\n        --TrajOut (int): Frequency to add to the trajectory file\n        --SMD (bool): Whether to use steered molecular dynamics\n        --Force (int): Force for Steered MD\n        --StartValue (int): Start value for SMD\n        --EndValue (int): End value for SMD. MAKE == Start if wanting constant.\n        --AtomMask (str): Mask for the restrained atoms.\n\n    Raises:\n        ValueError: If an unknown variable is parsed\n\n    Returns:\n        arg_dict (dict): Dictionary of user variables. \n    \"\"\"\n    HPC = \"None\"\n    HostName = socket.gethostname()\n    for alias, data in HPC_Config.items():\n        if HostName == data[\"HostName\"]:\n            HPC = alias\n            continue\n    defaults = UserVars.Standalone_Inp\n    HPC_Conf = HPC_Config[HPC]\n    parser = argparse.ArgumentParser(description=f\"\"\"Commandline arguments. This method of calculation input is being deprecated. Please do not use.\nIt is recommended to use -jt inpfile to generate input file templates with default values that you can then edit.\"\"\")\n    ### Core Job arguments\n    Core = parser.add_argument_group(\"Core Job Arguments\")\n    Core.add_argument('-wd', '--WorkDir', type=str,\n                        help=\"Home location for the calculations\", default=defaults[\"WorkDir\"])\n    Core.add_argument('-v', '--Verbosity', type=int,\n                        help=\"Verbosity: 0 = none, 1 = info\", default=defaults[\"Verbosity\"])\n    Core.add_argument('-dr', '--DryRun', type=str,\n                        help=\"Indicates whether programs are executed or not\", default=defaults[\"DryRun\"])\n\n    Compute = parser.add_argument_group(\"Compute Arguments\")\n    ### Compute Arguments\n    Compute.add_argument('-c', '--CoresPerJob', type=int,\n                        help=\"Number of cores per individual calculation\", default=defaults[\"CoresPerJob\"])\n    Compute.add_argument('-m','--MemoryPerJob', type=int,\n                        help=\"Gb of memory per individual calculation\", default=defaults[\"MemoryPerJob\"])\n\n    ### MM Arguments\n    MM = parser.add_argument_group(\"Molecular Dynamics Arguments\")\n    MM.add_argument('-MDcpu', '--MDCPUPath', type=str,\n                        help=\"Path to NAMD CPU executable\", default=NAMD_CPU)\n    MM.add_argument('-MDgpu', '--MDGPUPath', type=str,\n                        help=\"Path to NAMD GPU executable\", default=NAMD_GPU)\n\n    ### QM Arguments\n    QM = parser.add_argument_group(\"QM Arguments\")\n    QM.add_argument(\"-qf\", \"--QmFile\", type=str, default=defaults[\"QmFile\"],\n                    help=\"Name of file containing QM information.\")\n    QM.add_argument('-qp', '--QmPath', type=str,\n                        help=\"Path to QM software\", default=ORCA_PATH)\n    QM.add_argument('-qsel', '--QmSelection', type=str,\n                        help=\"Selection algebra for QM atoms\", default=defaults[\"QmSelection\"])\n    QM.add_argument('-qc', '--QmCharge', type=int,\n                        help=\"Charge of QM region\", default=defaults[\"QmCharge\"])\n    QM.add_argument('-qspin', '--QmSpin', type=int,\n                        help=\"Spin of QM region\", default=defaults[\"QmSpin\"])\n    QM.add_argument('-qm', '--QmMethod', type=str,\n                        help=\"Qm method\", default=defaults[\"QmMethod\"])\n    QM.add_argument('-qb', '--QmBasis', type=str,\n                        help=\"QM basis set\", default=defaults[\"QmBasis\"])\n    QM.add_argument('-qargs', '--QmArgs', type=str, \n                    help=\"Extra arguments for ORCA calculation\", default=defaults[\"QmArgs\"])\n\n    ### HPC Arguments\n    HPC = parser.add_argument_group(\"HPC/SLURM arguments\")\n    HPC.add_argument(\"--HPC\", type=bool, default=defaults[\"HPC\"], help=\"Whether to run on a HPC\")\n    HPC.add_argument(\"-MaxTime\", \"--MaxWallTime\", type=int,\n                     help=\"Maximum wall time (Hours) for your jobs (either leave as node max, or set as job length)\",\n                     default=HPC_Conf[\"MaxWallTime\"])\n    HPC.add_argument(\"-Host\", \"--HostName\", type=str,\n                     help=\"HostName of the HPC\", default=HPC_Conf[\"HostName\"])\n    HPC.add_argument(\"--Partition\", type=str, help=\"Calculation partition name\",\n                     default=HPC_Conf[\"Partition\"])\n    HPC.add_argument(\"--MaxCores\", type=int,\n                     help=\"Maximum number of cores available to a node (For array splitting)\", default=HPC_Conf[\"MaxCores\"])\n    HPC.add_argument(\"-QoS\", \"--QualityofService\", type=str,\n                     help=\"Slurm QoS, set to None if not relevant.\", default=HPC_Conf[\"QualityofService\"])\n    HPC.add_argument(\"--Account\", type=str,\n                     help=\"Slurm account, (Not username), Set to None if not relevant\", default=HPC_Conf[\"Account\"])\n    HPC.add_argument(\"-Software\", \"--SoftwareLines\", type=str,\n                    help=\"List of commands like \\\"module load XXX\\\" to load software. Keep each line surrounded by quotes.\",\n                    default=HPC_Conf[\"SoftwareLines\"], nargs=\"*\")\n\n    Standalone = parser.add_argument_group(\"Standalone Job arguments\")\n    Standalone.add_argument(\"-i\", \"--MMFile\", type=str, default=defaults[\"MMFile\"],\n                            help=\"Name of input file containing MD information\")\n    Standalone.add_argument(\"--Name\", type=str,\n                            default=defaults[\"Name\"], help=\"Name for the calculation\")\n    Standalone.add_argument(\"--Ensemble\", type=str,\n                            choices=[\"min\", \"heat\", \"NVT\", \"NPT\"],\n                            help=\"Ensemble for Calculation\", default=defaults[\"Ensemble\"])\n    Standalone.add_argument(\"--QM\", type=str, choices=[\"True\", \"False\"],\n                            default=defaults[\"QM\"], help=\"Whether this is a QMMM calculation or not.\")\n    Standalone.add_argument(\"-st\", \"--Steps\", type=int,\n                            default=defaults[\"Steps\"], help=\"Number of simulation steps.\")\n    Standalone.add_argument(\"-dt\", \"--TimeStep\", type=float,\n                            default=float(defaults[\"TimeStep\"]), help=\"Time step for the simulation. We recommend 2 for MM, 0.5 for QMMM\")\n    Standalone.add_argument(\"--ParmFile\", type=str,\n                            default=defaults[\"ParmFile\"], help=\"Parameter file name\")\n    Standalone.add_argument(\"--AmberCoordinates\", type=str,\n                            default=defaults[\"AmberCoordinates\"], help=\"Amber coordinate file name that relates to the parameter file\")\n    Standalone.add_argument(\"--StartFile\", type=str, default=defaults[\"StartFile\"], \n                            help=\"Either Amber coordinates or NAMD coordinates. These are the coordinates that it starts from.\")\n    Standalone.add_argument(\"--RestartOut\", type=int, default=defaults[\"RestartOut\"], \n                            help=\"Frequency to generate a restart file\")\n    Standalone.add_argument(\"--TrajOut\", type=int, default=defaults[\"TrajOut\"], \n                            help=\"Frequency to add to the trajectory file\")\n    Standalone.add_argument(\"--SMD\", type=str, choices=[\"True\", \"False\"], default=defaults[\"SMD\"], \n                            help=\"Wheter to use steered molecular dynamics\")\n    Standalone.add_argument(\"--Force\", type=float, default=defaults[\"Force\"], \n                            help=\"Force for Steered MD\")\n    Standalone.add_argument(\"--StartValue\", type=float, default=defaults[\"StartValue\"], \n                            help=\"Start value for SMD\")\n    Standalone.add_argument(\"--EndValue\", type=float, default=defaults[\"EndValue\"], \n                            help=\"End value for SMD. MAKE == Start if wanting constant.\")\n    Standalone.add_argument('-mask', '--AtomMask', type=str,\n                        help=\"Mask for the restrained atoms.\", default=defaults[\"AtomMask\"])\n    args = parser.parse_args(sysargs)\n    arg_dict = vars(args)\n    workdir = arg_dict[\"WorkDir\"]\n    qmfile = arg_dict[\"QmFile\"]\n    mmfile = arg_dict[\"MMFile\"]\n    # print(arg_dict[\"DryRun\"])\n    if arg_dict[\"QmFile\"] != \"None\":\n        qm_input = utils.file_read(f\"{workdir}{qmfile}\")\n        for i in qm_input:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\") # removes random spaces.\n            val = val.replace(\"\\n\",\"\") # removes newline errors/\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {qmfile}\")\n    if arg_dict[\"MMFile\"] != \"None\":\n        mm_input = utils.file_read(f\"{workdir}{mmfile}\")\n        for i in mm_input:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\")\n            val = val.replace(\"\\n\",\"\")\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {mmfile}\")\n    # utils.print_attributes(arg_dict) # Prints out all vars for use in docstring generation\n    return arg_dict\n</code></pre> <p>Initialises some of the main classes used by the calculation. </p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>dict</code> <p>User defined variables.</p> required <p>Returns:</p> Name Type Description <code>Calc</code> <code>CalcClass</code> <p>Generic calculation info</p> <code>MM</code> <code>MMClass</code> <p>MM Variables</p> <code>QM</code> <code>QMClas</code> <p>QM variables, if == False : No QMMM</p> <code>Umbrella</code> <code>UmbrellaClass</code> <p>Umbrella variables for restraint information.</p> Source code in <code>Standalone.py</code> <pre><code>def Class_init(args: dict):\n    \"\"\"Initialises some of the main classes used by the calculation. \n\n    Args:\n        args (dict): User defined variables.\n\n    Returns:\n        Calc (CalcClass): Generic calculation info\n        MM (MMClass): MM Variables\n        QM (QMClas): QM variables, if == False : No QMMM\n        Umbrella (UmbrellaClass): Umbrella variables for restraint information.\n    \"\"\"\n    Calc = CalcClass(args=args)\n    MM = MMClass()\n    Calc.Job_Name(Name=args[\"Name\"])\n    Calc.Set_OutFile(OutFile=args[\"Name\"])\n    Calc.Set_Id(0)\n    MM.Set_Length(Steps=args[\"Steps\"], TimeStep=args[\"TimeStep\"])\n    MM.Set_Ensemble(Ensemble=args[\"Ensemble\"])\n    MM.Set_Files(parm=args[\"ParmFile\"], ambercoor=args[\"AmberCoordinates\"])\n    MM.Set_Outputs(TimeOut=args[\"TrajOut\"], RestOut=args[\"RestartOut\"], \n                   TrajOut=args[\"TrajOut\"]) ### Output timings when trajectory is printed.\n    args[\"PullForce\"] = args[\"Force\"]\n    args[\"ConstForce\"] = args[\"Force\"]\n    Umbrella = UmbrellaClass(args, Min=float(args[\"StartValue\"]), bins=0,\n                            Start=float(args[\"StartValue\"]),\n                            Width=(float(args[\"EndValue\"]) - float(args[\"StartValue\"])))\n    Umbrella.add_start(0)\n    Umbrella.set_force(args[\"Force\"])\n    Umbrella.add_bins([str(args[\"EndValue\"])])\n    bincoor = args[\"StartFile\"]\n    if bincoor == \"None\" or bincoor == \"\" or bincoor == MM.ambercoor:\n                bincoor = None\n    if \".ncrst\" in str(bincoor) or \".rst7\" in str(bincoor):\n        print(\"WARNING: Your Binary Coordinates look like amber coordinates... They should be NAMD coodinates (.coor). This may cause issues...\\n\" if globals.verbosity &gt;= 1 else \"\", end=\"\")\n    if args[\"QM\"] == True or args[\"QM\"] == \"True\":\n        print(\"INFO: Running a QMMM calculation \\n\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n        QM = QMClass(args=args)\n        QM.set_selfile(\"syst-qm.pdb\")\n    else:\n        QM = False\n    if MM.TimeStep &gt; 1:\n        print(\"WARNING: TimeStep is greater than 1 fs. Setting Rattle to True\\n\" if globals.verbosity &gt;=1 else \"\", end=\"\")\n        MM.Set_Shake(\"all\")\n    NAMD = NAMDClass(Calc=Calc, MM=MM)\n    return Calc, MM, QM, Umbrella, NAMD\n</code></pre> <p>Generates the input file, including any syst-*.pdb files.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>dict</code> <p>User defined variables</p> required <p>Returns:</p> Name Type Description <code>Calc</code> <code>CalcClass</code> <p>Calculation variables</p> <code>MM</code> <code>MMClass</code> <p>Required for knowing how to run the calculation (With or without GPU ect. )</p> <code>QM</code> <code>QMClass</code> <p>Again required for knowing how to run the calculation.</p> Source code in <code>Standalone.py</code> <pre><code>def calc_setup(args: dict):\n    \"\"\"\n    Generates the input file, including any syst-*.pdb files.\n\n    Args:\n        args (dict): User defined variables\n\n    Returns:\n        Calc (CalcClass): Calculation variables\n        MM (MMClass): Required for knowing how to run the calculation (With or without GPU ect. )\n        QM (QMClass): Again required for knowing how to run the calculation.\n    \"\"\"\n    Calc, MM, QM, Umbrella, NAMD = Class_init(args) # inits classes\n    MM.CellVec = utils.get_cellVec(MM) # Obtains the cell vectors from the parm file. \n    NAMD.set_cellvectors(MM.CellVec)\n    NAMD.set_startcoords(args[\"StartFile\"], ambercoor=MM.ambercoor, parm=MM.parmfile)\n    if QM != False:\n        print(\"INFO: Setting up a QMMM calculation\\n\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n        NAMD.set_qm(Calc=Calc, QM=QM, index=\"QMMM\")\n        utils.QM_Gen(QM.QMSel, globals.WorkDir)\n        if globals.DryRun == False:\n            print(\"INFO: Setting up the QM pdb file.\\n\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n            logfile = subprocess.run([\"vmd\", \"-dispdev\", \"text\", \"-e\", \"qm_prep.tcl\"],\n                                     text = True, capture_output = True) # Generates sys-qm.pdb using vmd\n            with open(f\"{globals.WorkDir}tcl-qm.log\",\"w\") as f:\n                print(logfile, file=f)\n    else:\n        NAMD.set_pme(\"on\")\n        # pass\n    if args[\"SMD\"].casefold() == \"true\":\n        print(f\"WARNING: SMD method is currently untested... \" if globals.verbosity &gt;=1 else \"\", end=\"\")\n        NAMD = init_SMD(NAMD=NAMD,Umbrella=Umbrella )\n        utils.ColVarPDB_Gen(Umbrella)\n        if globals.DryRun == False:\n            print(\"INFO: Setting up the Colvar pdb file.\\n\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n            logfile = subprocess.run([\"vmd\", \"-dispdev\", \"text\", \"-e\", \"Colvar_prep.tcl\"],\n                                     text = True, capture_output = True) # Generates sys-col.pdb using vmd. \n            with open(f\"{globals.WorkDir}tcl-colvar.log\",\"w\") as f:\n                print(logfile, file=f)\n    print(\"INFO: Setting up the conf file\\n\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n    file = FileGen.Namd_File(NAMD)\n    utils.file_write(f\"{globals.WorkDir}{Calc.Name}.conf\", [file]) # Outputs the calculation file for namd. \n    return Calc, MM, QM\n</code></pre> <p>Handles the running of the calculations. Choosing the right version of NAMD Args:     Calc (CalcClass): Gets the name of the calculation     MM (MMClass): Gets the path to executables     QM (QMClass): Gets wheter to use the GPU.</p> Source code in <code>Standalone.py</code> <pre><code>def calc_run(Calc: CalcClass, MM: MMClass, QM: QMClass):\n    \"\"\"\n    Handles the running of the calculations. Choosing the right version of NAMD\n    Args:\n        Calc (CalcClass): Gets the name of the calculation\n        MM (MMClass): Gets the path to executables\n        QM (QMClass): Gets wheter to use the GPU.\n\n    \"\"\"\n    print(f\"INFO: Running the {Calc.Name} Calculation.\\n\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n    if  QM == False:\n        print(f\"INFO: {MM.GPUNamd} +oneWthPerCore +setcpuaffinity +devices 0 +cs {globals.WorkDir}{Calc.Name}.conf &gt; {globals.WorkDir}{Calc.Name}_1.0.out\\n\" \n              if globals.verbosity &gt;=2 else \"\", end=\"\")\n        subprocess.run([MM.GPUNamd +\n                        f\" +oneWthPerCore +setcpuaffinity +devices 0 +cs {globals.WorkDir}{Calc.Name}.conf &gt; {globals.WorkDir}{Calc.Name}_1.0.out\"],\n                       shell=True, capture_output=True)\n    else:\n        subprocess.run([\"mkdir /dev/shm/NAMD_QMMM\"], shell=True)\n        subprocess.run([MM.CPUNamd +\n                        f\" +p1 {globals.WorkDir}{Calc.Name}.conf &gt; {globals.WorkDir}{Calc.Name}_1.0.out\"],\n                       shell=True, capture_output=True)\n        subprocess.run([\"rm -r /dev/shm/NAMD_QMMM\"], shell=True)\n</code></pre>"},{"location":"Standalone/Examples/","title":"Some example input files","text":""},{"location":"Standalone/Examples/#minimsation","title":"Minimsation","text":""},{"location":"Standalone/Examples/#setup","title":"Setup","text":""},{"location":"Standalone/Examples/#heat","title":"Heat","text":""},{"location":"Standalone/Examples/#setup_1","title":"Setup:","text":""},{"location":"Standalone/Examples/#pre-requisit-files","title":"Pre-requisit files:","text":"<ul> <li>min_1.0.restart.coor</li> <li>start.rst7</li> <li>complex.parm7</li> </ul>"},{"location":"Standalone/Examples/#input-file","title":"Input file:","text":"heat.inp<pre><code># Heat file, heats to 300 k over 300 ps.\nStartFile=min_1.0.restart.coor\nEnsemble=heat                   # Heats to 300k\nSteps=150000                    # 300 ps with dt = 2fs\nDryRun=False\nName=heat\nRestartOut=100\nTrajOut=500                     # Generates 300 trajectory frames\n</code></pre> RestrainedHeat.inp<pre><code>SMD=True\nForce=0.50\nStartValue=1.3\nEndValue=1.3                    # Constant restraint (1.3 Ang)\nAtomMask=13717,13734,0,0        # Bond Restraint\nStartFile=min_1.0.restart.coor  # Starts from min file\nEnsemble=heat                   # Heats to 300k\nSteps=150000                    # Heat over 300 ps \nDryRun=False\nName=RestrainedHeat\nRestartOut=100\nTrajOut=500\n</code></pre>"},{"location":"Standalone/Examples/#run","title":"Run:","text":""},{"location":"Standalone/Examples/#command","title":"Command:","text":"<p><code>Standalone -i heat.inp</code></p>"},{"location":"Standalone/Examples/#outputs","title":"Outputs:","text":"<ul> <li>heat_1.0.out</li> <li>heat_1.0.coor</li> <li>heat_1.0.dcd</li> <li>heat_1.0.out</li> <li>heat_1.0.restart.coor</li> <li>heat_1.0.restart.vel</li> <li>heat_1.0.restart.xsc</li> <li>heat_1.0.vel</li> <li>heat_1.0.xsc</li> <li>heat.conf</li> </ul>"},{"location":"Standalone/Examples/#restrained-equilibration","title":"Restrained Equilibration","text":"RestrainedEquilibration.inp<pre><code>SMD=True                            # Turns on Colvar module\nForce=0.10\nStartValue=40                       # Restrain rather than SMD\nEndValue=40                         # Restrain rather than SMD\nAtomMask=13717,13734,13759,13762    # Dihedral restraint\nStartFile=heat_1.0.restart.coor     # Reads in Heat file\nEnsemble=NVT                        # Constant volume\nSteps=150000                        # 300 ps equil (2fs time step)\nDryRun=False\nName=equil_rest\nRestartOut=100\nTrajOut=1500\n</code></pre>"},{"location":"Standalone/Overview/","title":"Standalone Calculations","text":""},{"location":"Standalone/Overview/#overview","title":"Overview","text":"<p>In the workflow of designing a QM/MM umbrella sampling automation program, the tools required to run standard MD and QM/MM calculations were generated. </p> <p>We therefore added an interface that access these tools to allow the end user to quickly setup and run MD and QM/MM calculations. The tool uses the same file formats as the umbrella sampling code, and also reads in standard MD parameters that can be edited in the UserVars directory.  </p>"},{"location":"Standalone/Overview/#usage","title":"Usage","text":"<p>To use the standalone code, you can run:</p> <pre><code>Standalone --help # Gets all cli variables\n</code></pre> <p>For a more in-depth usage guide: Read this</p>"},{"location":"Standalone/Overview/#examples","title":"Examples","text":"<p>There are also example input files for a variety of different calculation types. </p>"},{"location":"Standalone/usage/","title":"Usage","text":""},{"location":"Standalone/usage/#setup","title":"Setup","text":"<p>To run a standalone simulation, you need some key initial files:</p> <ul> <li><code>Parameter file</code> (default = complex.parm7) Can be changed using <code>pyBrella --ParmFile PARM</code></li> <li><code>Coordinate file</code> (default = start.rst7) Can be changed using <code>pyBrella --StartFile COORD</code></li> <li><code>Amber Coordinate file</code> (default = start.rst7) Can be changed using <code>pyBrella --AmberCoordinates COORD</code>, This needs to be an amber file to link with amber parameters</li> </ul> <p>You also have cli variables that tune the calculation. They are handled by the input parser</p>"},{"location":"Standalone/usage/#running-recommended","title":"Running (recommended)","text":"<p>To run a Standalone calculation, we recommend generating an input file, defining any variables that differ from those in the default variables</p> <p>The code can then be executed using: <code>standalone -i INPUTFILE</code></p> <p>INPUTFILE must be in the format:</p> <pre><code># Lines starting with '#' will be ignored\n# All inputs should be on a new line\nKEYWORD1=VARIABLE1\nKEYWORD2=VARIABLE2\n</code></pre>"},{"location":"Standalone/usage/#running-not-recommended","title":"Running (not recommended)","text":"<p>You can also run a simulation directly from the command line. All user variables can be parsed and this is handled by the input parser</p>"},{"location":"Standalone/usage/#user-inputs","title":"User Inputs","text":"<p>The default inputs can be found and edited in <code>UserVars/Defaultinputs.py</code>, </p> <p>Here is a list of the main variables that can be changed:</p>"},{"location":"Standalone/usage/#general","title":"General","text":"<pre><code>\"WorkDir\" : \"./\",# str: relative or absolute path to calculation\n\"Verbosity\" : 0, # int: 0=Errors, 1=Warnings, 2=Info, 3=Debug\n\"DryRun\" : True, # bool: Whether to actually run calculations\n</code></pre>"},{"location":"Standalone/usage/#calculation","title":"Calculation","text":"<pre><code>\"CoresPerJob\" : 4, # int: Number of CPU cores for the calc.\n\"MemoryPerJob\" : 4, # int: Ammount of RAM for the calc.\n\"Name\" : \"Name\", # str: Name of calculation.\n\"Ensemble\" : \"min\", # str: min, heat, NVT, NVP\n</code></pre>"},{"location":"Standalone/usage/#qm","title":"QM","text":"<pre><code>\"QM\" : False, # bool: To select the use of qmmm, requires the use of a qm file. \n\"QmFile\" : \"None\", # str:  Name of qm file containing qm parms. \n\"QmSelection\" : \"resname CTN POP MG\", # str: vmd selection algebra for the QM region\n\"QmCharge\" : 1, # int: Net charge of QM system\n\"QmSpin\" : 0, # int: Spin state of QM system\n\"QmMethod\" : \"PBE\", # str: ORCA QM method\n\"QmBasis\" : \"6-31+G*\", # str: ORCA QM basis set.\n\"QmArgs\" : \"MINIPRINT D3BJ TightSCF CFLOAT\", # str: extra information to parse to ORCA\n</code></pre>"},{"location":"Standalone/usage/#mm","title":"MM","text":"<pre><code>\"MMFile\" : \"None\", # str: file containing qm information.\n\"Steps\" : 1000, # int: Number of steps to simulate.\n\"TimeStep\" : 2, # float: timestep in fs. if &gt;1, shake will be turned on. \n\"ParmFile\" : \"complex.parm7\", # str: parameter file. Currently only amber params supported.\n\"AmberCoordinates\" : \"start.rst7\", # str: amber coordinate file for use with the parameter files.\n\"StartFile\" : \"start.rst7\", # str: Amber or NAMD coordinates, start coordinates for THIS simulation.\n\"RestartOut\" : 10, # int: frequency of updating the restart file.\n\"TrajOut\" : 50, # int: frequency of updating the trajectory file.\n\"SMD\" : False, # bool: Whether to use Steered MD.\n\"SMDFile\" : None, # str: Name of file containing SMD parms\n\"Force\" : 0, # float: Force to perform SMD\n\"StartValue\" : 0, # float: start value for SMD\n\"EndValue\" : 0, # float: end value for SMD\n\"AtomMask\" : \"0,0,0,0\", # str: Atom mask for SMD, comma delimited string of atoms. \n\"HPC\" : False, # bool: Run using a SLURM Scheduler.\n</code></pre>"},{"location":"Umbrella/CodeReference/","title":"pyBrella","text":""},{"location":"Umbrella/CodeReference/#umbrella-code","title":"Umbrella code","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.VisInit","title":"<code>VisInit(Umbrella, File, extension='restart.coor')</code>","text":"<p>Initialises a tcl script to allow the opening of a stage of the calculation as a single trajectory..</p> <p>Parameters:</p> Name Type Description Default <code>Umbrella</code> <code>UmbrellaClass</code> <p>UmbrellaClass containing directory structure information</p> required <code>File</code> <code>str</code> <p>name of stage eg equil_1</p> required <code>extension</code> <code>str</code> <p>File extenstion of the structures. Loads NAMD restart files but could be adapted. Defaults to \"restart.coor\".</p> <code>'restart.coor'</code> Source code in <code>pyBrella.py</code> <pre><code>def VisInit(Umbrella: UmbrellaClass, File: str, extension=\"restart.coor\"):\n    \"\"\"Initialises a tcl script to allow the opening of a stage of the calculation as a single trajectory..\n\n    Args:\n        Umbrella (UmbrellaClass): UmbrellaClass containing directory structure information\n        File (str): name of stage eg equil_1\n        extension (str, optional): File extenstion of the structures. Loads NAMD restart files but could be adapted. Defaults to \"restart.coor\".\n    \"\"\"\n    Lines = [None] * (Umbrella.Bins + 1)\n    Lines[0] = f\"mol new {globals.parmfile}\"\n    for i in range(Umbrella.Bins):\n        Lines[i+1] = f\"mol addfile ./{i}/{File}.{i}.{extension}\"\n    utils.file_write(f\"{globals.WorkDir}/{File}_load.tcl\", lines=Lines)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.VisLoad","title":"<code>VisLoad(File)</code>","text":"<p>Loads up a tcl script into vmd</p> <p>Parameters:</p> Name Type Description Default <code>File</code> <code>str</code> <p>file name of step trying to visualise eg. equil_1</p> required Source code in <code>pyBrella.py</code> <pre><code>def VisLoad(File:str): # pragma: no cover\n    \"\"\"Loads up a tcl script into vmd\n\n    Args:\n        File (str): file name of step trying to visualise eg. equil_1\n    \"\"\"\n    subprocess.run([f\"vmd -e {File}_load.tcl\"], shell=True, capture_output=True)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.class_init","title":"<code>class_init(args)</code>","text":"<p>Initialises some key dictionary</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>dict</code> <p>User inputs and variables</p> required <p>Returns:</p> Name Type Description <code>Calc</code> <code>CalcClass</code> <p>Class containing calculation variables</p> <code>MM</code> <code>MMClass</code> <p>Class containing MD variables</p> <code>QM</code> <code>QMClass</code> <p>Class containing QM variables</p> <code>Umbrella</code> <code>UmbrellaClass</code> <p>Class containing Umbrella variables</p> <code>SLURM</code> <code>SLURMClass</code> <p>Class containing Slurm variables for HPC usage</p> Source code in <code>pyBrella.py</code> <pre><code>def class_init(args: dict):\n    \"\"\" Initialises some key dictionary\n\n    Args:\n        args (dict): User inputs and variables\n\n    Returns:\n        Calc (CalcClass): Class containing calculation variables\n        MM (MMClass): Class containing MD variables\n        QM (QMClass): Class containing QM variables\n        Umbrella (UmbrellaClass): Class containing Umbrella variables\n        SLURM (SLURMClass): Class containing Slurm variables for HPC usage\n    \"\"\"\n    Umbrella = UmbrellaClass(args,args[\"UmbrellaMin\"], args[\"UmbrellaBins\"],\n                             args[\"StartDistance\"], args[\"UmbrellaWidth\"],)\n    Calc = CalcClass(args)\n    MM = MMClass()\n    QM = QMClass(args)\n    bins = utils.init_bins(Umbrella.Bins, Umbrella.Width, Umbrella.Min)\n    Umbrella.add_bins(bins)\n    SLURM = SLURMClass(args)\n    SLURM.set_IDNumber()\n    return Calc, MM, QM, Umbrella, SLURM\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.const","title":"<code>const(MM, QM, Calc, Umbrella, PreviousJob)</code>","text":"Source code in <code>pyBrella.py</code> <pre><code>def const(MM: MMClass, QM: QMClass, Calc: CalcClass, Umbrella: UmbrellaClass, PreviousJob:str):\n    MM.Set_Force(Umbrella.ConstForce)\n    if Calc.MaxSteps == 0:\n        NumJobs = 1\n        MM.Set_Length(MM.Steps, MM.TimeStep)\n    else:\n        NumJobs = math.ceil(MM.Steps/Calc.MaxSteps)\n        MM.Set_Length(Calc.MaxSteps, MM.TimeStep)\n    NAMD = NAMDClass(Calc, MM)\n    NAMD.set_pme(\"off\")\n    NAMD.set_cellvectors(MM.CellVec)\n    NAMD.set_colvars(\"colvars.const.conf\")\n    JobList = [None] * Umbrella.Bins * NumJobs\n    for i in range(Umbrella.Bins):\n        colvar = utils.colvar_gen(Umbrella, i, \"constant\", Umbrella.ConstForce)\n        utils.file_write(f\"{globals.WorkDir}{i}/colvars.const.conf\",[colvar])\n        for j in range(NumJobs):\n            place = j * Umbrella.Bins + i\n            JobList[place] = f\"sleep 2 ; ( mkdir /dev/shm/RUNDIR_{i} ; cd ./{i} ; {MM.CPUNamd} {Calc.Name}_{j+1}.conf &gt; {Calc.Name}_{j+1}.{i}.out ; cd ../ ; rm -r /dev/shm/RUNDIR_{i} ) &amp;\"\n            NAMD.set_qm(Calc, QM, i)\n            if j == 0:\n                NAMD.set_startcoords(f\"{PreviousJob}.{i}.restart.coor\")\n                file = FileGen.Namd_File(NAMD, j+1, i)\n                utils.file_write(f\"{globals.WorkDir}{i}/{Calc.Name}_{j + 1}.conf\",\n                                 [file])\n            else:\n                NAMD.set_startcoords(f\"{Calc.Name}_{j}.{i}.restart.coor\")\n                file = FileGen.Namd_File(NAMD, j + 1, i)\n                utils.file_write(f\"{globals.WorkDir}{i}/{Calc.Name}_{j + 1}.conf\",\n                                 [file])\n    for i in range(NumJobs):\n        lines = i * Umbrella.Bins\n        utils.file_write(f\"{globals.WorkDir}{Calc.Name}_{i + 1}.txt\",\n                         JobList[lines : lines + Umbrella.Bins])\n    if globals.DryRun == False:\n        print(\"ERROR: Local umbrella run is not currently supported. We recommend you submit to a HPC\")\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.heat","title":"<code>heat(MM, Calc)</code>","text":"<p>Sets up and runs the heating calculation Args:     MM (MMClass): Class containing dynamics information     Calc (CalcClass): Class containing calculation information</p> Source code in <code>pyBrella.py</code> <pre><code>def heat(MM: MMClass, Calc: CalcClass):\n    \"\"\"\n    Sets up and runs the heating calculation\n    Args:\n        MM (MMClass): Class containing dynamics information\n        Calc (CalcClass): Class containing calculation information\n    \"\"\"\n    MM.Set_Ensemble(\"heat\")\n    MM.Set_Outputs(200, 10, 100)\n    MM.Set_Length(10000)\n    Calc.Job_Name(\"heat\")\n    NAMD = NAMDClass(Calc, MM)\n    NAMD.set_pme(\"on\")\n    NAMD.set_startcoords(\"min_1.0.restart.coor\", ambercoor=\"start.rst7\", parm=globals.parmfile)\n    NAMD.set_cellvectors(MM.CellVec)\n    file = FileGen.Namd_File(NAMD)\n    utils.file_write(f\"{globals.WorkDir}heat.conf\", [file])\n    if globals.DryRun == False: # pragma: no cover\n        print(\"INFO: Running the heat calculation\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n        subprocess.run([MM.GPUNamd + f\" +oneWthPerCore +setcpuaffinity +devices 0 heat.conf &gt; heat_1.0.out\"],\n                       shell=True, capture_output=True)\n        subprocess.run([\"mv heat* ./setup\", ],\n                   shell=True, capture_output=True)\n        subprocess.run([\"cp ./setup/heat_1.0.restart.coor .\", ],\n                    shell=True, capture_output=True)\n        subprocess.run([\"cp ./setup/heat_1.0.out .\", ],\n                    shell=True, capture_output=True)\n        subprocess.run([\"cp ./setup/heat.conf .\"],\n                    shell=True, capture_output=True)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.main","title":"<code>main()</code>","text":"<p>Main Umbrella sampling executable. This deals with everything and can be run from the command line.</p> Source code in <code>pyBrella.py</code> <pre><code>def main():\n    \"\"\"Main Umbrella sampling executable. This deals with everything and can be run from the command line. \n    \"\"\"\n    starttime = time.time()\n    args = input.UmbrellaInput(sys.argv[1:],) \n    verbosity = args[\"Verbosity\"]\n    assert type(verbosity) is int, f\"ERROR: verbosity statement must be an integer, not {verbosity}\"\n    WorkDir = args[\"WorkDir\"]\n    assert path.isdir(f\"{WorkDir}\"), f\"ERROR: User defined working directory: {WorkDir} Does not exist!\"\n    dr = args[\"DryRun\"]   \n    if dr == \"True\" or dr == True:\n        DryRun = True\n    elif dr == \"False\" or dr == False: # pragma: no cover\n        DryRun = False\n    assert type(DryRun) is bool, f\"ERROR: DryRun must be a boolean, not {DryRun}!\"\n    parmfile = args[\"ParmFile\"]\n    assert path.isfile(f\"{WorkDir}{parmfile}\"), f\"ERROR: {parmfile} does not exist in the working directory!\"\n    globals.init(v=verbosity, wd=WorkDir,dr=DryRun, parm=parmfile)\n    Calc, MM, QM, Umbrella, SLURM = class_init(args)\n    equil_length = int(args[\"EquilLength\"])*2000 # Number of steps to equilibrate each window. converts from ps to steps in 0.5 fs timsteps\n    prod_length = int(args[\"ProdLength\"])*2000 # Number of steps to run production for each window.\n    assert type(equil_length) is int, f\"ERROR: equil length must be an integer. Cant do half steps... {equil_length}\"\n    assert type(prod_length) is int, f\"ERROR: prod length must be an integer, cant do half steps {prod_length}\"\n    AnalIgnore = [] # Bins to ignore for analysis... Use with caution.\n    if args[\"Stage\"].casefold() == \"setup\":\n        setup(QM, Umbrella)\n    if args[\"Stage\"].casefold() == \"min\":\n        min(MM, Calc, args[\"StartFile\"])\n    if args[\"Stage\"].casefold() == \"heat\":\n        heat(MM, Calc)\n    if args[\"Stage\"].casefold() == \"pull\":\n        pull(Umbrella, MM, QM, Calc)\n    if args[\"Stage\"].casefold() == \"equil\":\n        MM.Set_Ensemble(\"NVT\")\n        Calc.Job_Name(\"equil\")\n        MM.Set_Length(equil_length, 0.5)  # 2000 steps at 0.5 fs = 1 ps ~ 1 day\n        MM.Set_Outputs(100, 100, 80)\n        const(MM, QM, Calc, Umbrella, \"pull_1\")\n        SLURM.set_arrayJob(\"equil_1.txt\", Umbrella.Bins)\n        utils.slurm_gen(\"NAME\", SLURM, \"sh array_job.sh\", globals.WorkDir)\n        utils.batch_sub(5,20, )\n    if args[\"Stage\"].casefold() == \"prod\":\n        Calc.Job_Name(\"prod\")\n        MM.Set_Ensemble(\"NVT\")\n        MM.Set_Length(prod_length, 0.5)  # 8000 steps at 0.5 fs = 4 ps, ~ 3.5 days\n        MM.Set_Outputs(100, 100, 80)  # Timings, Restart, Trajectory\n        if Calc.MaxSteps == 0:\n            num = 1\n        else:\n            num = math.ceil(equil_length/Calc.MaxSteps)\n        const(MM, QM, Calc, Umbrella, f\"equil_{num}\")\n    if args[\"Stage\"].casefold() == \"wham\":\n        if Calc.MaxSteps == 0:\n            NumJobs = 1\n        else:\n            if \"prod\" in args[\"AnalFile\"].casefold():\n                steps = prod_length\n            elif \"equil\" in args[\"AnalFile\"].casefold():\n                steps = equil_length\n            else:\n                steps = 0\n            NumJobs = math.ceil(steps / Calc.MaxSteps)\n        if \"_\" not in args[\"AnalysisFile\"].casefold():\n            if globals.verbosity &gt;= 1:\n                print(f\"Number of steps to glue together is {NumJobs}\")\n            Anal.glue_stick(Umbrella, NumJobs=NumJobs, file=args[\"AnalFile\"])\n        if Umbrella.atom3 != 0:\n            periodicity = \"periodic\"\n        else:\n            periodicity = \"discrete\"\n        wham = WhamClass(args[\"AnalysisFile\"], Umbrella.ConstForce, periodicity)\n        Wham.Init_Wham(Umbrella, wham, WhamIgnore=AnalIgnore)\n        Wham.Run_Wham(Umbrella, WhamIgnore=AnalIgnore)\n    if args[\"Stage\"].casefold() == \"analysis\": # pragma: no cover\n        Anal.analysis(Umbrella)\n    if args[\"Stage\"].casefold() == \"convergence\":\n        Wham.convergence(Calc, args[\"AnalysisFile\"], equil_length, prod_length, Umbrella)\n    if args[\"Stage\"].casefold() == \"vis\":\n        VisInit( Umbrella, args[\"AnalysisFile\"])\n        if globals.DryRun == \"False\":\n            VisLoad(args[\"AnalysisFile\"])\n    endtime = time.time()\n    print(f\"Total time is {endtime - starttime}\")\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.make_runfile","title":"<code>make_runfile(Umbrella, Joblist)</code>","text":"<p>Generates the pull.sh file to be run either locally or on the HPC</p> <p>Parameters:</p> Name Type Description Default <code>Umbrella</code> <code>UmbrellaClass</code> <p>Contains bin information</p> required <code>Joblist</code> <code>list</code> <p>List of jobs to run.</p> required Source code in <code>pyBrella.py</code> <pre><code>def make_runfile(Umbrella: UmbrellaClass, Joblist: list):\n    \"\"\"Generates the pull.sh file to be run either locally or on the HPC\n\n    Args:\n        Umbrella (UmbrellaClass): Contains bin information\n        Joblist (list): List of jobs to run.\n    \"\"\"\n    print(\"INFO: Generating pull.sh script.\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n    with open(f\"{globals.WorkDir}pull.sh\", 'w') as f:\n        print(\"#!/bin/bash\", file=f)\n        for i in range(Umbrella.StartBin, Umbrella.Bins):\n            print(Joblist[i], file=f)\n        for i in range(0, Umbrella.StartBin):\n            print(Joblist[Umbrella.StartBin - i - 1], file=f)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.make_umbrellaDirs","title":"<code>make_umbrellaDirs(Umbrella)</code>","text":"<p>Makes the directory structure for umbrella calculation</p> <p>Parameters:</p> Name Type Description Default <code>Umbrella</code> <code>UmbrellaClass</code> <p>Contains information about bins.</p> required Source code in <code>pyBrella.py</code> <pre><code>def make_umbrellaDirs(Umbrella: UmbrellaClass):\n    \"\"\"Makes the directory structure for umbrella calculation\n\n    Args:\n        Umbrella (UmbrellaClass): Contains information about bins.\n    \"\"\"\n    print(\"INFO: Making umbrella directories\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n    for i in range(Umbrella.Bins):\n        dir_path = str(globals.WorkDir) + str(i)\n        if path.exists(dir_path):\n            print(f\"INFO: {str(i)} exists. Deleting!\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n            try:\n                os.rmdir(dir_path)\n            except OSError:\n                print(f\"INFO: {i} directory not empty, deletion failed...\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n                pass\n        try:\n            os.mkdir(dir_path)\n        except FileExistsError:\n            print(f\"INFO: {i} directory exists, Skipping making new directory\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n            pass\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.min","title":"<code>min(MM, Calc, StartFile)</code>","text":"<p>sets up and runs the initial minimisation run (Pure MD)</p> <p>Parameters:</p> Name Type Description Default <code>MM</code> <code>MMClass</code> <p>Class containing dynamics information</p> required <code>Calc</code> <code>CalcClass</code> <p>Class containing calculation information</p> required <code>StartFile</code> <code>str</code> <p>Start coordinates pre minimisation.</p> required Source code in <code>pyBrella.py</code> <pre><code>def min(MM: MMClass, Calc: CalcClass, StartFile: str):    \n    \"\"\"sets up and runs the initial minimisation run (Pure MD)\n\n    Args:\n        MM (MMClass): Class containing dynamics information\n        Calc (CalcClass): Class containing calculation information\n        StartFile (str): Start coordinates pre minimisation.\n    \"\"\"\n    print(globals.WorkDir)\n    MM.Set_Ensemble(\"min\")\n    MM.Set_Outputs(1000, 100, 0)\n    MM.Set_Length(10000)\n    Calc.Job_Name(\"min\")\n    NAMD = NAMDClass(Calc, MM)\n    NAMD.set_pme(\"on\")\n    if StartFile == \"start.rst7\":\n        NAMD.set_startcoords(None, ambercoor=\"start.rst7\", parm=globals.parmfile)\n    else:\n        NAMD.set_startcoords(bincoor=StartFile, ambercoor=\"start.rst7\", parm=globals.parmfile)\n    NAMD.set_cellvectors(MM.CellVec)\n    file = FileGen.Namd_File(NAMD)\n    utils.file_write(f\"{globals.WorkDir}min.conf\", [file])\n    print(f\"{globals.WorkDir}min.conf\")\n    if globals.DryRun == False: # pragma: no cover\n        print(\"INFO: Running the minimisation script\" if globals.verbosity &gt;=2 else\"\", end=\"\" )\n        subprocess.run([MM.GPUNamd + f\" +oneWthPerCore +setcpuaffinity +devices 0 min.conf &gt; min_1.0.out\"],\n                       shell=True, capture_output=True)\n        print(\"INFO: Minimisation complete, cleaning up directory\" if globals.verbosity &gt;=2 else\"\", end=\"\" )\n        output = subprocess.run([\"mv min* ./setup\", \"cp ./setup/min_1.0.restart.coor .\",\n                    \"cp ./setup/min_1.0.out .\", \"cp ./setup/min.conf .\"],\n                   shell=True, capture_output=True)\n        output = subprocess.run([\"cp ./setup/min_1.0.restart.coor .\", ],\n                   shell=True, capture_output=True)\n        output = subprocess.run([\"cp ./setup/min_1.0.out .\"],\n                   shell=True, capture_output=True)\n        output = subprocess.run([\"cp ./setup/min.conf .\"],\n                   shell=True, capture_output=True)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.pull","title":"<code>pull(Umbrella, MM, QM, Calc)</code>","text":"Source code in <code>pyBrella.py</code> <pre><code>def pull(Umbrella: UmbrellaClass, MM: MMClass, QM: QMClass, Calc: CalcClass):\n    make_umbrellaDirs(Umbrella)\n    print(\"INFO: Setting up pulls\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n    MM.Set_Ensemble(\"NVT\")\n    MM.Set_Length(50,0.5)\n    MM.Set_Outputs(5,1,10)\n    MM.Set_Shake(\"none\")\n    MM.Set_Force(Umbrella.PullForce)\n    Calc.Job_Name(\"pull\")\n    Calc.Set_OutFile(\"pull\")\n    NAMD = NAMDClass(Calc, MM)\n    NAMD.set_cellvectors(MM.CellVec)\n    Joblist = [None]*Umbrella.Bins\n    for i in range(Umbrella.Bins):\n       if abs(Umbrella.BinVals[i] - Umbrella.Start) &lt; abs(Umbrella.Width * 0.5):\n           Umbrella.add_start(i)\n    for i in range(Umbrella.Bins):\n        if i &lt; Umbrella.StartBin:\n            prevPull = f\"../{i + 1}/pull_1.{i + 1}.restart.coor\"\n        elif i &gt; Umbrella.StartBin:\n            prevPull = f\"../{i-1}/pull_1.{i-1}.restart.coor\"\n        elif i == Umbrella.StartBin:\n            prevPull = f\"../heat_1.0.restart.coor\"#\n            print(f\"Pull starts from directory {i}\")\n        NAMD.set_qm(Calc, QM, i)\n        NAMD.set_startcoords(prevPull)\n        NAMD.set_colvars(\"colvars.pull.conf\")\n        file = FileGen.Namd_File(NAMD, window=i)\n        utils.file_write(f\"{globals.WorkDir}{i}/pull.conf\", [file])\n        colvarfile = utils.colvar_gen(Umbrella, i, \"pull\", Umbrella.PullForce )\n        utils.file_write(f\"{globals.WorkDir}{i}/colvars.pull.conf\", [colvarfile])\n        Joblist[i] = f\"mkdir /dev/shm/NAMD_{i} ; cd ./{i} ; {MM.CPUNamd} pull.conf &gt; pull_1.{i}.out ; cd ../ ; rm -r /dev/shm/NAMD_{i}\"\n    utils.file_write(f\"{globals.WorkDir}pull.txt\",Joblist)\n    make_runfile(Umbrella, Joblist)\n    if globals.DryRun == False: # pragma: no cover\n        print(\"INFO: Running serial pulls.\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n        run_out = subprocess.run([f\"sh {globals.WorkDir}pull.sh\"], shell=True, capture_output=True)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.setup","title":"<code>setup(QM, Umbrella)</code>","text":"<p>Generates a setup directory and creates the syst-*.pdb files</p> <p>Parameters:</p> Name Type Description Default <code>QM</code> <code>QMClass</code> <p>QM class containing QM section</p> required <code>Umbrella</code> <code>UmbrellaClass</code> <p>Umbrella Class containing colvar information</p> required Source code in <code>pyBrella.py</code> <pre><code>def setup(QM: QMClass, Umbrella: UmbrellaClass):\n    \"\"\"\n    Generates a setup directory and creates the syst-*.pdb files\n\n    Args:\n        QM (QMClass): QM class containing QM section\n        Umbrella (UmbrellaClass): Umbrella Class containing colvar information\n    \"\"\"\n    if path.isdir(f\"{globals.WorkDir}setup\") == False: ### Make setup directory. Not essential but makes dirs cleaner\n        print(\"INFO: Making the setup directory\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n        os.mkdir(f\"{globals.WorkDir}setup\")\n    utils.QM_Gen(QM.QMSel)\n    if globals.DryRun == False: \n        print(\"INFO: Setting up the syst-qm.pdb file.\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n        logfile = subprocess.run([\"vmd\", \"-dispdev\", \"text\", \"-e\", \"qm_prep.tcl\"],\n                                     text = True, capture_output = True)\n        with open(f\"{globals.WorkDir}setup/tcl-qm.log\",\"w\") as f:\n            print(logfile, file=f)\n    utils.ColVarPDB_Gen(Umbrella)\n    if globals.DryRun == False:\n        print(\"INFO: Setting up the Colvar pdb file.\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n        logfile = subprocess.run([\"vmd\", \"-dispdev\", \"text\", \"-e\", \"Colvar_prep.tcl\"],\n                                    text = True, capture_output = True)\n        print(logfile)\n        with open(f\"{globals.WorkDir}setup/tcl-colvar.log\",\"w\") as f:\n            print(logfile, file=f)\n</code></pre>"},{"location":"Umbrella/CodeReference/#wham-code","title":"Wham code","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Umbrella.wham.Init_Wham","title":"<code>Init_Wham(Umbrella, Wham, WhamIgnore=[])</code>","text":"<p>Initialises the WHAM directory and generates files</p> <p>Parameters:</p> Name Type Description Default <code>Umbrella</code> <code>UmbrellaClass</code> <p>Umbrella Variables</p> required <code>Wham</code> <code>WhamClass</code> <p>Wham variables</p> required <code>WhamIgnore</code> <code>list</code> <p>List of windows to ignore (Incase error)</p> <code>[]</code> Source code in <code>Umbrella/wham.py</code> <pre><code>def Init_Wham( Umbrella: UmbrellaClass, Wham: WhamClass, WhamIgnore=[]):\n    \"\"\" Initialises the WHAM directory and generates files\n\n    Args:\n        Umbrella (UmbrellaClass): Umbrella Variables\n        Wham (WhamClass): Wham variables\n        WhamIgnore (list): List of windows to ignore (Incase error)\n    \"\"\"\n    hist_bar = []\n    hist_count = []\n    try:\n        os.mkdir(f\"{globals.WorkDir}/WHAM/\")\n    except:\n        log.warning(\"Wham directory already exists\")\n    if os.path.exists(f\"{globals.WorkDir}/WHAM/{Wham.Name}metadata.dat\"):\n        os.remove(f\"{globals.WorkDir}/WHAM/{Wham.Name}metadata.dat\")\n    for i in range(0,Umbrella.Bins):    # Ignore line 1...\n        if i in WhamIgnore:\n            continue\n        time, value = utils.data_2d(f\"{globals.WorkDir}{i}/{Wham.Name}.{i}.colvars.traj\")\n        integral_time = autocorrelate(value)\n        counts, bins, bars = plt.hist(value, 100)\n        hist_count.extend(counts)\n        hist_bar.extend(bins)\n        with open(f\"{globals.WorkDir}WHAM/{Wham.Name}metadata.dat\",'a') as f:\n            txt = f\"../{i}/{Wham.Name}.{i}.colvars.traj {round(Umbrella.BinVals[i],3)} {float(Wham.Force)} {int(integral_time)}\" ##ORCA equation for harmonic restraints: V = 0.5*k (a - a0)^2\n            print(txt, file = f)\n        # subprocess.run([f\"head {globals.WorkDir}{i}/{Wham.Name}.{i}.colvars.traj -n 4005 &gt; {globals.WorkDir}{i}/{Wham.Name}.{i}.colvars.2ps.traj\"], shell=True,)\n        # print(f\"head {globals.WorkDir}{i}/{Wham.Name}.{i}.colvars.traj -n 4005 &gt; {globals.WorkDir}{i}/{Wham.Name}.{i}.colvars.2ps.traj\")\n    plt.xlabel(\"Reaction coordinate\")\n    plt.ylabel(\"Count\")\n    if globals.verbosity &gt;= 2 :\n        plt.show()\n    else:\n        plt.clf()\n    with open(f\"{globals.WorkDir}WHAM/{Wham.Name}UmbrellaHist.dat\", 'w') as f:\n        for i in range(len(hist_count)):\n            print(str(hist_bar[i]) + \"\\t\" + str(hist_count[i]), file=f)\n    with open(f\"{globals.WorkDir}WHAM/wham.sh\", 'w') as f:\n        if Wham.Type == \"Periodic\":\n            P=\"P\"\n        else:\n            P=\"\"\n        if Umbrella.BinVals[0] &gt;  Umbrella.BinVals[Umbrella.Bins-1]:\n            min = Umbrella.BinVals[Umbrella.Bins-1]\n            max = Umbrella.BinVals[0]\n        else:\n            max = Umbrella.BinVals[Umbrella.Bins-1]\n            min = Umbrella.BinVals[0]\n        text = f\"\"\"#!/bin/bash\nwham {P} {min} {max} {Umbrella.Bins-1 - len(WhamIgnore)} 1e-06 {Wham.Force} 0 {Wham.Name}metadata.dat out.pmf 10 60\nsed '1d' out.pmf | awk '{\"{\"}print $1,\"\",$2{\"}\"}' &gt; plot_free_energy.dat\n\"\"\"\n        print(text, file=f)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Umbrella.wham.Run_Wham","title":"<code>Run_Wham(Umbrella, WhamIgnore=[])</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>Umbrella</code> <code>UmbrellaClass</code> <p>Contains information such as force constants and bin b</p> required <code>WhamIgnore</code> <code>list</code> <p>List of bins to exclude. </p> <code>[]</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If wham not working</p> <code>Exception</code> <p>If metadata.dat file not found</p> <p>Returns:</p> Name Type Description <code>y</code> <code>list</code> <p>List of energies</p> <code>Err</code> <code>list</code> <p>List of errors</p> Source code in <code>Umbrella/wham.py</code> <pre><code>def Run_Wham(Umbrella: UmbrellaClass, WhamIgnore=[]):# Umbrella, Wham):\n    \"\"\"_summary_\n\n    Args:\n        Umbrella (UmbrellaClass): Contains information such as force constants and bin b\n        WhamIgnore (list, optional): List of bins to exclude. \n\n    Raises:\n        Exception: If wham not working\n        Exception: If metadata.dat file not found\n\n    Returns:\n        y (list): List of energies\n        Err (list): List of errors \n    \"\"\"\n    print(\"INFO: Running WHAM\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n    out = subprocess.run(f\"cd {globals.WorkDir}WHAM ; sh wham.sh ; cd ../\", shell=True, capture_output=True)\n    if \"wham.sh\" in out.stderr.decode():\n        raise Exception(f\"Problem with running wham: {out.stderr.decode()}\")\n    if \"No such file \" in out.stdout.decode():\n        print(out.stdout.decode())\n        raise Exception(\"metadata file not found when runnning wham.sh\")\n    data = utils.file_read(path=f\"{globals.WorkDir}WHAM/out.pmf\")\n    array = [data[i] for i in range(1,Umbrella.Bins-len(WhamIgnore)) ]\n    x = numpy.zeros(len(array))\n    y = numpy.zeros(len(array))\n    err = numpy.zeros(len(array))\n    for line in range(0, len(array)):\n        columns = array[line].split()\n        x[line] = columns[0]\n        y[line] = columns[1]\n        err[line] = columns[2]\n    #print(y)\n    # plt.plot(x,y,)\n    plt.errorbar(x,y,yerr=err, c=\"black\", capsize=5)\n    plt.xlabel(\"Reaction coordinate\")\n    plt.ylabel(\"Energy (kcal $mol^{-1}$)\")\n    plt.title(f\"Wham PMF\")\n    plt.savefig(f\"{globals.WorkDir}WHAM/PMF.eps\",transparent=True)\n    if globals.verbosity &gt;=2 :\n        plt.show()\n    else:\n        plt.clf()\n    plt.errorbar(y=x,x=y,xerr=err, c=\"black\", capsize=5)\n    plt.ylabel(\"Reaction coordinate\")\n    plt.xlabel(\"Energy (kcal $mol^{-1}$)\")\n    plt.title(f\"Wham PMF\")\n    plt.savefig(f\"{globals.WorkDir}WHAM/PMF_AxisSwap.eps\",transparent=True)\n    plt.clf()\n    subprocess.run(f\"head -n {Umbrella.Bins} {globals.WorkDir}WHAM/out.pmf &gt; {globals.WorkDir}WHAM/PMF.dat\", shell=True)\n    subprocess.run(\n    f\"sed -i \\\"0,/+\\/-/s/+\\/-/Err1/\\\" {globals.WorkDir}WHAM/PMF.dat \",\n        shell=True)\n    subprocess.run(\n        f\"sed -i \\\"0,/+\\/-/s/+\\/-/Err2/\\\" {globals.WorkDir}WHAM/PMF.dat\",\n        shell=True)\n    subprocess.run(\n        f\"sed -i \\\"s/#Coor/Coor/g\\\" {globals.WorkDir}WHAM/PMF.dat\",\n        shell=True)\n    return y, err\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Umbrella.wham.autocorrelate","title":"<code>autocorrelate(data)</code>","text":"<p>Uses the emcee package to calculate the time autocorrelation of the collective variable.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list</code> <p>list of colvar data</p> required <p>Returns:</p> Name Type Description <code>integral_time</code> <code>float</code> <p>Time autocorrelation value for the dataset.</p> Source code in <code>Umbrella/wham.py</code> <pre><code>def autocorrelate(data: list):\n    \"\"\"Uses the emcee package to calculate the time autocorrelation of the collective variable.\n\n    Args:\n        data (list): list of colvar data\n\n    Returns:\n        integral_time (float): Time autocorrelation value for the dataset.\n    \"\"\"\n    try:\n        integral_time = emcee.autocorr.integrated_time(data, c=1)\n    except emcee.autocorr.AutocorrError:\n        integral_time = 1\n    except IndexError:\n        integral_time = 1    \n    return integral_time\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Umbrella.wham.convergence","title":"<code>convergence(Calc, AnalFile, equil_length, prod_length, Umbrella)</code>","text":"Source code in <code>Umbrella/wham.py</code> <pre><code>def convergence(Calc: CalcClass, AnalFile: str, equil_length: int, prod_length: int, Umbrella: UmbrellaClass, ):\n    WhamIgnore = []\n    if Calc.MaxSteps == 0:\n        NumJobs = 1\n    else:\n        if \"prod\" in AnalFile.casefold():\n            steps = prod_length\n        elif \"equil\" in AnalFile.casefold():\n            steps = equil_length\n        else:\n            steps = 0\n        NumJobs = math.ceil(steps / Calc.MaxSteps)\n    if globals.verbosity &gt;= 1:\n        print(f\"Number of steps to glue together is {NumJobs}\")\n    try:\n        os.mkdir(f\"{globals.WorkDir}WHAM\")\n    except:\n        pass   \n    try:\n        os.mkdir(f\"{globals.WorkDir}WHAM/Conv\")\n    except:\n        pass\n    for i in range(1,NumJobs+1):\n        print(f\"Performing WHAM on step {i}\")\n        WhamIgnore = Anal.Error_Check(Umbrella=Umbrella, Errors=WhamIgnore, Step=i)\n        print(f\"WARNING: Error windows are: {WhamIgnore}\")\n        if i &gt; 1:\n            prev_y = y\n            #prev_Err = Err\n        Anal.glue_stick(Umbrella, NumJobs=i, file=AnalFile)\n        if Umbrella.atom3 != 0:\n            periodicity = \"periodic\"\n        else:\n            periodicity = \"discrete\"\n        wham = WhamClass(AnalFile, Umbrella.ConstForce, periodicity)\n        Init_Wham(Umbrella, wham, WhamIgnore=WhamIgnore)\n        y, Err = Run_Wham(Umbrella, WhamIgnore=WhamIgnore)\n        convergence=False\n        if i &gt; 1:\n            Diffs = numpy.zeros(len(y))\n            for j in range(len(y)):\n                if y[j] == numpy.inf or prev_y[j] == numpy.inf:\n                    diff = 0\n                else:\n                    diff = abs(y[j]-prev_y[j])\n                if diff == \"nan\":\n                    diff = 0\n                Diffs[j] = diff\n            if numpy.max(Diffs) &lt;= 0.1:\n                convergence = True\n            print(f\"INFO: Maximum difference = {numpy.max(Diffs)}\"if globals.verbosity &gt;=1 else \"\", end=\"\")\n            if convergence == True:\n                print(f\"SUCCESS: Convergence achieved\"if globals.verbosity &gt;=1 else \"\", end=\"\")\n                if numpy.max(Err) &gt; 0.10:\n                    print(f\"INFO: Error bars still too large: {numpy.max(Err)}\" if globals.verbosity &gt;=1 else \"\", end=\"\")\n                else:\n                    break\n        subprocess.run(f\"head -n {Umbrella.Bins} {globals.WorkDir}WHAM/out.pmf &gt; {globals.WorkDir}WHAM/Conv/{i}.pmf\", shell=True)\n        subprocess.run(f\"mv {globals.WorkDir}WHAM/PMF.eps {globals.WorkDir}WHAM/Conv/{i}.eps\", shell=True)\n        subprocess.run(f\"sed -i \\\"0,/+\\/-/s/+\\/-/Err1/\\\" {globals.WorkDir}WHAM/Conv/{i}.pmf \" , shell=True)\n        subprocess.run(\n            f\"sed -i \\\"0,/+\\/-/s/+\\/-/Err2/\\\" {globals.WorkDir}WHAM/Conv/{i}.pmf \",\n            shell=True)\n        subprocess.run(\n            f\"sed -i \\\"s/#Coor/Coor/g\\\" {globals.WorkDir}WHAM/Conv/{i}.pmf\",\n            shell=True)\n</code></pre>"},{"location":"Umbrella/CodeReference/#tools","title":"Tools","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.FileGen","title":"<code>FileGen</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.FileGen.Namd_File","title":"<code>Namd_File(NAMD, substep=1, window=0)</code>","text":"<p>Automates the generation of a NAMD input file. </p> <p>Parameters:</p> Name Type Description Default <code>NAMD</code> <code>NAMDClass</code> <p>Grabs NAMD information.</p> required <code>substep</code> <code>int</code> <p>When breaking long simulations into smaller calcs, use substeps</p> <code>1</code> <code>window</code> <code>int</code> <p>Umbrella window if performing Umbrella sampling</p> <code>0</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If shake is not on but timestep large</p> <p>Returns:</p> Name Type Description <code>NAMD_File</code> <code>str</code> <p>Formatted NAMD file that can then be ran.</p> Source code in <code>Tools/FileGen.py</code> <pre><code>def Namd_File(NAMD: NAMDClass,  substep=1, window=0):\n    \"\"\"\n    Automates the generation of a NAMD input file. \n\n    Args:\n        NAMD (NAMDClass): Grabs NAMD information.\n        substep (int): When breaking long simulations into smaller calcs, use substeps\n        window (int): Umbrella window if performing Umbrella sampling\n\n    Raises:\n        AttributeError: If shake is not on but timestep large\n\n    Returns:\n        NAMD_File (str): Formatted NAMD file that can then be ran. \n\n    \"\"\"\n    # NAMD = NAMDClass(Calc, MM, bincoor=StartCoord)\n    # NAMD.set_cellvectors(MM.CellVec, MM.CellShape)\n    # if QM !=None:\n    #     NAMD.set_qm(Calc, QM)\n    # if MM.PME != \"off\":\n    #     NAMD.set_pme(MM.PME)\n    if NAMD.bincoor == None:\n        bincoor = \"\"\n    else:\n        bincoor = f\"bincoordinates      {NAMD.bincoor}\"\n    if NAMD.timestep &lt; 2 and NAMD.rigidBonds != \"none\":\n        return AttributeError, f\"Timestep is {NAMD.timestep} but shake is on... This will cause errors.\"\n    if int(NAMD.steps) &lt;= 10000:\n        energy = 1\n    elif NAMD.runtype == \"min\":\n        energy = 1\n    else:\n        energy = NAMD.restfreq\n    if NAMD.timestep &gt;=2 and NAMD.rigidBonds == \"none\":\n        print(f\"WARNING: Timestep is {NAMD.timestep} but shake isn't on... this will slow down simulations. running anyway.\")\n    NAMD_File = f\"\"\"### pybrella {NAMD.outfile} input file \n# File options:\nparmfile            {NAMD.parm}\nambercoor           {NAMD.ambercoor}\n{bincoor}\nDCDfile             {NAMD.outfile}_{substep}.{window}.dcd\nDCDfreq             {NAMD.dcdfreq}\nrestartname         {NAMD.outfile}_{substep}.{window}.restart\nrestartfreq         {NAMD.restfreq}\noutputname          {NAMD.outfile}_{substep}.{window}\noutputTiming        {NAMD.timefreq}\noutputEnergies      {energy}\n\n# Calculation options:\namber               {NAMD.amber}\nswitching           {NAMD.switching}\nexclude             {NAMD.exclude}\n1-4scaling          {NAMD.scaling}\nscnb                {NAMD.scnb}\nreadexclusions      {NAMD.readexclusions}\ncutoff              {NAMD.cutoff}\nwatermodel          {NAMD.watermodel}\npairListdist        {NAMD.pairListDist}\nLJcorrection        {NAMD.LJcorrection}\nZeroMomentum        {NAMD.ZeroMomentum}\nrigidBonds          {NAMD.rigidBonds}\nrigidTolerance      {NAMD.rigidTolerance}\nrigidIterations     {NAMD.rigidIterations}\ntimeStep            {NAMD.timestep}\nfullElectFrequency  {NAMD.fullElectFrequency}\nnonBondedFreq       {NAMD.nonBondedFreq}\nstepspercycle       {NAMD.stepspercycle}\n\n\n# PME options:\nPME                 {NAMD.PME}\nPMEGridSizeX        {NAMD.PMEGridSizeX}\nPMEGridSizeY        {NAMD.PMEGridSizeY}\nPMEGridSizeZ        {NAMD.PMEGridSizeZ}\nPMETolerance        {NAMD.PMETolerance}\nPMEInterpOrder      {NAMD.PMEInterpOrder}\n\n# Cell options:\ncellBasisVector1    {NAMD.cellBasisVector1}\ncellBasisVector2    {NAMD.cellBasisVector2}\ncellBasisVector3    {NAMD.cellBasisVector3}\ncellOrigin          {NAMD.cellOrigin}\n\n# Temperature options:\n{NAMD.heating}\n\n# Pressure options:\nBerendsenPressure   {NAMD.BrensdenPressure}\n\n# QMMM options:\nqmForces            {NAMD.qmForces}\n{NAMD.qmLines}\n#CUDAFAST\n\n{NAMD.colvarlines}\n\n{NAMD.runtype}                 {NAMD.steps}\n\"\"\"\n    return NAMD_File\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.FileGen.ORCA_FileGen","title":"<code>ORCA_FileGen(Molecule, ORCA)</code>","text":"<p>Generates an input file for a standalone ORCA calculation</p> <p>Parameters:</p> Name Type Description Default <code>Molecule</code> <code>MolClass</code> <p>Molecular information</p> required <code>ORCA</code> <code>ORCAClass</code> <p>ORCA Calculation information</p> required <p>Returns:</p> Name Type Description <code>file</code> <code>str</code> <p>ORCA input file</p> Source code in <code>Tools/FileGen.py</code> <pre><code>def ORCA_FileGen(Molecule: MolClass, ORCA: ORCAClass):\n    \"\"\"\n    Generates an input file for a standalone ORCA calculation\n\n    Args:\n        Molecule (MolClass): Molecular information\n        ORCA (ORCAClass): ORCA Calculation information\n\n    Returns:  \n        file (str): ORCA input file\n\n    \"\"\"\n    file = f\"\"\"! {ORCA.method} {ORCA.basis} {ORCA.dispersion} {ORCA.dificulty} {ORCA.convergence} {ORCA.grid} {ORCA.restart} {ORCA.calculation} {ORCA.extras}\n%PAL NPROCS {ORCA.cores} END\n\n*xyz {Molecule.charge} {Molecule.spin}\n\"\"\"\n    for i in range(Molecule.nat):\n        file += f\"{Molecule.element[i]} {round(float(Molecule.x[i]),4)} {round(float(Molecule.y[i]),4)} {round(float(Molecule.z[i]),4)} \\n\"\n    file += \"*\"\n    return file\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.FileGen.ORCA_Wrapper","title":"<code>ORCA_Wrapper(QM, Calc)</code>","text":"<p>DEPRECIATED! Attempt at creating a custom wrapper for linking NAMD and ORCA</p> <p>This is no longer in use but could be re-introduced. It can be used to help run more efficiently on certain HPC systems. Args:     QM (QMClass): Class containing QM Calc information     Calc (CalcClass): Class containing Other calc information such as cores</p> <p>Returns:</p> Name Type Description <code>file</code> <code>str</code> <p>Wrapper script that can be used with the \"custom\" qm config</p> Source code in <code>Tools/FileGen.py</code> <pre><code>def ORCA_Wrapper(QM: QMClass, Calc: CalcClass):\n    \"\"\"\n    DEPRECIATED! Attempt at creating a custom wrapper for linking NAMD and ORCA\n\n    This is no longer in use but could be re-introduced. It can be used to help run more efficiently on certain HPC systems.\n    Args:\n        QM (QMClass): Class containing QM Calc information\n        Calc (CalcClass): Class containing Other calc information such as cores\n\n    Returns: \n        file (str): Wrapper script that can be used with the \"custom\" qm config\n    \"\"\"\n\n    file = f\"\"\"#!/usr/bin/python3\n# by Marcelo Melo (melomcr@gmail.com)\n# Adapted by Ross (ross.amory98@gmail.com)\n\nfrom sys import argv as sargv\nfrom sys import exit\nfrom os.path import dirname\nimport subprocess as sp\n\norcaConfigLines1 = \\\"\\\"\\\"\\\n!  {QM.Method} {QM.Basis} EnGrad {QM.QMExtra}\n%output \n  PrintLevel Mini \n  Print [ P_Mulliken ] 1\n  Print [ P_AtCharges_M ] 1\nend\n%PAL NPROCS {Calc.Threads} END\n\\\"\\\"\\\"\norcaConfigLines2 = \"%pointcharges \\\\\\\"\\\"\n\norcaConfigLines3 = \\\"\\\"\\\"\\\\\n%coords\n  CTyp xyz\n  Charge {QM.Charge}\n  Mult {QM.Spin}\n  Units Angs\n  coords\n\n\\\"\\\"\\\"\ninputFilename = sargv[1]\ndirectory = dirname(inputFilename)\norcaInFileName = directory + \"/\"\norcaInFileName += \"qmmm.input\"\npcFileName = orcaInFileName\npcFileName += \".pntchrg\"\n\norcaConfigLines2 += pcFileName + \"\\\\\"\\\\n\"\norcaOutFileName = orcaInFileName\norcaOutFileName += \".TmpOut\"\norcaGradFileName = orcaInFileName\norcaGradFileName += \".engrad\"\nfinalResFileName = inputFilename\nfinalResFileName += \".result\"\n\ninfile = open(inputFilename,\"r\")\n\nline = infile.readline()\nnumQMatms = int(line.split()[0])\nnumPntChr = int(line.split()[1].replace(\"\\\\n\",\"\"))\noutLinesQM = []\noutLinesPC = []\noutLinesPC.append(str(numPntChr) + \"\\\\n\")\nident = \"  \"\n\nlineIndx = 1\nfor line in infile:\n\n    posx = line.split()[0]\n    posy = line.split()[1]\n    posz = line.split()[2]\n\n    if lineIndx &lt;= numQMatms:\n        element = line.split()[3].replace(\"\\\\n\",\"\")\n\n        outLinesQM.append(ident + \" \".join([element,posx,posy,posz]) + \"\\\\n\")\n    else:\n        charge = line.split()[3]\n\n        outLinesPC.append(\" \".join([charge,posx,posy,posz]) + \"\\\\n\")\n\n    lineIndx += 1\noutLinesQM.append(ident + \"end\" + \"\\\\n\")\noutLinesQM.append(\"end\" + \"\\\\n\")\n\n\ninfile.close()\nwith open(orcaInFileName,\"w\") as outQMFile:\n\n    outQMFile.write(orcaConfigLines1)\n    outQMFile.write(orcaConfigLines2)\n    outQMFile.write(orcaConfigLines3)\n\n    for line in outLinesQM:\n        outQMFile.write(line)\n\nwith open(pcFileName,\"w\") as outPCFile:\n\n    for line in outLinesPC:\n        outPCFile.write(line)\ncmdline = \"cd \" + directory + \"; \"\ncmdline += \"{QM.QMpath} \"\ncmdline += orcaInFileName + \" '--use-hwthread-cpus --cpu-list CPUS' &gt; \" + orcaOutFileName\n\nproc = sp.Popen(args=cmdline, shell=True)\nproc.wait()\n\ngradFile = open(orcaGradFileName,\"r\")\nfor i in range(3):\n    gradFile.readline()\n\norcaNumQMAtms = int(gradFile.readline().replace(\"\\\\n\",\"\"))\nif orcaNumQMAtms != numQMatms:\n    print(\"ERROR: Expected\",numQMatms,\"but found\",orcaNumQMAtms,\"atoms in engrad file!\")\n    exit(1)\n\nfor i in range(3):\n    gradFile.readline()\n\nfinalEnergy = gradFile.readline().replace(\"\\\\n\",\"\").strip()\n\nprint(\"ORCA energy: \", finalEnergy,\"Eh\")\nfinalEnergy = str( float(finalEnergy) * 627.509469 )\n\nprint(\"ORCA energy: \", finalEnergy,\"kcal/mol\")\nfor i in range(3):\n    gradFile.readline()\ngrads = []\nfor i in range(orcaNumQMAtms):\n\n    grads.append( list() )\n\n    for j in range(3):\n        gradComp = gradFile.readline().replace(\"\\\\n\",\"\").strip()\n        gradComp = float(gradComp) * -1185.82151\n        grads[i].append( str(gradComp) )\n\ngradFile.close()\n\ntmpOutFile = open(orcaOutFileName,\"r\")\n\nqmCharges = []\n\n\nchargeSection = False\n\niterate = True\nwhile iterate:\n\n    line = tmpOutFile.readline()\n\n    if line.find(\"MULLIKEN ATOMIC CHARGES\") != -1:\n        chargeSection = True\n        line = tmpOutFile.readline()\n        continue\n\n    if chargeSection:\n        length = len(line.split())\n        qmCharges.append(line.split()[length-1].replace(\"\\\\n\",\"\").strip())\n        pass\n\n    if len(qmCharges) == numQMatms:\n        break\n\ntmpOutFile.close()\n\nfinFile = open(finalResFileName,\"w\")\nfinFile.write(finalEnergy + \"\\\\n\")\nfor i in range(numQMatms):\n\n    finFile.write(\" \".join(grads[i]) + \" \" + qmCharges[i] + \"\\\\n\")\n\nfinFile.close()\nexit(0)\n\n\"\"\"\n    return file\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.InputParser","title":"<code>InputParser</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.InputParser.BenchmarkInput","title":"<code>BenchmarkInput(sysargs)</code>","text":"<p>Parses command line arguments for a benchmark calculation</p> <p>Parameters:</p> Name Type Description Default <code>sysargs</code> <code>list</code> <p>Commandline variables to be parsed to ArgParse</p> required <p>Returns:</p> Name Type Description <code>args</code> <code>dict</code> <p>Dictionary containing all user-defined variables.</p> Source code in <code>Tools/InputParser.py</code> <pre><code>def BenchmarkInput(sysargs: list):\n    \"\"\"\n    Parses command line arguments for a benchmark calculation\n\n    Args:\n        sysargs (list): Commandline variables to be parsed to ArgParse\n\n    Returns:\n        args (dict): Dictionary containing all user-defined variables.\n    \"\"\"\n    Benchmark_Inp = UserVars.Benchmark_Inp\n    parser = argparse.ArgumentParser(description=f\"\"\"CLI interface for running a QM benchmark in ORCA\"\"\")\n    gen = parser.add_argument_group(\"Generic Inputs\")\n    gen.add_argument(\"-v\", \"--verbosity\", type=int, help=\"Control the verbosity of the job\", choices=[0,1,2,3 ], default=Benchmark_Inp[\"Verbosity\"])\n    gen.add_argument(\"-wd\",\"--WorkDir\", type=str, help=\"Working directory path\", default=Benchmark_Inp[\"WorkDir\"])\n    gen.add_argument(\"-c\", \"--Cores\", type=int, help=\"The number of CPU cores to give each ORCA Job.\", default=Benchmark_Inp[\"Cores\"])\n    gen.add_argument(\"-dr\", \"--DryRun\", type=str, help=\"Should the calculation be performed?\", default=Benchmark_Inp[\"DryRun\"])\n    gen.add_argument(\"-stg\", \"--Stage\", type=str, help=\"The stage of the calculation\",choices=[\"init\", \"calc\", \"analysis\",], default=Benchmark_Inp[\"Stage\"])\n    gen.add_argument(\"-i\", \"--input\", type=str, help=\"Optinonal input file rather than using the CLI interface.\", default=None)\n    bench = parser.add_argument_group(\"Benchmark Inputs\")\n    bench.add_argument(\"-type\", \"--BenchmarkType\", type=str, help=\"Define the type of benchmark to perform\", choices=[\"Energy\", \"Gradient\", \"Structure\"], default=Benchmark_Inp[\"BenchmarkType\"])\n    bench.add_argument(\"-cd\", \"--CoordinateLoc\", type=str, help=\"Location for the structures to perform the benchmark on\", default=Benchmark_Inp[\"CoordinateLoc\"])\n    bench.add_argument(\"-reactions\", \"--ReactionList\", type=str, \n                       help=\"Name of the file containing the list of reaction steps. This must be line delimited single step reactions with the name of the \\\n                       structure being identical of that to the file in the coordinates folder.\", default=Benchmark_Inp[\"ReactionList\"])\n    qm = parser.add_argument_group(\"ORCA specific inputs\")\n    qm.add_argument(\"--Path\", type=str, help=\"Path to ORCA executable\", default=ORCA_PATH)\n    qm.add_argument(\"--SCF\",type=str, help=\"The orca scf convergence setting\", choices=[\"NORMALSCF\", \"TIGHTSCF\", \"VERYTIGHTSCF\", \"EXTREMESCF\"], default=Benchmark_Inp[\"SCF\"])\n    qm.add_argument(\"--Grid\", type=str, help=\"Specify the orca integration grid\", choices=[\"DEFGRID1\", \"DEFGRID2\", \"DEFGRID3\"], default=Benchmark_Inp[\"Grid\"])\n    qm.add_argument(\"--Restart\", type=str, help=\"Togle whether to use a restart file or not\", choices=[\"AUTOSTART\", \"NOAUTOSTART\"], default=Benchmark_Inp[\"Restart\"])\n    qm.add_argument(\"--Convergence\", type=str, help=\"Chose th orca convergence stratergy\", choices=[\"EasyConv\", \"NormalConv\", \"SlowConv\", \"VerySlowConv\", \"ForceConv\"], default=Benchmark_Inp[\"Convergence\"])\n    qm.add_argument(\"--Extras\", type=str, help=\"Extra ORCA commands to use for all calculations (default is \\\"MINIPRINT\\\")\", default=Benchmark_Inp[\"Extras\"])\n    args = parser.parse_args(sysargs)\n    arg_dict = vars(args)\n    if arg_dict[\"input\"] != None:\n        print(\"ERROR: Not implemented yet.. \")\n    return arg_dict\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.InputParser.BondsInput","title":"<code>BondsInput(path, Labels)</code>","text":"<p>Reads in Bond information and updates the Label class</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path of file containing bond information</p> required <code>Labels</code> <code>LabelClass</code> <p>Label class containing labels</p> required <p>Returns:</p> Name Type Description <code>Labels</code> <code>LabelClass</code> <p>Updated label class</p> Source code in <code>Tools/InputParser.py</code> <pre><code>def BondsInput(path: str, Labels: LabelClass):\n    \"\"\"Reads in Bond information and updates the Label class\n\n    Args:\n        path (str): Path of file containing bond information\n        Labels (LabelClass): Label class containing labels\n\n    Returns:\n        Labels (LabelClass): Updated label class\n    \"\"\"\n    try:\n        data = utils.file_read(path)\n    except FileNotFoundError:\n        print(\"No bond information file found...\")\n        return Labels\n    for lines in data:\n        variables = lines.split()\n        if \"name\" in variables[0].casefold():\n            pass\n        else:\n            Labels.add_bond(selection=f\"{variables[1]},{variables[2]}\", name=variables[0], thresh=float(variables[3]))\n    return Labels\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.InputParser.DihedralInput","title":"<code>DihedralInput(path, Labels)</code>","text":"<p>Reads in Dihedral bond information Args:     path (str): Path to file containing dihedral information     Labels (LabelClass): Label class containing Label information</p> <p>Returns:</p> Name Type Description <code>Labels</code> <code>LabelClass</code> <p>Updated label class with new dihedral information</p> Source code in <code>Tools/InputParser.py</code> <pre><code>def DihedralInput(path: str, Labels: LabelClass):\n    \"\"\"\n    Reads in Dihedral bond information\n    Args:\n        path (str): Path to file containing dihedral information\n        Labels (LabelClass): Label class containing Label information\n\n    Returns:\n        Labels (LabelClass): Updated label class with new dihedral information\n\n    \"\"\"\n    try:\n        data = utils.file_read(path)\n    except FileNotFoundError:\n        print(\"No dihedral information file found...\")\n        return Labels\n    for lines in data:\n        variables = lines.split()\n        if \"name\" in variables[0].casefold():\n            pass\n        else:\n            Labels.add_dihedral(selection=f\"{variables[1]},{variables[2]},{variables[3]},{variables[4]}\",\n                        name=variables[0], target1=float(variables[6]), t1name=variables[5],\n                        target2=float(variables[8]), t2name=variables[7])\n    return Labels\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.InputParser.StandaloneInput","title":"<code>StandaloneInput(sysargs)</code>","text":"<p>Controls the inputs of a standalone calculation. </p> <p>Parameters:</p> Name Type Description Default <code>sysargs</code> <code>list</code> <p>CLI inputs (see attributes)</p> required <p>Attributes:</p> Name Type Description <code>--WorkDir</code> <code>str</code> <p>Working Directory</p> <code>--Verbosity</code> <code>int</code> <p>Verbosity: 0 = none, 1 = info</p> <code>--DryRun</code> <code>str</code> <p>Indicates whether programs are executed or not</p> <code>--CoresPerJob</code> <code>int</code> <p>Number of cores per individual calculation</p> <code>--MemoryPerJob</code> <code>int</code> <p>Gb of memory per individual calculation</p> <code>--MDCPUPath</code> <code>str</code> <p>Path to NAMD CPU executable</p> <code>--MDGPUPath</code> <code>str</code> <p>Path to NAMD GPU executable</p> <code>--QmFile</code> <code>str</code> <p>Name of file containing QM information.</p> <code>--QmPath</code> <code>str</code> <p>Path to QM software</p> <code>--QmSelection</code> <code>str</code> <p>Selection algebra for QM atoms</p> <code>--QmCharge</code> <code>int</code> <p>Charge of QM region</p> <code>--QmSpin</code> <code>int</code> <p>Spin of QM region</p> <code>--QmMethod</code> <code>str</code> <p>Qm method</p> <code>--QmBasis</code> <code>str</code> <p>QM basis set</p> <code>--QmArgs</code> <code>str</code> <p>Extra arguments for ORCA calculation</p> <code>--HPC</code> <code>bool</code> <p>Whether to run on a HPC</p> <code>--MaxWallTime</code> <code>int</code> <p>Maximum wall time (Hours) for your jobs (either leave as node max, or set as job length)</p> <code>--HostName</code> <code>str</code> <p>HostName of the HPC</p> <code>--Partition</code> <code>str</code> <p>Calculation partition name</p> <code>--MaxCores</code> <code>int</code> <p>Maximum number of cores available to a node (For array splitting)</p> <code>--QualityofService</code> <code>str</code> <p>Slurm QoS, set to None if not relevant.</p> <code>--Account</code> <code>str</code> <p>Slurm account, (Not username), Set to None if not relevant</p> <code>--SoftwareLines</code> <code>list</code> <p>List of commands like \"module load XXX\" to load software. Keep each line surrounded by quotes.</p> <code>--MMFile</code> <code>str</code> <p>Name of input file containing MD information</p> <code>--Name</code> <code>str</code> <p>Name for the calculation</p> <code>--Ensemble</code> <code>str</code> <p>Ensemble for Calculation</p> <code>--QM</code> <code>bool</code> <p>Whether this is a QMMM calculation or not.</p> <code>--Steps</code> <code>int</code> <p>Number of simulation steps.</p> <code>--TimeStep</code> <code>float</code> <p>Time step for the simulation. We recommend 2 for MM, 0.5 for QMMM</p> <code>--ParmFile</code> <code>str</code> <p>Parameter file name</p> <code>--AmberCoordinates</code> <code>str</code> <p>Amber coordinate file name that relates to the parameter file</p> <code>--StartFile</code> <code>str</code> <p>Either Amber coordinates or NAMD coordinates. These are the coordinates that it starts from.</p> <code>--RestartOut</code> <code>int</code> <p>Frequency to generate a restart file</p> <code>--TrajOut</code> <code>int</code> <p>Frequency to add to the trajectory file</p> <code>--SMD</code> <code>bool</code> <p>Whether to use steered molecular dynamics</p> <code>--Force</code> <code>int</code> <p>Force for Steered MD</p> <code>--StartValue</code> <code>int</code> <p>Start value for SMD</p> <code>--EndValue</code> <code>int</code> <p>End value for SMD. MAKE == Start if wanting constant.</p> <code>--AtomMask</code> <code>str</code> <p>Mask for the restrained atoms.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown variable is parsed</p> <p>Returns:</p> Name Type Description <code>arg_dict</code> <code>dict</code> <p>Dictionary of user variables.</p> Source code in <code>Tools/InputParser.py</code> <pre><code>def StandaloneInput(sysargs: list):\n    \"\"\"\n    Controls the inputs of a standalone calculation. \n\n    Args:\n        sysargs (list): CLI inputs (see attributes)\n\n    Attributes:\n        --WorkDir (str): Working Directory\n        --Verbosity (int): Verbosity: 0 = none, 1 = info\n        --DryRun (str):  Indicates whether programs are executed or not\n        --CoresPerJob (int): Number of cores per individual calculation\n        --MemoryPerJob (int): Gb of memory per individual calculation\n        --MDCPUPath (str): Path to NAMD CPU executable\n        --MDGPUPath (str): Path to NAMD GPU executable\n        --QmFile (str): Name of file containing QM information.\n        --QmPath (str): Path to QM software\n        --QmSelection (str): Selection algebra for QM atoms\n        --QmCharge (int): Charge of QM region\n        --QmSpin (int): Spin of QM region\n        --QmMethod (str): Qm method\n        --QmBasis (str): QM basis set\n        --QmArgs (str): Extra arguments for ORCA calculation\n        --HPC (bool): Whether to run on a HPC\n        --MaxWallTime (int): Maximum wall time (Hours) for your jobs (either leave as node max, or set as job length)\n        --HostName (str): HostName of the HPC\n        --Partition (str): Calculation partition name\n        --MaxCores (int): Maximum number of cores available to a node (For array splitting)\n        --QualityofService (str): Slurm QoS, set to None if not relevant.\n        --Account (str): Slurm account, (Not username), Set to None if not relevant\n        --SoftwareLines (list): List of commands like \"module load XXX\" to load software. Keep each line surrounded by quotes.\n        --MMFile (str): Name of input file containing MD information\n        --Name (str): Name for the calculation\n        --Ensemble (str): Ensemble for Calculation\n        --QM (bool): Whether this is a QMMM calculation or not.\n        --Steps (int): Number of simulation steps.\n        --TimeStep (float): Time step for the simulation. We recommend 2 for MM, 0.5 for QMMM\n        --ParmFile (str): Parameter file name\n        --AmberCoordinates (str): Amber coordinate file name that relates to the parameter file\n        --StartFile (str): Either Amber coordinates or NAMD coordinates. These are the coordinates that it starts from.\n        --RestartOut (int): Frequency to generate a restart file\n        --TrajOut (int): Frequency to add to the trajectory file\n        --SMD (bool): Whether to use steered molecular dynamics\n        --Force (int): Force for Steered MD\n        --StartValue (int): Start value for SMD\n        --EndValue (int): End value for SMD. MAKE == Start if wanting constant.\n        --AtomMask (str): Mask for the restrained atoms.\n\n    Raises:\n        ValueError: If an unknown variable is parsed\n\n    Returns:\n        arg_dict (dict): Dictionary of user variables. \n    \"\"\"\n    HPC = \"None\"\n    HostName = socket.gethostname()\n    for alias, data in HPC_Config.items():\n        if HostName == data[\"HostName\"]:\n            HPC = alias\n            continue\n    defaults = UserVars.Standalone_Inp\n    HPC_Conf = HPC_Config[HPC]\n    parser = argparse.ArgumentParser(description=f\"\"\"Commandline arguments. This method of calculation input is being deprecated. Please do not use.\nIt is recommended to use -jt inpfile to generate input file templates with default values that you can then edit.\"\"\")\n    ### Core Job arguments\n    Core = parser.add_argument_group(\"Core Job Arguments\")\n    Core.add_argument('-wd', '--WorkDir', type=str,\n                        help=\"Home location for the calculations\", default=defaults[\"WorkDir\"])\n    Core.add_argument('-v', '--Verbosity', type=int,\n                        help=\"Verbosity: 0 = none, 1 = info\", default=defaults[\"Verbosity\"])\n    Core.add_argument('-dr', '--DryRun', type=str,\n                        help=\"Indicates whether programs are executed or not\", default=defaults[\"DryRun\"])\n\n    Compute = parser.add_argument_group(\"Compute Arguments\")\n    ### Compute Arguments\n    Compute.add_argument('-c', '--CoresPerJob', type=int,\n                        help=\"Number of cores per individual calculation\", default=defaults[\"CoresPerJob\"])\n    Compute.add_argument('-m','--MemoryPerJob', type=int,\n                        help=\"Gb of memory per individual calculation\", default=defaults[\"MemoryPerJob\"])\n\n    ### MM Arguments\n    MM = parser.add_argument_group(\"Molecular Dynamics Arguments\")\n    MM.add_argument('-MDcpu', '--MDCPUPath', type=str,\n                        help=\"Path to NAMD CPU executable\", default=NAMD_CPU)\n    MM.add_argument('-MDgpu', '--MDGPUPath', type=str,\n                        help=\"Path to NAMD GPU executable\", default=NAMD_GPU)\n\n    ### QM Arguments\n    QM = parser.add_argument_group(\"QM Arguments\")\n    QM.add_argument(\"-qf\", \"--QmFile\", type=str, default=defaults[\"QmFile\"],\n                    help=\"Name of file containing QM information.\")\n    QM.add_argument('-qp', '--QmPath', type=str,\n                        help=\"Path to QM software\", default=ORCA_PATH)\n    QM.add_argument('-qsel', '--QmSelection', type=str,\n                        help=\"Selection algebra for QM atoms\", default=defaults[\"QmSelection\"])\n    QM.add_argument('-qc', '--QmCharge', type=int,\n                        help=\"Charge of QM region\", default=defaults[\"QmCharge\"])\n    QM.add_argument('-qspin', '--QmSpin', type=int,\n                        help=\"Spin of QM region\", default=defaults[\"QmSpin\"])\n    QM.add_argument('-qm', '--QmMethod', type=str,\n                        help=\"Qm method\", default=defaults[\"QmMethod\"])\n    QM.add_argument('-qb', '--QmBasis', type=str,\n                        help=\"QM basis set\", default=defaults[\"QmBasis\"])\n    QM.add_argument('-qargs', '--QmArgs', type=str, \n                    help=\"Extra arguments for ORCA calculation\", default=defaults[\"QmArgs\"])\n\n    ### HPC Arguments\n    HPC = parser.add_argument_group(\"HPC/SLURM arguments\")\n    HPC.add_argument(\"--HPC\", type=bool, default=defaults[\"HPC\"], help=\"Whether to run on a HPC\")\n    HPC.add_argument(\"-MaxTime\", \"--MaxWallTime\", type=int,\n                     help=\"Maximum wall time (Hours) for your jobs (either leave as node max, or set as job length)\",\n                     default=HPC_Conf[\"MaxWallTime\"])\n    HPC.add_argument(\"-Host\", \"--HostName\", type=str,\n                     help=\"HostName of the HPC\", default=HPC_Conf[\"HostName\"])\n    HPC.add_argument(\"--Partition\", type=str, help=\"Calculation partition name\",\n                     default=HPC_Conf[\"Partition\"])\n    HPC.add_argument(\"--MaxCores\", type=int,\n                     help=\"Maximum number of cores available to a node (For array splitting)\", default=HPC_Conf[\"MaxCores\"])\n    HPC.add_argument(\"-QoS\", \"--QualityofService\", type=str,\n                     help=\"Slurm QoS, set to None if not relevant.\", default=HPC_Conf[\"QualityofService\"])\n    HPC.add_argument(\"--Account\", type=str,\n                     help=\"Slurm account, (Not username), Set to None if not relevant\", default=HPC_Conf[\"Account\"])\n    HPC.add_argument(\"-Software\", \"--SoftwareLines\", type=str,\n                    help=\"List of commands like \\\"module load XXX\\\" to load software. Keep each line surrounded by quotes.\",\n                    default=HPC_Conf[\"SoftwareLines\"], nargs=\"*\")\n\n    Standalone = parser.add_argument_group(\"Standalone Job arguments\")\n    Standalone.add_argument(\"-i\", \"--MMFile\", type=str, default=defaults[\"MMFile\"],\n                            help=\"Name of input file containing MD information\")\n    Standalone.add_argument(\"--Name\", type=str,\n                            default=defaults[\"Name\"], help=\"Name for the calculation\")\n    Standalone.add_argument(\"--Ensemble\", type=str,\n                            choices=[\"min\", \"heat\", \"NVT\", \"NPT\"],\n                            help=\"Ensemble for Calculation\", default=defaults[\"Ensemble\"])\n    Standalone.add_argument(\"--QM\", type=str, choices=[\"True\", \"False\"],\n                            default=defaults[\"QM\"], help=\"Whether this is a QMMM calculation or not.\")\n    Standalone.add_argument(\"-st\", \"--Steps\", type=int,\n                            default=defaults[\"Steps\"], help=\"Number of simulation steps.\")\n    Standalone.add_argument(\"-dt\", \"--TimeStep\", type=float,\n                            default=float(defaults[\"TimeStep\"]), help=\"Time step for the simulation. We recommend 2 for MM, 0.5 for QMMM\")\n    Standalone.add_argument(\"--ParmFile\", type=str,\n                            default=defaults[\"ParmFile\"], help=\"Parameter file name\")\n    Standalone.add_argument(\"--AmberCoordinates\", type=str,\n                            default=defaults[\"AmberCoordinates\"], help=\"Amber coordinate file name that relates to the parameter file\")\n    Standalone.add_argument(\"--StartFile\", type=str, default=defaults[\"StartFile\"], \n                            help=\"Either Amber coordinates or NAMD coordinates. These are the coordinates that it starts from.\")\n    Standalone.add_argument(\"--RestartOut\", type=int, default=defaults[\"RestartOut\"], \n                            help=\"Frequency to generate a restart file\")\n    Standalone.add_argument(\"--TrajOut\", type=int, default=defaults[\"TrajOut\"], \n                            help=\"Frequency to add to the trajectory file\")\n    Standalone.add_argument(\"--SMD\", type=str, choices=[\"True\", \"False\"], default=defaults[\"SMD\"], \n                            help=\"Wheter to use steered molecular dynamics\")\n    Standalone.add_argument(\"--Force\", type=float, default=defaults[\"Force\"], \n                            help=\"Force for Steered MD\")\n    Standalone.add_argument(\"--StartValue\", type=float, default=defaults[\"StartValue\"], \n                            help=\"Start value for SMD\")\n    Standalone.add_argument(\"--EndValue\", type=float, default=defaults[\"EndValue\"], \n                            help=\"End value for SMD. MAKE == Start if wanting constant.\")\n    Standalone.add_argument('-mask', '--AtomMask', type=str,\n                        help=\"Mask for the restrained atoms.\", default=defaults[\"AtomMask\"])\n    args = parser.parse_args(sysargs)\n    arg_dict = vars(args)\n    workdir = arg_dict[\"WorkDir\"]\n    qmfile = arg_dict[\"QmFile\"]\n    mmfile = arg_dict[\"MMFile\"]\n    # print(arg_dict[\"DryRun\"])\n    if arg_dict[\"QmFile\"] != \"None\":\n        qm_input = utils.file_read(f\"{workdir}{qmfile}\")\n        for i in qm_input:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\") # removes random spaces.\n            val = val.replace(\"\\n\",\"\") # removes newline errors/\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {qmfile}\")\n    if arg_dict[\"MMFile\"] != \"None\":\n        mm_input = utils.file_read(f\"{workdir}{mmfile}\")\n        for i in mm_input:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\")\n            val = val.replace(\"\\n\",\"\")\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {mmfile}\")\n    # utils.print_attributes(arg_dict) # Prints out all vars for use in docstring generation\n    return arg_dict\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.InputParser.UmbrellaInput","title":"<code>UmbrellaInput(sysargs)</code>","text":"<p>Description of UmbrellaInput</p> <p>Parameters:</p> Name Type Description Default <code>sysargs</code> <code>list</code> <p>CLI user variables</p> required <p>Returns:</p> Name Type Description <code>arg_dict</code> <code>dict</code> <p>User variables parsed as a dictionary.</p> Source code in <code>Tools/InputParser.py</code> <pre><code>def UmbrellaInput(sysargs):\n    \"\"\"\n    Description of UmbrellaInput\n\n    Args:\n        sysargs (list): CLI user variables\n\n    Returns:\n        arg_dict (dict): User variables parsed as a dictionary.\n\n    \"\"\"\n    HPC = \"None\"\n    HostName = socket.gethostname()\n    for alias, data in HPC_Config.items():\n        if HostName == data[\"HostName\"]:\n            HPC = alias\n            continue\n    defaults = UserVars.Umbrella_Inp\n    HPC_Conf = HPC_Config[HPC]\n    parser = argparse.ArgumentParser(description=f\"\"\"Commandline arguments. This method of calculation input is being deprecated. Please do not use.\nIt is recommended to use --Stage inpfile to generate input file templates with default values that you can then edit.\"\"\")\n    ### Core Job arguments\n    Core = parser.add_argument_group(\"Core Job Arguments\")\n    Core.add_argument('-wd', '--WorkDir', type=str,\n                        help=\"Home location for the calculations\", default=defaults[\"WorkDir\"])\n    Core.add_argument('-i', '--Input', type=str, default=\"None\",\n                      help=\"Global input file, This will overwrite all other variables and input files.\")\n    Core.add_argument('-v', '--Verbosity', type=int,\n                        help=\"Verbosity: 0 = none, 1 = info\", default=defaults[\"Verbosity\"])\n    Core.add_argument('-dr', '--DryRun', type=str,\n                        help=\"Indicates whether programs are executed or not\", default=defaults[\"DryRun\"])\n\n    Compute = parser.add_argument_group(\"Compute Arguments\")\n    ### Compute Arguments\n    Compute.add_argument('-cores', '--CoresPerJob', type=int,\n                        help=\"Number of cores per individual calculation\", default=defaults[\"CoresPerJob\"])\n    Compute.add_argument('-mem','--MemoryPerJob', type=int,\n                        help=\"Gb of memory per individual calculation\", default=defaults[\"MemoryPerJob\"])\n    Compute.add_argument('-MaxCalc', '--MaxStepsPerCalc', type=int,\n                         help=\"The maximum number of steps per calculation. splits jobs into sub-steps. useful for short wall times. 0 == No cap.\",\n                         default=defaults[\"MaxStepsPerCalc\"])\n\n    ### MM Arguments\n    MM = parser.add_argument_group(\"Molecular Dynamics Arguments\")\n    MM.add_argument('-MDcpu', '--MDCPUPath', type=str,\n                        help=\"Path to NAMD CPU executable\", default=NAMD_CPU)\n    MM.add_argument('-MDgpu', '--MDGPUPath', type=str,\n                        help=\"Path to NAMD GPU executable\", default=NAMD_GPU)\n\n    ### QM Arguments\n    QM = parser.add_argument_group(\"QM Arguments\")\n    QM.add_argument(\"--QM\", type=str, choices=[\"True\", \"False\"], default=defaults[\"QM\"],\n                    help=\"Whether to use QMMM Umbrella Sampling\")\n    QM.add_argument(\"-qf\", \"--QmFile\", type=str, default=defaults[\"QmFile\"],\n                        help=\"Name of file containing QM information.\")\n    QM.add_argument('-qp', '--QmPath', type=str,\n                        help=\"Path to QM software\", default=ORCA_PATH)\n    QM.add_argument('-qsel', '--QmSelection', type=str,\n                        help=\"Selection algebra for QM atoms\", default=defaults[\"QmSelection\"])\n    QM.add_argument('-qc', '--QmCharge', type=int,\n                        help=\"Charge of QM region\", default=defaults[\"QmCharge\"])\n    QM.add_argument('-qspin', '--QmSpin', type=int,\n                        help=\"Spin of QM region\", default=defaults[\"QmSpin\"])\n    QM.add_argument('-qm', '--QmMethod', type=str,\n                        help=\"Qm method\", default=defaults[\"QmMethod\"])\n    QM.add_argument('-qb', '--QmBasis', type=str,\n                        help=\"QM basis set\", default=defaults[\"QmBasis\"])\n    QM.add_argument('-qargs', '--QmArgs', type=str, help=\"Extra arguments for ORCA calculation\", default=defaults[\"QmArgs\"])\n\n    ### Umbrella Arguments\n    Umbrella = parser.add_argument_group(\"Umbrella Sampling arguments\")\n    Umbrella.add_argument(\"--UmbrellaFile\", type=str, default=defaults[\"UmbrellaFile\"],\n                        help=\"Name of file containing Umbrella information.\")\n    Umbrella.add_argument('-min', '--UmbrellaMin', type=float,\n                        help=\"Minimum Umbrella distance\", default=defaults[\"UmbrellaMin\"])\n    Umbrella.add_argument('-width', '--UmbrellaWidth', type=float,\n                        help=\"Umbrella bin width in Angstroms or degrees\", default=defaults[\"UmbrellaWidth\"])\n    Umbrella.add_argument('-bins', '--UmbrellaBins', type=int,\n                        help=\"Number of umbrella bins\", default=defaults[\"UmbrellaBins\"])\n    Umbrella.add_argument('-pf', '--PullForce', type=float,\n                        help=\"Force for pulls in KCal A-2\", default=defaults[\"PullForce\"])\n    Umbrella.add_argument('-f', '--ConstForce', type=float,\n                        help=\"Force for standard Umbrella runs\", default=defaults[\"ConstForce\"]) ### NAMD uses 1/2 k rather than just k\n    Umbrella.add_argument('-sd', '--StartDistance', type=float,\n                        help=\"Distance of initial simulation\", default=defaults[\"StartDistance\"])\n    Umbrella.add_argument('-mask', '--AtomMask', type=str,\n                        help=\"Mask for the restrained atoms.\", default=defaults[\"AtomMask\"])\n    Umbrella.add_argument('-stg', '--Stage', type=str,\n                        help=\"Stage of umbrella simulation\", default=defaults[\"Stage\"])\n    Umbrella.add_argument('-af', '--AnalysisFile', type=str,\n                        help=\"Name prefix to perform custom analysis.(XXX.i.colvars.traj\", default=defaults[\"AnalysisFile\"])\n    Umbrella.add_argument(\"--StartFile\", default=defaults[\"StartFile\"], type=str, help=\"Initial coordinate file if not starting from \\\"start.rst7\\\"\")\n    Umbrella.add_argument(\"--ParmFile\", default=defaults[\"ParmFile\"], type=str, \n                              help=\"Amber parameter file\")\n    Umbrella.add_argument(\"--EquilLength\", default=defaults[\"EquilLength\"], type=int, \n                          help=\"Length of equilibration in ps (per window)\")\n    Umbrella.add_argument(\"--ProdLength\", type=int, default=defaults[\"ProdLength\"],\n                          help=\"Length of production umbrellasampling per window in ps.\")\n    if HPC != \"None\":\n    ### HPC Arguments\n        HPC = parser.add_argument_group(\"HPC/SLURM arguments\")\n        HPC.add_argument(\"-MaxTime\", \"--MaxWallTime\", type=int,\n                        help=\"Maximum wall time (Hours) for your jobs (either leave as node max, or set as job length)\",\n                        default=HPC_Conf[\"MaxWallTime\"])\n        HPC.add_argument(\"-Host\", \"--HostName\", type=str,\n                        help=\"HostName of the HPC\", default=HPC_Conf[\"HostName\"])\n        HPC.add_argument(\"--Partition\", type=str, help=\"Calculation partition name\",\n                        default=HPC_Conf[\"Partition\"])\n        HPC.add_argument(\"--MaxCores\", type=int,\n                        help=\"Maximum number of cores available to a node (For array splitting)\", default=HPC_Conf[\"MaxCores\"])\n        HPC.add_argument(\"-QoS\", \"--QualityofService\", type=str,\n                        help=\"Slurm QoS, set to None if not relevant.\", default=HPC_Conf[\"QualityofService\"])\n        HPC.add_argument(\"--Account\", type=str,\n                        help=\"Slurm account, (Not username), Set to None if not relevant\", default=HPC_Conf[\"Account\"])\n        HPC.add_argument(\"-Software\", \"--SoftwareLines\", type=str,\n                        help=\"List of commands like \\\"module load XXX\\\" to load software. Keep each line surrounded by quotes.\",\n                        default=HPC_Conf[\"SoftwareLines\"], nargs=\"*\")\n    args = parser.parse_args(sysargs)\n    arg_dict = vars(args)\n    if HPC == \"None\":\n        arg_dict = arg_dict | HPC_Conf\n    workdir = arg_dict[\"WorkDir\"]\n    qmfile = arg_dict[\"QmFile\"]\n    umbfile = arg_dict[\"UmbrellaFile\"]\n    inpfile = arg_dict[\"Input\"]\n    if arg_dict[\"Stage\"].casefold() == \"inpfile\": # Generates an Umbrella.inp file in the work directory using default values\n        utils.file_2dwrite(f\"{workdir}Umbrella.inp\", x=list(defaults.keys()), y=list(defaults.values()), delim=\"=\" )\n    if arg_dict[\"QmFile\"] != \"None\":\n        qm_input = utils.file_read(f\"{workdir}{qmfile}\")\n        for i in qm_input:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\") # removes random spaces.\n            val = val.replace(\"\\n\",\"\") # removes newline errors.\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {qmfile}\")\n    if arg_dict[\"UmbrellaFile\"] != \"None\":\n        umb_input = utils.file_read(f\"{workdir}{umbfile}\")\n        for i in umb_input:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\")\n            val = val.replace(\"\\n\",\"\")\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {umbfile}\")\n    if arg_dict[\"Input\"] != \"None\":\n        inp = utils.file_read(f\"{workdir}{inpfile}\")\n        for i in inp:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\")\n            val = val.replace(\"\\n\",\"\")\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {inpfile}\")\n    return arg_dict\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.analysis","title":"<code>analysis</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.analysis.Error_Check","title":"<code>Error_Check(Umbrella, Errors, Step=0)</code>","text":"<p>Identifies whether a window should be used for wham calculation.</p> Source code in <code>Tools/analysis.py</code> <pre><code>def Error_Check(Umbrella, Errors, Step=0, ):\n    \"\"\"Identifies whether a window should be used for wham calculation.\"\"\"\n    print(f\"Checking for errors in step {Step}\")\n    Labels = LabelClass(f\"../{globals.parmfile}\")\n    Labels.clear_Vars()\n    Labels = input.BondsInput(f\"{globals.WorkDir}BondErrors.dat\", Labels)\n    Labels = input.DihedralInput(f\"{globals.WorkDir}DihedralErrors.dat\", Labels)\n    core_load = []\n    core_load.append(f\"mol new {globals.parmfile}\")\n    dataframe = DataClass(\"Production\")\n    for i in range(Umbrella.Bins):\n        Path = f\"{globals.WorkDir}{i}/\"\n        # print(Labels.bond)\n        if i in Errors:\n            continue\n        Labels.file_name([f\"prod_{Step}.{i}.dcd\"])\n        Bonds, Dihedrals = Label_Maker(Labels, f\"{globals.WorkDir}{i}/label_maker.tcl\")\n        subprocess.run([f\"cd {globals.WorkDir}{i} ; vmd -dispdev text -e label_maker.tcl ; cd ../\"], shell=True, capture_output=True)\n        dataframe = Labal_Analysis(Bonds, Dihedrals, f\"{globals.WorkDir}{i}/\", i, dataframe)\n        if len(Dihedrals) &gt; 0:\n            Error = True\n        else:\n            Error = False\n        for j in range(len(Dihedrals)):\n            steps, data = utils.data_2d(f\"{Path}{Dihedrals[j].name}.dat\")\n            break_point = tcl_dihedAnalysis(Dihedrals[j], data, i, Error_Anal=True)\n            if break_point == len(data):\n                Error = False\n            elif break_point &gt;= 0.9*len(data):\n                Error = False\n                print(f\"WARNING: There are some problems with window {i}, They are near the end so ignoring.\" if globals.verbosity &gt;=1 else \"\", end=\"\")\n            else:\n                Error = True\n                Errors.append(i)\n                print(f\"WARNING: Error identified in step {Step} of window {i}, Dihedral Error\" if globals.verbosity &gt;=1 else \"\", end=\"\")\n                print(f\"Breakpoint is: {break_point} out of {len(data)} steps\" if globals.verbosity &gt;=1 else \"\", end=\"\")\n                break\n        if Error != True:\n            for j in range(len(Bonds)):\n                steps, data = utils.data_2d(f\"{Path}{Bonds[j].name}.dat\")\n                break_point = tcl_bondAnalysis(Bonds[j], data, i, Error_Anal=True)\n                if break_point == len(data):\n                    Error = False\n                elif break_point &gt;= 0.5*len(data):\n                    Error = False\n                    print(f\"WARNING: There are some problems with step {Step}, They are near the end so ignoring.\" if globals.verbosity &gt;=1 else \"\", end=\"\")\n                else:\n                    Error = True\n                    Errors.append(i)\n                    print(f\"WARNING: Error identified in step {Step} of window {i}, Bond Error\" if globals.verbosity &gt;=1 else \"\", end=\"\")\n                    break\n    return Errors\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.analysis.Labal_Analysis","title":"<code>Labal_Analysis(Bonds, Dihedrals, Path, window, dataframe)</code>","text":"<p>Saves bond and dihedral analysis, and controls errors for when files are missing ect.</p> Source code in <code>Tools/analysis.py</code> <pre><code>def Labal_Analysis(Bonds, Dihedrals, Path, window, dataframe):\n    \"\"\"Saves bond and dihedral analysis, and controls errors for when files are missing ect.\"\"\"\n    for i in range(len(Bonds)):\n        try:\n            steps, data = utils.data_2d(f\"{Path}{Bonds[i].name}.dat\")\n            # plt.hist(data,10)\n            tcl_bondAnalysis(Bonds[i], data, window)\n            dataframe.add_data(Bonds[i].name, window, data)\n        except FileNotFoundError:\n            log.error(f\"Simulation {window} has errors...\")\n            break\n    for i in range(len(Dihedrals)):\n        try:\n            steps, data = utils.data_2d(f\"{Path}{Dihedrals[i].name}.dat\")\n            tcl_dihedAnalysis(Dihedrals[i], data, window)\n            dataframe.add_data(Dihedrals[i].name, window, data)\n        except FileNotFoundError:\n            # log.warning(f\"Simulation {window} has errors...\")\n            break\n    return dataframe\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.analysis.Label_Maker","title":"<code>Label_Maker(Label, path)</code>","text":"<p>This generates the tcl script that automates the bond and dihedral analysis.</p> Source code in <code>Tools/analysis.py</code> <pre><code>def Label_Maker(Label, path):\n    \"\"\"This generates the tcl script that automates the bond and dihedral analysis.\"\"\"\n    Bonds = [None] * len(Label.bond)\n    Dihedrals = [None] * len(Label.dihedral)\n    with open(path, 'w') as f:\n        print(f\"mol new {Label.parm} waitfor -1\", file=f)\n    with open(path, 'a') as f:\n        for i in Label.file:\n            print(f\"mol addfile {i} waitfor -1\", file=f)\n# \"\"\", file=f)\n        for i in range(len(Label.bond)):\n            atoms = Label.bond[i]\n            Bonds[i] = BondClass(atoms.split(\",\")[0], atoms.split(\",\")[1], Label.bondName[i], Label.bondThresh[i])\n            lines = tcl_bondPlot(Bonds[i])\n            print(lines, file=f)\n        for i in range(len(Label.dihedral)):\n            atoms = Label.dihedral[i]\n            Dihedrals[i] = DihedralClass(atoms.split(\",\")[0],\n                                         atoms.split(\",\")[1],\n                                         atoms.split(\",\")[2],\n                                         atoms.split(\",\")[3],\n                                         Label.dihedralName[i],\n                                         Label.dihedralTarget1[i],\n                                         Label.dihedralTarget1Name[i],\n                                         Label.dihedralTarget2[i],\n                                         Label.dihedralTarget2Name[i], )\n            lines = tcl_dihedPlot(Dihedrals[i])\n            print(lines, file=f)\n        print(\"quit\", file=f)\n    return Bonds, Dihedrals\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.analysis.analysis","title":"<code>analysis(Umbrella)</code>","text":"Source code in <code>Tools/analysis.py</code> <pre><code>def analysis(Umbrella: UmbrellaClass):\n    Labels = LabelClass(f\"../{globals.parmfile}\")\n    Labels = input.BondsInput(f\"{globals.WorkDir}Bonds.dat\", Labels)\n    Labels = input.DihedralInput(f\"{globals.WorkDir}Dihedral.dat\", Labels)\n    core_load = []\n    core_load.append(f\"mol new {globals.parmfile}\")\n    dataframe = DataClass(\"Production\")\n    for i in range(Umbrella.Bins):\n        FileNames = []\n        for j in range(1,20):\n            FileNames.append(f\"prod_{j}.{i}.dcd\")\n        Labels.file_name(FileNames)\n        Bonds, Dihedrals = Anal.Label_Maker(Labels, f\"{globals.WorkDir}{i}/label_maker.tcl\")\n        if globals.DryRun == False:\n            subprocess.run([f\"cd {globals.WorkDir}{i} ; vmd -dispdev text -e label_maker.tcl ; cd ../\"], shell=True, capture_output=True)\n        dataframe = Anal.Labal_Analysis(Bonds, Dihedrals, f\"{globals.WorkDir}{i}/\", i, dataframe)\n        core_load.append(f\"mol addfile ./{i}/equil.{i}.restart.coor \")\n    with open(f\"{globals.WorkDir}prod_load.tcl\",'w') as f:\n        for i in range(len(core_load)):\n            print(core_load[i], file=f)\n    df = pd.concat(dataframe.dat)\n    print(df.loc[df[\"Name\"] == \"c6Ring\", \"Data\"].shape)\n    print(type(Umbrella.atom1), Umbrella.atom2, Umbrella.atom3)\n    for bond in Bonds:\n        if ((bond.at1 == Umbrella.atom1) or (bond.at2 == Umbrella.atom1)) and ((bond.at1 == Umbrella.atom2) or (bond.at2 == Umbrella.atom2)) and (Umbrella.atom3 == 0):\n            reactioncoordinate = bond.name\n            print(f\"INFO: Reaction coordinate is {reactioncoordinate}\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n    for dihed in Dihedrals:\n        if ((dihed.at1 == Umbrella.atom1) or (dihed.at4 == Umbrella.atom1)) and ((dihed.at2 == Umbrella.atom2) or (dihed.at3 == Umbrella.atom2)) and ((dihed.at3 == Umbrella.atom3) or (dihed.at2 == Umbrella.atom3)) and ((dihed.at4 == Umbrella.atom4) or (dihed.at1 == Umbrella.atom4)):\n            reactioncoordinate = dihed.name\n            print(f\"INFO: Reaction coordinate is {reactioncoordinate}\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n    try:\n        os.mkdir(f\"{globals.WorkDir}Figures/\")\n    except:\n        print(\"INFO: Figures directory already exists\"if globals.verbosity &gt;=2 else \"\", end=\"\")\n    for bond in Bonds:\n        plt.hist(df.loc[df[\"Name\"] == bond.name, \"Data\",], 100,color=\"black\")\n        plt.title(f\"{bond.name} bond\")\n        plt.xlabel(\"Distance\")\n        plt.ylabel(\"Count\")\n        plt.savefig(f\"{globals.WorkDir}Figures/{bond.name}.eps\",transparent=True)\n        if globals.verbosity &gt;= 2:\n            plt.show()\n        else:\n            plt.clf()\n        d = plt.hist2d(df.loc[df[\"Name\"] == reactioncoordinate, \"Data\"], df.loc[df[\"Name\"] == bond.name, \"Data\"],\n                    100, cmap=\"binary\")\n        plt.title(f\"Reaction coordinate vs. {bond.name} bond\")\n        plt.ylabel(f\"{bond.name} bond distance\")\n        plt.xlabel(\"Reaction coordinate\")\n        plt.savefig(f\"{globals.WorkDir}Figures/{bond.name}_2d.eps\",transparent=True)\n        with open(f\"{globals.WorkDir}Figures/{bond.name}_2d.dat\", 'w') as f:\n            print(f\"x\\ty\\tcount\", file=f)\n            for i in range(len(d[0])):\n                for j in range(len(d[0])):\n                    print(f\"{d[1][i]}\\t{d[2][j]}\\t{d[0][i][j]}\",file=f )\n        if globals.verbosity &gt;= 2:\n            plt.show()\n        else:\n            plt.clf()\n    for dihed in Dihedrals:\n        plt.hist(df.loc[df[\"Name\"] == dihed.name, \"Data\"], 100, color=\"black\")\n        plt.title(f\"{dihed.name} dihedral\")\n        plt.xlabel(\"Angle\")\n        plt.ylabel(\"Count\")\n        plt.savefig(f\"{globals.WorkDir}Figures/{dihed.name}.eps\",transparent=True)\n        if globals.verbosity &gt;= 2:\n            plt.show()\n        else:\n            plt.clf()\n        d = plt.hist2d(df.loc[df[\"Name\"] == reactioncoordinate, \"Data\"], df.loc[df[\"Name\"] == dihed.name, \"Data\"],100, cmap=\"binary\")    \n        plt.title(f\"Reaction coordinate vs. {dihed.name} dihedral\")\n        plt.ylabel(f\"{dihed.name} dihedral angle\")\n        plt.xlabel(\"Reaction coordinate\")\n        plt.savefig(f\"{globals.WorkDir}Figures/{dihed.name}_2d.eps\",transparent=True)\n        with open(f\"{globals.WorkDir}Figures/{dihed.name}_2d.dat\", 'w') as f:\n            print(f\"x\\ty\\tcount\", file=f)\n            for i in range(len(d[0])):\n                for j in range(len(d[0])):\n                    print(f\"{d[1][i]}\\t{d[2][j]}\\t{d[0][i][j]}\",file=f )\n        if globals.verbosity &gt;= 1:\n            plt.show()\n        else:\n            plt.clf()\n    df.to_csv(f\"{globals.WorkDir}Figures/Data.csv\")\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.analysis.glue_stick","title":"<code>glue_stick(Umbrella, NumJobs, file)</code>","text":"<p>Sticks split jobs back together for analysis.</p> Source code in <code>Tools/analysis.py</code> <pre><code>def glue_stick(Umbrella, NumJobs, file):\n    \"\"\"Sticks split jobs back together for analysis.\"\"\"\n    for i in range(Umbrella.Bins):\n        step, value = [\"#Step\"], [\"Value\"]\n        for j in range(NumJobs):\n            try:\n                coords, datay = utils.data_2d(f\"{globals.WorkDir}{i}/{file}_{j+1}.{i}.colvars.traj\")\n            except FileNotFoundError:\n                print(f\"{globals.WorkDir}{i}/{file}_{j+1}.{i}.colvars.traj is not found. moving on...\")\n                pass\n            step = step + [int(k+(len(step)-1)) for k in coords if k != 0]      # NAMD prints state 0 at the start so will need to remove repeats.\n            value = value + [datay[k] for k in range(len(coords)) if k != 0]\n        utils.file_2dwrite(path=f\"{globals.WorkDir}{i}/{file}.{i}.colvars.traj\",\n                           x=step, y=value)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.analysis.tcl_bondAnalysis","title":"<code>tcl_bondAnalysis(bond, data, simulation, Error_Anal=False)</code>","text":"<p>Runs analysis on 2d data file containing bond lengths and states whether they are within the expected threshold.</p> Source code in <code>Tools/analysis.py</code> <pre><code>def tcl_bondAnalysis(bond, data, simulation, Error_Anal=False):\n    \"\"\"Runs analysis on 2d data file containing bond lengths and states whether they are within the expected threshold.\"\"\"\n    for i in range(len(data)):\n        if i == 0:\n            prevState = \"None\"\n        else:\n            prevState = State\n        if data[i] &lt;= 0.8 * bond.thresh:\n            # log.warning(f\"{bond.name} is short ({data[i]}) for window {simulation}, on trajectory {i}\")\n            State = \"Short\"\n            if Error_Anal == True:\n                print(f\"BondLength = {data[i]}\")\n                return i\n        elif data[i] &gt;= 1.2 * bond.thresh:\n            # log.warning(f\"{bond.name} is long ({data[i]}) for window {simulation}, on trajectory {i}\")\n            State = \"Long\"\n        else:\n            State = \"Normal\"\n        # if State !=  prevState:\n        #     log.warning(f\"{bond.name} has changed to {State} for window {simulation} on step {i}\")\n    if Error_Anal == False:\n        return State\n    else:\n        return len(data)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.analysis.tcl_bondPlot","title":"<code>tcl_bondPlot(bond)</code>","text":"<p>Creates a list of lines for an alaysis tcl script used by vmd which allows for the tracking of bonds.</p> Source code in <code>Tools/analysis.py</code> <pre><code>def tcl_bondPlot(bond):\n    \"\"\"Creates a list of lines for an alaysis tcl script used by vmd which allows for the tracking of bonds.\"\"\"\n    lines = f\"\"\"label add Bonds 0/{bond.at1} 0/{bond.at2}\nlabel graph Bonds 0 {bond.name}.dat\nlabel delete Bonds 0\n\"\"\"\n    return lines\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.analysis.tcl_dihedAnalysis","title":"<code>tcl_dihedAnalysis(dihed, data, window, Error_Anal=False)</code>","text":"<p>Runs analysis on 2d data file containing dihedral angles and states what state they are in.</p> Source code in <code>Tools/analysis.py</code> <pre><code>def tcl_dihedAnalysis(dihed, data, window, Error_Anal=False):\n    \"\"\"Runs analysis on 2d data file containing dihedral angles and states what state they are in.\"\"\"\n    for i in range(len(data)):\n        if i == 0:\n            prevState = \"None\"\n        else:\n            prevState = State\n        Dist1 = numpy.absolute(dihed.target1 - data[i])\n        # print(f\"D1 {Dist1}\")\n        Dist2 = numpy.absolute(dihed.target2 - data[i])\n        # print(f\"D2 {Dist2}\")\n        if Dist1 &lt; Dist2:\n            State = dihed.target1Name\n        elif Dist2 &lt; Dist1:\n            if Error_Anal == True:\n                return i\n            State = dihed.target2Name\n        # if prevState != State:\n        #     log.warning(f\"Dihedral flip from {dihed.name} {prevState} to {State} for window {window}, on step {i}\")\n    if Error_Anal == False:\n        return State\n    else:\n        return len(data)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.analysis.tcl_dihedPlot","title":"<code>tcl_dihedPlot(dihed)</code>","text":"<p>Creates a list of lines for an alaysis tcl script used by vmd which allows for the tracking of Dihedrals.</p> Source code in <code>Tools/analysis.py</code> <pre><code>def tcl_dihedPlot(dihed):\n    \"\"\"Creates a list of lines for an alaysis tcl script used by vmd which allows for the tracking of Dihedrals.\"\"\"\n    lines = f\"\"\"label add Dihedrals 0/{dihed.at1} 0/{dihed.at2} 0/{dihed.at3} 0/{dihed.at4}\nlabel graph Dihedrals 0 {dihed.name}.dat\nlabel delete Dihedrals 0\n\"\"\"\n    return lines\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes","title":"<code>classes</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.BondClass","title":"<code>BondClass</code>","text":"<p>Class for containing bond data Attributes:     atom1 (int): Atom1 in bond     atom2 (int): Atom2 in bond     name (str): Name/ID of bond     threshold (float): Standard value of bond, (Broken if 1.2x bigger)</p> Source code in <code>Tools/classes.py</code> <pre><code>class BondClass:\n    \"\"\"Class for containing bond data\n    Attributes:\n        atom1 (int): Atom1 in bond\n        atom2 (int): Atom2 in bond\n        name (str): Name/ID of bond\n        threshold (float): Standard value of bond, (Broken if 1.2x bigger)\n    \"\"\"\n    def __init__(self, atom1: int, atom2: int, name: str, threshold: float):\n        \"\"\"\n        Bond class init.\n\n        Args:\n            atom1 (int): Atom1 in bond\n            atom2 (int): Atom2 in bond\n            name (str): Name/ID of bond\n            threshold (float): Standard value of bond, (Broken if 1.2x bigger)\n\n        \"\"\"\n        self.at1 = int(atom1)\n        self.at2 = int(atom2)\n        self.name = name\n        self.thresh = threshold\n    def __repr__(self):\n        return f\"Atoms: {self.at1} {self.at2}, name: {self.name}, threshold: {self.thresh}\"\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.BondClass.at1","title":"<code>at1 = int(atom1)</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.BondClass.at2","title":"<code>at2 = int(atom2)</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.BondClass.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.BondClass.thresh","title":"<code>thresh = threshold</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.BondClass.__init__","title":"<code>__init__(atom1, atom2, name, threshold)</code>","text":"<p>Bond class init.</p> <p>Parameters:</p> Name Type Description Default <code>atom1</code> <code>int</code> <p>Atom1 in bond</p> required <code>atom2</code> <code>int</code> <p>Atom2 in bond</p> required <code>name</code> <code>str</code> <p>Name/ID of bond</p> required <code>threshold</code> <code>float</code> <p>Standard value of bond, (Broken if 1.2x bigger)</p> required Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, atom1: int, atom2: int, name: str, threshold: float):\n    \"\"\"\n    Bond class init.\n\n    Args:\n        atom1 (int): Atom1 in bond\n        atom2 (int): Atom2 in bond\n        name (str): Name/ID of bond\n        threshold (float): Standard value of bond, (Broken if 1.2x bigger)\n\n    \"\"\"\n    self.at1 = int(atom1)\n    self.at2 = int(atom2)\n    self.name = name\n    self.thresh = threshold\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.BondClass.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>Tools/classes.py</code> <pre><code>def __repr__(self):\n    return f\"Atoms: {self.at1} {self.at2}, name: {self.name}, threshold: {self.thresh}\"\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.CalcClass","title":"<code>CalcClass</code>","text":"<p>Class for containing generic calculation information</p> <p>Attributes:</p> Name Type Description <code>QM</code> <code>str</code> <p>\"off\" or \"on\" for toggling QMMM calculations.</p> <code>Threads</code> <code>int</code> <p>Number of CPU threads per individual calculation (i.e. per umbrella window)</p> <code>Memory</code> <code>int</code> <p>Ammount of RAM per individual calculation (i.e. per umbrella window)</p> <code>MaxSteps</code> <code>int</code> <p>Maximum number of steps per individual calculation (For breaking long simulations to fit on short HPC queues)</p> <code>Name</code> <code>str</code> <p>Name of Job</p> <code>OutFile</code> <code>str</code> <p>file name</p> <code>Id</code> <code>int</code> <p>SLURM jobID</p> <code>QM</code> <code>str</code> <p>off or on</p> Source code in <code>Tools/classes.py</code> <pre><code>class CalcClass:\n    \"\"\"Class for containing generic calculation information\n\n    Attributes:\n        QM (str): \"off\" or \"on\" for toggling QMMM calculations.\n        Threads (int): Number of CPU threads per individual calculation (i.e. per umbrella window)\n        Memory (int): Ammount of RAM per individual calculation (i.e. per umbrella window)\n        MaxSteps (int): Maximum number of steps per individual calculation (For breaking long simulations to fit on short HPC queues)\n        Name (str): Name of Job\n        OutFile (str): file name\n        Id (int): SLURM jobID\n        QM (str): off or on\n    \"\"\"\n    QM = \"off\"\n    def __init__(self, args: dict):\n        \"\"\"\n        Initiates Calculation class, to set some standard calculation variables. \n        Args:\n            args (dict): ArgParse user input\n\n        Attributes:\n            Threads (int): Number of CPU threads per individual calculation (i.e. per umbrella window)\n            Memory (int): Ammount of RAM per individual calculation (i.e. per umbrella window)\n            MaxSteps (int): Maximum number of steps per individual calculation (For breaking long simulations to fit on short HPC queues)\n        \"\"\"\n        self.Threads = args[\"CoresPerJob\"]\n        self.Memory = args[\"MemoryPerJob\"]\n        try:\n            self.MaxSteps = args[\"MaxStepsPerCalc\"]\n        except KeyError:\n            self.MaxSteps = 0\n    def Job_Name(self, Name: str,):\n        \"\"\"\n        Sets the job name \n\n        Args:\n            Name (str): Name of Job\n\n        \"\"\"  \n        self.Name = Name\n    def Set_OutFile(self, OutFile: str):\n        \"\"\"\n        sets the output file name\n\n        Args:\n            OutFile (str): file name\n        \"\"\"\n        self.OutFile = OutFile\n    def Set_Id(self, Id: int):\n        \"\"\"\n        Gets the slurm ID of the calculation         \n\n        Args:\n            Id (int): SLURM jobID\n        \"\"\"\n        self.Id = Id\n    def Set_QM(self, QM: str):\n        \"\"\"\n        Sets the QM state of the calculation\n        Args:\n            QM (str): off or on\n        \"\"\"\n        self.QM = QM\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.CalcClass.MaxSteps","title":"<code>MaxSteps = args['MaxStepsPerCalc']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.CalcClass.Memory","title":"<code>Memory = args['MemoryPerJob']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.CalcClass.QM","title":"<code>QM = 'off'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.CalcClass.Threads","title":"<code>Threads = args['CoresPerJob']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.CalcClass.Job_Name","title":"<code>Job_Name(Name)</code>","text":"<p>Sets the job name </p> <p>Parameters:</p> Name Type Description Default <code>Name</code> <code>str</code> <p>Name of Job</p> required Source code in <code>Tools/classes.py</code> <pre><code>def Job_Name(self, Name: str,):\n    \"\"\"\n    Sets the job name \n\n    Args:\n        Name (str): Name of Job\n\n    \"\"\"  \n    self.Name = Name\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.CalcClass.Set_Id","title":"<code>Set_Id(Id)</code>","text":"<p>Gets the slurm ID of the calculation         </p> <p>Parameters:</p> Name Type Description Default <code>Id</code> <code>int</code> <p>SLURM jobID</p> required Source code in <code>Tools/classes.py</code> <pre><code>def Set_Id(self, Id: int):\n    \"\"\"\n    Gets the slurm ID of the calculation         \n\n    Args:\n        Id (int): SLURM jobID\n    \"\"\"\n    self.Id = Id\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.CalcClass.Set_OutFile","title":"<code>Set_OutFile(OutFile)</code>","text":"<p>sets the output file name</p> <p>Parameters:</p> Name Type Description Default <code>OutFile</code> <code>str</code> <p>file name</p> required Source code in <code>Tools/classes.py</code> <pre><code>def Set_OutFile(self, OutFile: str):\n    \"\"\"\n    sets the output file name\n\n    Args:\n        OutFile (str): file name\n    \"\"\"\n    self.OutFile = OutFile\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.CalcClass.Set_QM","title":"<code>Set_QM(QM)</code>","text":"<p>Sets the QM state of the calculation Args:     QM (str): off or on</p> Source code in <code>Tools/classes.py</code> <pre><code>def Set_QM(self, QM: str):\n    \"\"\"\n    Sets the QM state of the calculation\n    Args:\n        QM (str): off or on\n    \"\"\"\n    self.QM = QM\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.CalcClass.__init__","title":"<code>__init__(args)</code>","text":"<p>Initiates Calculation class, to set some standard calculation variables.  Args:     args (dict): ArgParse user input</p> <p>Attributes:</p> Name Type Description <code>Threads</code> <code>int</code> <p>Number of CPU threads per individual calculation (i.e. per umbrella window)</p> <code>Memory</code> <code>int</code> <p>Ammount of RAM per individual calculation (i.e. per umbrella window)</p> <code>MaxSteps</code> <code>int</code> <p>Maximum number of steps per individual calculation (For breaking long simulations to fit on short HPC queues)</p> Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, args: dict):\n    \"\"\"\n    Initiates Calculation class, to set some standard calculation variables. \n    Args:\n        args (dict): ArgParse user input\n\n    Attributes:\n        Threads (int): Number of CPU threads per individual calculation (i.e. per umbrella window)\n        Memory (int): Ammount of RAM per individual calculation (i.e. per umbrella window)\n        MaxSteps (int): Maximum number of steps per individual calculation (For breaking long simulations to fit on short HPC queues)\n    \"\"\"\n    self.Threads = args[\"CoresPerJob\"]\n    self.Memory = args[\"MemoryPerJob\"]\n    try:\n        self.MaxSteps = args[\"MaxStepsPerCalc\"]\n    except KeyError:\n        self.MaxSteps = 0\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DataClass","title":"<code>DataClass</code>","text":"<p>Class for containing generic analysis data. Attributes:     dat: List of data DataFrames</p> Source code in <code>Tools/classes.py</code> <pre><code>class DataClass:\n    \"\"\"Class for containing generic analysis data.\n    Attributes:\n        dat: List of data DataFrames\n    \"\"\"\n    dat = []\n    def __init__(self, Name: str,):\n        \"\"\"\n        Data class init. for use in structure/trajectory analysis\n\n        Args:\n            Name (str): Name of data\n        \"\"\"\n        self.name = Name\n    def add_data(self, name:str, window:int, data:float):\n        \"\"\"\n        Adds data to the data class\n        Args:\n            name (str): name/ID of analysis variable \n            window (int): window\n            data (float): data point\n\n        \"\"\"\n        self.dat.append(pd.DataFrame(\n            data={\"Name\": name, \"Window\": window, \"Data\": data}))\n    def __repr__(self):\n        return f\"{self.name}: \\n{self.dat}\"\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DataClass.dat","title":"<code>dat = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DataClass.name","title":"<code>name = Name</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DataClass.__init__","title":"<code>__init__(Name)</code>","text":"<p>Data class init. for use in structure/trajectory analysis</p> <p>Parameters:</p> Name Type Description Default <code>Name</code> <code>str</code> <p>Name of data</p> required Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, Name: str,):\n    \"\"\"\n    Data class init. for use in structure/trajectory analysis\n\n    Args:\n        Name (str): Name of data\n    \"\"\"\n    self.name = Name\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DataClass.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>Tools/classes.py</code> <pre><code>def __repr__(self):\n    return f\"{self.name}: \\n{self.dat}\"\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DataClass.add_data","title":"<code>add_data(name, window, data)</code>","text":"<p>Adds data to the data class Args:     name (str): name/ID of analysis variable      window (int): window     data (float): data point</p> Source code in <code>Tools/classes.py</code> <pre><code>def add_data(self, name:str, window:int, data:float):\n    \"\"\"\n    Adds data to the data class\n    Args:\n        name (str): name/ID of analysis variable \n        window (int): window\n        data (float): data point\n\n    \"\"\"\n    self.dat.append(pd.DataFrame(\n        data={\"Name\": name, \"Window\": window, \"Data\": data}))\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass","title":"<code>DihedralClass</code>","text":"<p>Class for containing dihedral data Attributes:     atom1 (int): Atom1 in dihedral     atom2 (int): Atom2 in dihedral     atom3 (int): Atom3 in dihedral     atom4 (int): Atom4 in dihedral     name (str): Name of dihedral angle     target1 (float): Value of primary dihedral state     t1name (str): Name or ID of primary dihedral state     target2 (float): Value of secondary dihedral state     t2name (str): Name or ID of secondary dihedral state</p> Source code in <code>Tools/classes.py</code> <pre><code>class DihedralClass:\n    \"\"\"Class for containing dihedral data\n    Attributes:\n        atom1 (int): Atom1 in dihedral\n        atom2 (int): Atom2 in dihedral\n        atom3 (int): Atom3 in dihedral\n        atom4 (int): Atom4 in dihedral\n        name (str): Name of dihedral angle\n        target1 (float): Value of primary dihedral state\n        t1name (str): Name or ID of primary dihedral state\n        target2 (float): Value of secondary dihedral state\n        t2name (str): Name or ID of secondary dihedral state\n    \"\"\"\n    def __init__(self, atom1: int, atom2: int, atom3: int, atom4: int, name: str, target1: float, t1name: str, target2: float, t2name: str):\n        \"\"\"\n        Dihedral class Init.\n\n        Args:\n            atom1 (int): Atom1 in dihedral\n            atom2 (int): Atom2 in dihedral\n            atom3 (int): Atom3 in dihedral\n            atom4 (int): Atom4 in dihedral\n            name (str): Name of dihedral angle\n            target1 (float): Value of primary dihedral state\n            t1name (str): Name or ID of primary dihedral state\n            target2 (float): Value of secondary dihedral state\n            t2name (str): Name or ID of secondary dihedral state\n\n        \"\"\"\n        self.at1 = int(atom1)\n        self.at2 = int(atom2)\n        self.at3 = int(atom3)\n        self.at4 = int(atom4)\n        self.name = name\n        self.target1 = target1\n        self.target1Name = t1name\n        self.target2 = target2\n        self.target2Name = t2name\n    def __repr__(self):\n        return f\"Atoms: {self.at1} {self.at2} {self.at3} {self.at4}, Name: {self.name}, {self.target1Name} = {self.target1}, {self.target2Name} = {self.target2}\"\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass.at1","title":"<code>at1 = int(atom1)</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass.at2","title":"<code>at2 = int(atom2)</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass.at3","title":"<code>at3 = int(atom3)</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass.at4","title":"<code>at4 = int(atom4)</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass.target1","title":"<code>target1 = target1</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass.target1Name","title":"<code>target1Name = t1name</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass.target2","title":"<code>target2 = target2</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass.target2Name","title":"<code>target2Name = t2name</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass.__init__","title":"<code>__init__(atom1, atom2, atom3, atom4, name, target1, t1name, target2, t2name)</code>","text":"<p>Dihedral class Init.</p> <p>Parameters:</p> Name Type Description Default <code>atom1</code> <code>int</code> <p>Atom1 in dihedral</p> required <code>atom2</code> <code>int</code> <p>Atom2 in dihedral</p> required <code>atom3</code> <code>int</code> <p>Atom3 in dihedral</p> required <code>atom4</code> <code>int</code> <p>Atom4 in dihedral</p> required <code>name</code> <code>str</code> <p>Name of dihedral angle</p> required <code>target1</code> <code>float</code> <p>Value of primary dihedral state</p> required <code>t1name</code> <code>str</code> <p>Name or ID of primary dihedral state</p> required <code>target2</code> <code>float</code> <p>Value of secondary dihedral state</p> required <code>t2name</code> <code>str</code> <p>Name or ID of secondary dihedral state</p> required Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, atom1: int, atom2: int, atom3: int, atom4: int, name: str, target1: float, t1name: str, target2: float, t2name: str):\n    \"\"\"\n    Dihedral class Init.\n\n    Args:\n        atom1 (int): Atom1 in dihedral\n        atom2 (int): Atom2 in dihedral\n        atom3 (int): Atom3 in dihedral\n        atom4 (int): Atom4 in dihedral\n        name (str): Name of dihedral angle\n        target1 (float): Value of primary dihedral state\n        t1name (str): Name or ID of primary dihedral state\n        target2 (float): Value of secondary dihedral state\n        t2name (str): Name or ID of secondary dihedral state\n\n    \"\"\"\n    self.at1 = int(atom1)\n    self.at2 = int(atom2)\n    self.at3 = int(atom3)\n    self.at4 = int(atom4)\n    self.name = name\n    self.target1 = target1\n    self.target1Name = t1name\n    self.target2 = target2\n    self.target2Name = t2name\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.DihedralClass.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>Tools/classes.py</code> <pre><code>def __repr__(self):\n    return f\"Atoms: {self.at1} {self.at2} {self.at3} {self.at4}, Name: {self.name}, {self.target1Name} = {self.target1}, {self.target2Name} = {self.target2}\"\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass","title":"<code>LabelClass</code>","text":"<p>Class for containing bond and dihedral label information (For structure analysis) Attributes:     bond (list[str]): List of bond atom selections in format: (\"at1,at2\")     bondName (list[str]): List of bond names     bondThresh (list[float]): List of standard bond lengths     dihedral (list[str]): List of dihedral atom selections in format: (\"at1,at2,at3,at4\")     dihedralName (list[str]): List of dihedral names     dihedralTarget1 (list[float]): List of dihedral primary values     dihedralTarget2 (list[float]): List of dihedral secondary values     dihedralTarget1Name (list[str]): List of names/ID for primary dihedral values     dihedralTarget2Name (list[str]): List of names/ID for secondary dihedral values     parm (str): parameter file to be loaded by vmd     file (str): coordinate file to be loaded by vmd</p> Source code in <code>Tools/classes.py</code> <pre><code>class LabelClass:\n    \"\"\"Class for containing bond and dihedral label information (For structure analysis)\n    Attributes:\n        bond (list[str]): List of bond atom selections in format: (\"at1,at2\")\n        bondName (list[str]): List of bond names\n        bondThresh (list[float]): List of standard bond lengths\n        dihedral (list[str]): List of dihedral atom selections in format: (\"at1,at2,at3,at4\")\n        dihedralName (list[str]): List of dihedral names\n        dihedralTarget1 (list[float]): List of dihedral primary values\n        dihedralTarget2 (list[float]): List of dihedral secondary values\n        dihedralTarget1Name (list[str]): List of names/ID for primary dihedral values\n        dihedralTarget2Name (list[str]): List of names/ID for secondary dihedral values\n        parm (str): parameter file to be loaded by vmd\n        file (str): coordinate file to be loaded by vmd \n    \"\"\"\n    bond = []\n    bondName = []\n    bondThresh = []\n    dihedral = []\n    dihedralName = []\n    dihedralTarget1 = []\n    dihedralTarget2 = []\n    dihedralTarget1Name = []\n    dihedralTarget2Name = []\n    def __init__(self,  parm: str):\n        \"\"\"\n        Initialises a label class, used for structural analysis\n\n        Args:\n            parm (str): filename of param file for use in vmd.\n        \"\"\"\n        self.parm = parm\n    def add_bond(self, selection: str, name: str, thresh: float):\n        \"\"\"\n        Adds bond labels to the label class.\n\n        Args:\n            selection (str): Atomic selection, as a coma delimited string in style \"at1,at2\"\n            name (str): Name/ID of bond\n            thresh (float): Standard bond length (bond classed as broken at 1.2x thresh)\n\n        Attributes:\n            bond (list[str]): List of bond atom selections in format: (\"at1,at2\")\n            bondName (list[str]): List of bond names\n            bondThresh (list[float]): List of standard bond lengths\n        \"\"\"\n        self.bond.append(selection)\n        self.bondName.append(name)\n        self.bondThresh.append(thresh)\n    def add_dihedral(self, selection: str, name: str, target1: float, t1name:str , target2: float, t2name:str):\n        \"\"\"\n        Adds dihedral labels to the label class.\n\n        Args:\n            selection (str): Atom selection, as a coma delimited string in style \"at1, at2, at3, at4\"\n            name (str): Name/ID of dihedral\n            target1 (float): Primary value of dihedral angle\n            t1name (str): Name/ID of primary dihedral angle\n            target2 (float): Secondary value of dihedral angle\n            t2name (str): Name/ID of secondary dihedral angle\n\n        Attributes:\n            dihedral (list[str]): List of dihedral atom selections in format: (\"at1,at2,at3,at4\")\n            dihedralName (list[str]): List of dihedral names\n            dihedralTarget1 (list[float]): List of dihedral primary values\n            dihedralTarget2 (list[float]): List of dihedral secondary values\n            dihedralTarget1Name (list[str]): List of names/ID for primary dihedral values\n            dihedralTarget2Name (list[str]): List of names/ID for secondary dihedral values\n        \"\"\"\n        self.dihedral.append(selection)\n        self.dihedralName.append(name)\n        self.dihedralTarget1.append(target1)\n        self.dihedralTarget1Name.append(t1name)\n        self.dihedralTarget2.append(target2)\n        self.dihedralTarget2Name.append(t2name)\n    def file_name(self, name: str):\n        \"\"\"\n        Name of coordinate file to be loaded by vmd\n\n        Args:\n            name (str): filename of coordinates\n\n        \"\"\"\n        self.file = name\n    def clear_Vars(self):\n        \"\"\"\n        Clears all label data, whilst maintaining file and param.\n        \"\"\"\n        self.bond = []\n        self.bondName = []\n        self.bondThresh = []\n        self.dihedral = []\n        self.dihedralName = []\n        self.dihedralTarget1 = []\n        self.dihedralTarget2 = []\n        self.dihedralTarget1Name = []\n        self.dihedralTarget2Name = []\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.bond","title":"<code>bond = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.bondName","title":"<code>bondName = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.bondThresh","title":"<code>bondThresh = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.dihedral","title":"<code>dihedral = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.dihedralName","title":"<code>dihedralName = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.dihedralTarget1","title":"<code>dihedralTarget1 = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.dihedralTarget1Name","title":"<code>dihedralTarget1Name = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.dihedralTarget2","title":"<code>dihedralTarget2 = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.dihedralTarget2Name","title":"<code>dihedralTarget2Name = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.parm","title":"<code>parm = parm</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.__init__","title":"<code>__init__(parm)</code>","text":"<p>Initialises a label class, used for structural analysis</p> <p>Parameters:</p> Name Type Description Default <code>parm</code> <code>str</code> <p>filename of param file for use in vmd.</p> required Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self,  parm: str):\n    \"\"\"\n    Initialises a label class, used for structural analysis\n\n    Args:\n        parm (str): filename of param file for use in vmd.\n    \"\"\"\n    self.parm = parm\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.add_bond","title":"<code>add_bond(selection, name, thresh)</code>","text":"<p>Adds bond labels to the label class.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>str</code> <p>Atomic selection, as a coma delimited string in style \"at1,at2\"</p> required <code>name</code> <code>str</code> <p>Name/ID of bond</p> required <code>thresh</code> <code>float</code> <p>Standard bond length (bond classed as broken at 1.2x thresh)</p> required <p>Attributes:</p> Name Type Description <code>bond</code> <code>list[str]</code> <p>List of bond atom selections in format: (\"at1,at2\")</p> <code>bondName</code> <code>list[str]</code> <p>List of bond names</p> <code>bondThresh</code> <code>list[float]</code> <p>List of standard bond lengths</p> Source code in <code>Tools/classes.py</code> <pre><code>def add_bond(self, selection: str, name: str, thresh: float):\n    \"\"\"\n    Adds bond labels to the label class.\n\n    Args:\n        selection (str): Atomic selection, as a coma delimited string in style \"at1,at2\"\n        name (str): Name/ID of bond\n        thresh (float): Standard bond length (bond classed as broken at 1.2x thresh)\n\n    Attributes:\n        bond (list[str]): List of bond atom selections in format: (\"at1,at2\")\n        bondName (list[str]): List of bond names\n        bondThresh (list[float]): List of standard bond lengths\n    \"\"\"\n    self.bond.append(selection)\n    self.bondName.append(name)\n    self.bondThresh.append(thresh)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.add_dihedral","title":"<code>add_dihedral(selection, name, target1, t1name, target2, t2name)</code>","text":"<p>Adds dihedral labels to the label class.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>str</code> <p>Atom selection, as a coma delimited string in style \"at1, at2, at3, at4\"</p> required <code>name</code> <code>str</code> <p>Name/ID of dihedral</p> required <code>target1</code> <code>float</code> <p>Primary value of dihedral angle</p> required <code>t1name</code> <code>str</code> <p>Name/ID of primary dihedral angle</p> required <code>target2</code> <code>float</code> <p>Secondary value of dihedral angle</p> required <code>t2name</code> <code>str</code> <p>Name/ID of secondary dihedral angle</p> required <p>Attributes:</p> Name Type Description <code>dihedral</code> <code>list[str]</code> <p>List of dihedral atom selections in format: (\"at1,at2,at3,at4\")</p> <code>dihedralName</code> <code>list[str]</code> <p>List of dihedral names</p> <code>dihedralTarget1</code> <code>list[float]</code> <p>List of dihedral primary values</p> <code>dihedralTarget2</code> <code>list[float]</code> <p>List of dihedral secondary values</p> <code>dihedralTarget1Name</code> <code>list[str]</code> <p>List of names/ID for primary dihedral values</p> <code>dihedralTarget2Name</code> <code>list[str]</code> <p>List of names/ID for secondary dihedral values</p> Source code in <code>Tools/classes.py</code> <pre><code>def add_dihedral(self, selection: str, name: str, target1: float, t1name:str , target2: float, t2name:str):\n    \"\"\"\n    Adds dihedral labels to the label class.\n\n    Args:\n        selection (str): Atom selection, as a coma delimited string in style \"at1, at2, at3, at4\"\n        name (str): Name/ID of dihedral\n        target1 (float): Primary value of dihedral angle\n        t1name (str): Name/ID of primary dihedral angle\n        target2 (float): Secondary value of dihedral angle\n        t2name (str): Name/ID of secondary dihedral angle\n\n    Attributes:\n        dihedral (list[str]): List of dihedral atom selections in format: (\"at1,at2,at3,at4\")\n        dihedralName (list[str]): List of dihedral names\n        dihedralTarget1 (list[float]): List of dihedral primary values\n        dihedralTarget2 (list[float]): List of dihedral secondary values\n        dihedralTarget1Name (list[str]): List of names/ID for primary dihedral values\n        dihedralTarget2Name (list[str]): List of names/ID for secondary dihedral values\n    \"\"\"\n    self.dihedral.append(selection)\n    self.dihedralName.append(name)\n    self.dihedralTarget1.append(target1)\n    self.dihedralTarget1Name.append(t1name)\n    self.dihedralTarget2.append(target2)\n    self.dihedralTarget2Name.append(t2name)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.clear_Vars","title":"<code>clear_Vars()</code>","text":"<p>Clears all label data, whilst maintaining file and param.</p> Source code in <code>Tools/classes.py</code> <pre><code>def clear_Vars(self):\n    \"\"\"\n    Clears all label data, whilst maintaining file and param.\n    \"\"\"\n    self.bond = []\n    self.bondName = []\n    self.bondThresh = []\n    self.dihedral = []\n    self.dihedralName = []\n    self.dihedralTarget1 = []\n    self.dihedralTarget2 = []\n    self.dihedralTarget1Name = []\n    self.dihedralTarget2Name = []\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.LabelClass.file_name","title":"<code>file_name(name)</code>","text":"<p>Name of coordinate file to be loaded by vmd</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>filename of coordinates</p> required Source code in <code>Tools/classes.py</code> <pre><code>def file_name(self, name: str):\n    \"\"\"\n    Name of coordinate file to be loaded by vmd\n\n    Args:\n        name (str): filename of coordinates\n\n    \"\"\"\n    self.file = name\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass","title":"<code>MMClass</code>","text":"<p>Class for containing molecular mechanics calculation information</p> <p>Attributes:</p> Name Type Description <code>CPUNamd</code> <code>str</code> <p>Path to CPU version of NAMD (For QMMM)</p> <code>GPUNamd</code> <code>str</code> <p>Path to GPU version of NAMD (For MD)</p> <code>Shake</code> <code>str</code> <p>NAMD shake settings, usually all or none</p> <code>TimeOut</code> <code>int</code> <p>Frequency to print out TIMING and PERFORMANCE data</p> <code>RestOut</code> <code>int</code> <p>Frequency to update the restart files</p> <code>TrajOut</code> <code>int</code> <p>Frequency to add frames to the trajectory file</p> <code>Temp</code> <code>float</code> <p>Temperature of simulation.</p> <code>Ensemble</code> <code>str</code> <p>min, heat, NVT or NVP</p> <code>Steps</code> <code>int</code> <p>Number of steps in the simulation</p> <code>TimeStep</code> <code>float</code> <p>Time step in fs</p> <code>CellVec</code> <code>float</code> <p>Cell vector in Angstrom</p> <code>Force</code> <code>float</code> <p>Force constant used by the colvar module</p> <code>parmfile</code> <code>str</code> <p>file of the amber parameters (.parm7)</p> <code>ambercoor</code> <code>str</code> <p>file of the amber coordinates (.rst7)</p> <code>PME</code> <code>str</code> <p>Defines the PME interactions (off or on)</p> <code>CutOff</code> <code>float</code> <p>Sets the long range cutoff distance</p> Source code in <code>Tools/classes.py</code> <pre><code>class MMClass:\n    \"\"\"Class for containing molecular mechanics calculation information\n\n    Attributes:\n        CPUNamd (str): Path to CPU version of NAMD (For QMMM)\n        GPUNamd (str): Path to GPU version of NAMD (For MD)\n        Shake (str): NAMD shake settings, usually all or none\n        TimeOut (int): Frequency to print out TIMING and PERFORMANCE data\n        RestOut (int): Frequency to update the restart files\n        TrajOut (int): Frequency to add frames to the trajectory file\n        Temp (float): Temperature of simulation.\n        Ensemble (str): min, heat, NVT or NVP\n        Steps (int): Number of steps in the simulation\n        TimeStep (float): Time step in fs\n        CellVec (float): Cell vector in Angstrom\n        Force (float): Force constant used by the colvar module\n        parmfile (str): file of the amber parameters (.parm7)\n        ambercoor (str): file of the amber coordinates (.rst7)\n        PME (str): Defines the PME interactions (off or on)\n        CutOff (float): Sets the long range cutoff distance\n    \"\"\"\n    CellVec = 150.2205127 # Default although should change. \n    CellShape = \"oct\"\n    Temp = MMVars[\"temperature\"]\n    CutOff = MMVars[\"cutoff\"]\n    PME = \"off\"\n    parmfile = f\"../{globals.parmfile}\"\n    ambercoor = \"../start.rst7\"\n    Shake = \"none\"\n    def __init__(self, ):\n        \"\"\"\n        Contains MD parameters\n\n        Attributes:\n            CPUNamd (str): Path to CPU version of NAMD (For QMMM)\n            GPUNamd (str): Path to GPU version of NAMD (For MD)\n        \"\"\"\n        self.CPUNamd = NAMD_CPU\n        self.GPUNamd = NAMD_GPU\n    def Set_Shake(self, Shake: str):\n        \"\"\"\n        Defines the shake/rattle state. (For restraining bonds during large time steps.)\n\n        Args:\n            Shake (str): NAMD shake settings, usually all, water or none\n        \"\"\"\n        self.Shake = Shake\n    def Set_Outputs(self, TimeOut: int, RestOut: int, TrajOut: int):\n        \"\"\"\n        Defines how often to print simulation data.\n\n        Args:\n            TimeOut (int): Frequency to print out TIMING and PERFORMANCE data\n            RestOut (int): Frequency to update the restart files\n            TrajOut (int): Frequency to add frames to the trajectory file\n        \"\"\"\n        self.TimeOut = TimeOut\n        self.RestOut = RestOut\n        self.TrajOut = TrajOut\n    def Set_Temp(self, Temp: float):\n        \"\"\"\n        Sets/Changes the temperature of the simulation\n\n        Args:\n            Temp (float): Temperature of simulation.\n        \"\"\"\n        self.Temp = Temp\n    def Set_Ensemble(self, Ensemble: str):\n        \"\"\"\n        Sets the ensemble of the simulation.\n        Args:\n            Ensemble (str): min, heat, NVT or NVP\n\n        \"\"\"\n        self.Ensemble = Ensemble\n    def Set_Length(self, Steps: int, TimeStep: float=0.05):\n        \"\"\"\n        Defines simulation length \n\n        Args:\n            Steps (int): Number of steps in the simulation\n            TimeStep (float=0.05): Time step in fs\n        \"\"\"\n        self.Steps = int(Steps)\n        self.TimeStep = float(TimeStep)\n    def Change_Cell(self, CellVec: float):\n        \"\"\"\n        Changes the cell vector, (used when reading in from the parm file)\n\n        Args:\n            CellVec (float): Cell vector in Angstrom\n\n        \"\"\"\n        self.CellVec = CellVec\n    def Set_Force(self, Force: float):\n        \"\"\"\n        Sets the force when running steered MD or umbrella sampling\n\n        Args:\n            Force (float): Force constant used by the colvar module\n        \"\"\"\n        self.Force = Force\n    def Set_Files(self, parm: str, ambercoor: str):\n        \"\"\"\n        Defines amber files that are required when using amber parameters\n\n        Args:\n            parm (str): file of the amber parameters (.parm7)\n            ambercoor (str): file of the amber coordinates (.rst7)\n        \"\"\"\n        self.parmfile = parm\n        self.ambercoor = ambercoor\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.CPUNamd","title":"<code>CPUNamd = NAMD_CPU</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.CellShape","title":"<code>CellShape = 'oct'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.CellVec","title":"<code>CellVec = 150.2205127</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.CutOff","title":"<code>CutOff = MMVars['cutoff']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.GPUNamd","title":"<code>GPUNamd = NAMD_GPU</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.PME","title":"<code>PME = 'off'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.Shake","title":"<code>Shake = 'none'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.Temp","title":"<code>Temp = MMVars['temperature']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.ambercoor","title":"<code>ambercoor = '../start.rst7'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.parmfile","title":"<code>parmfile = f'../{globals.parmfile}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.Change_Cell","title":"<code>Change_Cell(CellVec)</code>","text":"<p>Changes the cell vector, (used when reading in from the parm file)</p> <p>Parameters:</p> Name Type Description Default <code>CellVec</code> <code>float</code> <p>Cell vector in Angstrom</p> required Source code in <code>Tools/classes.py</code> <pre><code>def Change_Cell(self, CellVec: float):\n    \"\"\"\n    Changes the cell vector, (used when reading in from the parm file)\n\n    Args:\n        CellVec (float): Cell vector in Angstrom\n\n    \"\"\"\n    self.CellVec = CellVec\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.Set_Ensemble","title":"<code>Set_Ensemble(Ensemble)</code>","text":"<p>Sets the ensemble of the simulation. Args:     Ensemble (str): min, heat, NVT or NVP</p> Source code in <code>Tools/classes.py</code> <pre><code>def Set_Ensemble(self, Ensemble: str):\n    \"\"\"\n    Sets the ensemble of the simulation.\n    Args:\n        Ensemble (str): min, heat, NVT or NVP\n\n    \"\"\"\n    self.Ensemble = Ensemble\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.Set_Files","title":"<code>Set_Files(parm, ambercoor)</code>","text":"<p>Defines amber files that are required when using amber parameters</p> <p>Parameters:</p> Name Type Description Default <code>parm</code> <code>str</code> <p>file of the amber parameters (.parm7)</p> required <code>ambercoor</code> <code>str</code> <p>file of the amber coordinates (.rst7)</p> required Source code in <code>Tools/classes.py</code> <pre><code>def Set_Files(self, parm: str, ambercoor: str):\n    \"\"\"\n    Defines amber files that are required when using amber parameters\n\n    Args:\n        parm (str): file of the amber parameters (.parm7)\n        ambercoor (str): file of the amber coordinates (.rst7)\n    \"\"\"\n    self.parmfile = parm\n    self.ambercoor = ambercoor\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.Set_Force","title":"<code>Set_Force(Force)</code>","text":"<p>Sets the force when running steered MD or umbrella sampling</p> <p>Parameters:</p> Name Type Description Default <code>Force</code> <code>float</code> <p>Force constant used by the colvar module</p> required Source code in <code>Tools/classes.py</code> <pre><code>def Set_Force(self, Force: float):\n    \"\"\"\n    Sets the force when running steered MD or umbrella sampling\n\n    Args:\n        Force (float): Force constant used by the colvar module\n    \"\"\"\n    self.Force = Force\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.Set_Length","title":"<code>Set_Length(Steps, TimeStep=0.05)</code>","text":"<p>Defines simulation length </p> <p>Parameters:</p> Name Type Description Default <code>Steps</code> <code>int</code> <p>Number of steps in the simulation</p> required <code>TimeStep</code> <code>float=0.05</code> <p>Time step in fs</p> <code>0.05</code> Source code in <code>Tools/classes.py</code> <pre><code>def Set_Length(self, Steps: int, TimeStep: float=0.05):\n    \"\"\"\n    Defines simulation length \n\n    Args:\n        Steps (int): Number of steps in the simulation\n        TimeStep (float=0.05): Time step in fs\n    \"\"\"\n    self.Steps = int(Steps)\n    self.TimeStep = float(TimeStep)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.Set_Outputs","title":"<code>Set_Outputs(TimeOut, RestOut, TrajOut)</code>","text":"<p>Defines how often to print simulation data.</p> <p>Parameters:</p> Name Type Description Default <code>TimeOut</code> <code>int</code> <p>Frequency to print out TIMING and PERFORMANCE data</p> required <code>RestOut</code> <code>int</code> <p>Frequency to update the restart files</p> required <code>TrajOut</code> <code>int</code> <p>Frequency to add frames to the trajectory file</p> required Source code in <code>Tools/classes.py</code> <pre><code>def Set_Outputs(self, TimeOut: int, RestOut: int, TrajOut: int):\n    \"\"\"\n    Defines how often to print simulation data.\n\n    Args:\n        TimeOut (int): Frequency to print out TIMING and PERFORMANCE data\n        RestOut (int): Frequency to update the restart files\n        TrajOut (int): Frequency to add frames to the trajectory file\n    \"\"\"\n    self.TimeOut = TimeOut\n    self.RestOut = RestOut\n    self.TrajOut = TrajOut\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.Set_Shake","title":"<code>Set_Shake(Shake)</code>","text":"<p>Defines the shake/rattle state. (For restraining bonds during large time steps.)</p> <p>Parameters:</p> Name Type Description Default <code>Shake</code> <code>str</code> <p>NAMD shake settings, usually all, water or none</p> required Source code in <code>Tools/classes.py</code> <pre><code>def Set_Shake(self, Shake: str):\n    \"\"\"\n    Defines the shake/rattle state. (For restraining bonds during large time steps.)\n\n    Args:\n        Shake (str): NAMD shake settings, usually all, water or none\n    \"\"\"\n    self.Shake = Shake\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.Set_Temp","title":"<code>Set_Temp(Temp)</code>","text":"<p>Sets/Changes the temperature of the simulation</p> <p>Parameters:</p> Name Type Description Default <code>Temp</code> <code>float</code> <p>Temperature of simulation.</p> required Source code in <code>Tools/classes.py</code> <pre><code>def Set_Temp(self, Temp: float):\n    \"\"\"\n    Sets/Changes the temperature of the simulation\n\n    Args:\n        Temp (float): Temperature of simulation.\n    \"\"\"\n    self.Temp = Temp\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MMClass.__init__","title":"<code>__init__()</code>","text":"<p>Contains MD parameters</p> <p>Attributes:</p> Name Type Description <code>CPUNamd</code> <code>str</code> <p>Path to CPU version of NAMD (For QMMM)</p> <code>GPUNamd</code> <code>str</code> <p>Path to GPU version of NAMD (For MD)</p> Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, ):\n    \"\"\"\n    Contains MD parameters\n\n    Attributes:\n        CPUNamd (str): Path to CPU version of NAMD (For QMMM)\n        GPUNamd (str): Path to GPU version of NAMD (For MD)\n    \"\"\"\n    self.CPUNamd = NAMD_CPU\n    self.GPUNamd = NAMD_GPU\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MolClass","title":"<code>MolClass</code>","text":"<p>Class for containing molecular information including coordinates and charges. This is used for benchmarking only</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name of molecule</p> <code>charge</code> <code>int</code> <p>net charge of molecule</p> <code>spin</code> <code>int</code> <p>total spin of molecule</p> <code>element</code> <code>list</code> <p>list of elements ( in order of coordinates)</p> <code>x</code> <code>list</code> <p>list of x coordinates</p> <code>y</code> <code>list</code> <p>list of y coordinates</p> <code>z</code> <code>list</code> <p>list of z coordinates</p> <code>nat</code> <code>int</code> <p>Total number of atoms</p> Source code in <code>Tools/classes.py</code> <pre><code>class MolClass:\n    \"\"\"Class for containing molecular information including coordinates and charges. This is used for benchmarking only\n\n    Attributes:\n        name (str): name of molecule\n        charge (int): net charge of molecule\n        spin (int): total spin of molecule\n        element (list): list of elements ( in order of coordinates)\n        x (list): list of x coordinates\n        y (list): list of y coordinates\n        z (list): list of z coordinates\n        nat (int): Total number of atoms\n    \"\"\"\n    def __init__(self, name:str):\n        \"\"\"\n        Gets the name of the molecule\n\n        Args:\n            name (str): Name of the molecule\n\n        \"\"\"\n        self.name = name\n    def set_charge(self, charge: int, spin: int):\n        \"\"\"\n        Sets the charge and spin of the molecule\n\n        Args:\n            charge (int): Net charge of the molecule (Only whole charge supported)\n            spin (int): Spin state of the molecule as defined by ORCA\n\n        \"\"\"\n        assert type(charge) is int, \"Charge must be an integer, partial charges are not supported\"\n        self.charge = charge\n        assert type(spin) is int, \"Spin must be an integer, partial spins are not supported\"\n        self.spin = spin\n    def add_coordinates(self, at: list, x: list, y: list, z: list, nat: int):\n        \"\"\"\n        Adds all structural information to the molecule\n        Args:\n            at (list): list of elements ( in order of coordinates)\n            x (list): list of x coordinates\n            y (list): list of y coordinates\n            z (list): list of z coordinates\n            nat (int): Total number of atoms\n\n        \"\"\"\n        assert len(x) == len(y) == len(z) == len(at) == nat, \"Coordinates are broken... x,y&amp;z coordinates are different lengths\"\n        self.element = at\n        self.x = x\n        self.y = y\n        self.z = z\n        self.nat = nat\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MolClass.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MolClass.__init__","title":"<code>__init__(name)</code>","text":"<p>Gets the name of the molecule</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the molecule</p> required Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, name:str):\n    \"\"\"\n    Gets the name of the molecule\n\n    Args:\n        name (str): Name of the molecule\n\n    \"\"\"\n    self.name = name\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MolClass.add_coordinates","title":"<code>add_coordinates(at, x, y, z, nat)</code>","text":"<p>Adds all structural information to the molecule Args:     at (list): list of elements ( in order of coordinates)     x (list): list of x coordinates     y (list): list of y coordinates     z (list): list of z coordinates     nat (int): Total number of atoms</p> Source code in <code>Tools/classes.py</code> <pre><code>def add_coordinates(self, at: list, x: list, y: list, z: list, nat: int):\n    \"\"\"\n    Adds all structural information to the molecule\n    Args:\n        at (list): list of elements ( in order of coordinates)\n        x (list): list of x coordinates\n        y (list): list of y coordinates\n        z (list): list of z coordinates\n        nat (int): Total number of atoms\n\n    \"\"\"\n    assert len(x) == len(y) == len(z) == len(at) == nat, \"Coordinates are broken... x,y&amp;z coordinates are different lengths\"\n    self.element = at\n    self.x = x\n    self.y = y\n    self.z = z\n    self.nat = nat\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.MolClass.set_charge","title":"<code>set_charge(charge, spin)</code>","text":"<p>Sets the charge and spin of the molecule</p> <p>Parameters:</p> Name Type Description Default <code>charge</code> <code>int</code> <p>Net charge of the molecule (Only whole charge supported)</p> required <code>spin</code> <code>int</code> <p>Spin state of the molecule as defined by ORCA</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_charge(self, charge: int, spin: int):\n    \"\"\"\n    Sets the charge and spin of the molecule\n\n    Args:\n        charge (int): Net charge of the molecule (Only whole charge supported)\n        spin (int): Spin state of the molecule as defined by ORCA\n\n    \"\"\"\n    assert type(charge) is int, \"Charge must be an integer, partial charges are not supported\"\n    self.charge = charge\n    assert type(spin) is int, \"Spin must be an integer, partial spins are not supported\"\n    self.spin = spin\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass","title":"<code>NAMDClass</code>","text":"<p>Class for containing NAMD Variables</p> <p>Attributes:</p> Name Type Description <code>amber</code> <code>str</code> <p>Whether to use amber coordinates and parameters</p> <code>switching</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>exclude</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>scaling</code> <code>float</code> <p>NAMD Variable (refer to manual)</p> <code>scnb</code> <code>float</code> <p>NAMD Variable (refer to manual)</p> <code>readexclusions</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>watermodel</code> <code>str</code> <p>Water model to be used (TIP3P)</p> <code>pairListDist</code> <code>float</code> <p>NAMD Variable (refer to manual)</p> <code>LJcorrection</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>ZeroMomentum</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>rigidTolerance</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>rigidIterations</code> <code>int</code> <p>NAMD Variable (refer to manual)</p> <code>fullElectFrequency</code> <code>float</code> <p>NAMD Variable (refer to manual)</p> <code>nonBondedFreq</code> <code>int</code> <p>NAMD Variable (refer to manual)</p> <code>stepspercycle</code> <code>int</code> <p>NAMD Variable (refer to manual)</p> <code>PME</code> <code>str</code> <p>Toggle for PME</p> <code>PMEGridSizeX</code> <code>int</code> <p>NAMD Variable (refer to manual)</p> <code>PMEGridSizeY</code> <code>int</code> <p>NAMD Variable (refer to manual)</p> <code>PMEGridSizeZ</code> <code>int</code> <p>NAMD Variable (refer to manual)</p> <code>PMETolerance</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>PMEInterpOrder</code> <code>int</code> <p>NAMD Variable (refer to manual)</p> <code>qmForces</code> <code>str</code> <p>Whether to use QMMM</p> <code>qmLines</code> <code>str</code> <p>QM config lines</p> <code>colvarlines</code> <code>str</code> <p>Colvar config lines for SMD and Umbrella sampling</p> <code>parm</code> <code>str</code> <p>parameter file</p> <code>ambercoor</code> <code>str</code> <p>Amber coordinate file</p> <code>outfile</code> <code>str</code> <p>output filename</p> <code>dcdfreq</code> <code>int</code> <p>frequency to update trajectories</p> <code>restfreq</code> <code>int</code> <p>frequency to update restart file</p> <code>timefreq</code> <code>int</code> <p>frequency to print timing and performance information</p> <code>cutoff</code> <code>float</code> <p>non-bonded cutoff</p> <code>timestep</code> <code>float</code> <p>timestep for MD</p> <code>rigidBonds</code> <code>str</code> <p>whether to use shake</p> <code>steps</code> <code>int</code> <p>Number of steps </p> <code>BrensdenPressure</code> <code>str</code> <p>Whether to control pressure of system</p> <code>heating</code> <code>str</code> <p>Heating information</p> <code>runtype</code> <code>str</code> <p>whether dynamics or minimisation</p> <code>cellBasisVector1</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>cellBasisVector2</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>cellBasisVector3</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>cellOrigin</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>bincoor</code> <code>str</code> <p>coordinates to actully be used as start coodinates</p> <code>ambercoor</code> <code>str</code> <p>coordinates related to amber parameters (Must be in amber format)</p> <code>parm</code> <code>str</code> <p>AMBER parameter file</p> Source code in <code>Tools/classes.py</code> <pre><code>class NAMDClass:\n    \"\"\"Class for containing NAMD Variables\n\n    Attributes:\n        amber (str): Whether to use amber coordinates and parameters\n        switching (str): NAMD Variable (refer to manual)\n        exclude (str): NAMD Variable (refer to manual)\n        scaling (float): NAMD Variable (refer to manual)\n        scnb (float): NAMD Variable (refer to manual)\n        readexclusions (str): NAMD Variable (refer to manual)\n        watermodel (str): Water model to be used (TIP3P)\n        pairListDist (float): NAMD Variable (refer to manual)\n        LJcorrection (str): NAMD Variable (refer to manual)\n        ZeroMomentum (str): NAMD Variable (refer to manual)\n        rigidTolerance (str): NAMD Variable (refer to manual)\n        rigidIterations (int): NAMD Variable (refer to manual)\n        fullElectFrequency (float): NAMD Variable (refer to manual)\n        nonBondedFreq (int): NAMD Variable (refer to manual)\n        stepspercycle (int): NAMD Variable (refer to manual)\n        PME (str): Toggle for PME\n        PMEGridSizeX (int):  NAMD Variable (refer to manual)\n        PMEGridSizeY (int): NAMD Variable (refer to manual)\n        PMEGridSizeZ (int): NAMD Variable (refer to manual)\n        PMETolerance (str): NAMD Variable (refer to manual)\n        PMEInterpOrder (int): NAMD Variable (refer to manual)\n        qmForces (str): Whether to use QMMM\n        qmLines (str): QM config lines\n        colvarlines (str): Colvar config lines for SMD and Umbrella sampling\n        parm (str): parameter file\n        ambercoor (str): Amber coordinate file\n        outfile (str): output filename\n        dcdfreq (int): frequency to update trajectories\n        restfreq (int): frequency to update restart file\n        timefreq (int): frequency to print timing and performance information\n        cutoff (float): non-bonded cutoff\n        timestep (float): timestep for MD\n        rigidBonds (str): whether to use shake\n        steps (int): Number of steps \n        BrensdenPressure (str): Whether to control pressure of system\n        heating (str): Heating information\n        runtype (str): whether dynamics or minimisation\n        cellBasisVector1 (str): NAMD Variable (refer to manual)\n        cellBasisVector2 (str): NAMD Variable (refer to manual)\n        cellBasisVector3 (str): NAMD Variable (refer to manual)\n        cellOrigin (str): NAMD Variable (refer to manual)\n        bincoor (str): coordinates to actully be used as start coodinates\n        ambercoor (str): coordinates related to amber parameters (Must be in amber format)\n        parm (str): AMBER parameter file \n    \"\"\"\n    amber = MMVars[\"amber\"]\n    switching = MMVars[\"switching\"]\n    exclude = MMVars[\"exclude\"]\n    scaling = MMVars[\"1-4scaling\"]\n    scnb = MMVars[\"scnb\"]\n    readexclusions = MMVars[\"readexclusions\"]\n    watermodel = MMVars[\"watermodel\"]\n    pairListDist = MMVars[\"pairListdist\"]\n    LJcorrection = MMVars[\"LJcorrection\"]\n    ZeroMomentum = MMVars[\"ZeroMomentum\"]\n    rigidTolerance = MMVars[\"rigidTolerance\"]\n    rigidIterations = MMVars[\"rigidIterations\"]\n    fullElectFrequency = MMVars[\"fullElectFrequency\"]\n    nonBondedFreq = MMVars[\"nonBondedFreq\"]\n    stepspercycle = MMVars[\"stepspercycle\"]\n    PME = MMVars[\"PME\"]\n    PMEGridSizeX = MMVars[\"PMEGridSizeX\"]\n    PMEGridSizeY = MMVars[\"PMEGridSizeY\"]\n    PMEGridSizeZ = MMVars[\"PMEGridSizeZ\"]\n    PMETolerance = MMVars[\"PMETolerance\"]\n    PMEInterpOrder = MMVars[\"PMEInterpOrder\"]\n    qmForces = MMVars[\"qmForces\"]\n    qmLines = f\"\"\n    colvarlines = \"\"\n    def __init__(self, Calc: CalcClass, MM: MMClass,):\n        \"\"\"\n        NAMD Class initialise. Requres some MD Parameters \n        Args:\n            Calc (CalcClass): for job name\n            MM (MMClass): for MD parameters.\n\n        Raises:\n            AttributeError: if unknown ensemble is provided (either min, heat, NVT or NVP)\n\n        Attributes:\n        parm (str): parameter file\n        ambercoor (str): Amber coordinate file\n        outfile (str): output filename\n        dcdfreq (int): frequency to update trajectories\n        restfreq (int): frequency to update restart file\n        timefreq (int): frequency to print timing and performance information\n        cutoff (float): non-bonded cutoff\n        timestep (float): timestep for MD\n        rigidBonds (str): whether to use shake\n        steps (int): Number of steps \n        BrensdenPressure (str): Whether to control pressure of system\n        heating (str): Heating information\n        runtype (str): whether dynamics or minimisation\n        \"\"\"\n        self.parm = MM.parmfile\n        self.ambercoor = MM.ambercoor\n        # self.bincoor = bincoor\n        self.outfile = Calc.Name\n        self.dcdfreq = MM.TrajOut\n        self.restfreq = MM.RestOut\n        self.timefreq = MM.TimeOut\n        self.cutoff = MM.CutOff\n        self.timestep = MM.TimeStep\n        self.rigidBonds = MM.Shake\n        self.steps = MM.Steps\n        if MM.Ensemble == \"NVT\": # Formats NVT calculation\n            self.BrensdenPressure = \"off\"\n            self.heating = f\"\"\"langevin            on\nlangevinDamping     5\nlangevinTemp        {MM.Temp}\nlangevinHydrogen    off\ntemperature         {MM.Temp}\n\"\"\"\n            self.runtype = \"run\"\n        elif MM.Ensemble == \"NPT\": # Formats NPT calculation\n            self.BrensdenPressure = \"on\"\n            self.heating = f\"\"\"langevin            on\nlangevinDamping     5\nlangevinTemp        {MM.Temp}\nlangevinHydrogen    off\ntemperature         {MM.Temp}\n\"\"\"\n            self.runtype = \"run\"\n        elif \"heat\" in MM.Ensemble.casefold(): # Heat is classed as an ensemble \n            self.BrensdenPressure = \"off\"\n            self.heating = f\"\"\"temperature         0\nreassignFreq        {math.floor(MM.Steps/(MM.Temp/0.2))}\nreassignIncr        0.2\nreassignHold        {MM.Temp}\n\"\"\"\n            self.runtype = \"run\"\n        elif \"min\" in MM.Ensemble.casefold(): # Min is classed as an ensemble\n            self.BrensdenPressure = \"off\"\n            self.heating = \"\"\"temperature             0\nlangevin            off\"\"\"\n            self.runtype = \"minimize\"\n        else:\n            return AttributeError, f\"ERROR: {MM.Ensemble} not configured.\"\n    def set_pme(self, val=\"off\"):\n        \"\"\"\n        Whether to use PME\n        Args:\n            val (undefined): off or on\n        Attributes:\n            PME (str): off or on\n        \"\"\"\n        self.PME = val\n    def set_cellvectors(self, CellVector: float, CellShape=\"oct\"): ### Currently only supports truncated Octahedron cells\n        \"\"\"\n        Sorts out NAMD's cell shapes as it does not natively support octahedral.\n        Args:\n            CellVector (float): first number from the .parm7 file\n            CellShape (str, optional): Shape of cell. Only supports octahedral. Defaults to \"oct\".\n\n        TODO:\n            CellShape: Support other cell vectors\n\n        Attributes:\n            cellBasisVector1 (str): NAMD Variable (refer to manual)\n            cellBasisVector2 (str): NAMD Variable (refer to manual)\n            cellBasisVector3 (str): NAMD Variable (refer to manual)\n            cellOrigin (str): NAMD Variable (refer to manual)\n\n        Raises:\n            AttributeError: If any unit cell provided that is not curently supported (Only Oct at the moment.)\n        \"\"\"\n        if CellShape.casefold() == \"oct\":\n            self.cellBasisVector1 = f\"{CellVector} 0.0 0.0\"\n            self.cellBasisVector2 = f\"{(-1/3)*CellVector} {(2/3)*np.sqrt(2)*CellVector} 0.0\"\n            self.cellBasisVector3 = f\"{(-1/3)*CellVector} {(-1/3)*np.sqrt(2)*CellVector} {(-1/3)*np.sqrt(6)*CellVector}\"\n            self.cellOrigin = \"0 0 0\"\n        else:\n            return AttributeError, \"Cell shape not supported currently, please add this functionality.\"\n    def set_qm(self, Calc: CalcClass, QM: QMClass, index=0):\n        \"\"\"\n        Initialises the QM section of the NAMD input file. \n\n        Args:\n            Calc (CalcClass): Required for number of cores\n            QM (QMClass): Contains QM information\n            index (int): For umbrella sampling. \n\n        Attributes:\n            qmForces (str): Toggles QMMM\n            qmLines (str): Variables required for QMMM\n        \"\"\"\n        if Calc.QM == \"False\":\n            self.qmForces = \"off\"\n            self.qmLines = f\"\"\n        else:\n            self.qmForces = \"on\"\n#             self.qmLines = f\"\"\"\n# qmParamPDB              \"../syst-qm.pdb\"\n# qmColumn                \"beta\"\n# qmBondColumn            \"occ\"\n# QMsimsPerNode           1\n# QMElecEmbed             on\n# QMSwitching             on\n# QMSwitchingType         shift\n# QMPointChargeScheme     round\n# QMBondScheme            \"cs\"\n# qmBaseDir               \"/dev/shm/NAMD_{index}\"\n# qmConfigLine            \"! {QM.Method} {QM.Basis} EnGrad {QM.QMExtra}\"\n# qmConfigLine            \"%%output PrintLevel Mini Print\\[ P_Mulliken \\] 1 Print\\[P_AtCharges_M\\] 1 end\"\n# qmConfigLine            \"%PAL NPROCS {Calc.Threads} END\"\n# qmMult                  \"1 {QM.Spin}\"\n# qmCharge                \"1 {QM.Charge}\"\n# qmSoftware              \"orca\"\n# qmExecPath              \"{QM.QMpath}\"\n# QMOutStride             1\n# qmEnergyStride          1\n# QMPositionOutStride     1\n#\n# \"\"\"\n            self.qmLines = f\"\"\"\n            qmParamPDB              \"{QM.SelFile}\"\n            qmColumn                \"beta\"\n            qmBondColumn            \"occ\"\n            QMsimsPerNode           1\n            QMElecEmbed             on\n            QMSwitching             on\n            QMSwitchingType         shift\n            QMPointChargeScheme     round\n            QMBondScheme            \"cs\"\n            qmBaseDir               \"/dev/shm/RUNDIR_{index}\"\n            qmConfigLine            \"! {QM.Method} {QM.Basis} EnGrad {QM.QMExtra}\"\n            qmConfigLine            \"%%output PrintLevel Mini Print\\[ P_Mulliken \\] 1 Print\\[P_AtCharges_M\\] 1 end\"\n            qmConfigLine            \"%PAL NPROCS {Calc.Threads} END\"\n            qmMult                  \"1 {QM.Spin}\"\n            qmCharge                \"1 {QM.Charge}\"\n            qmSoftware              \"orca\"\n            qmExecPath              \"{QM.QMpath}\"\n            QMOutStride             1\n            qmEnergyStride          1\n            QMPositionOutStride     1\n\n            \"\"\"\n    def set_colvars(self, file: str, toggle=\"on\"):\n        \"\"\"\n        Sorts out collective variables for SMD and Umbrella Sampling\n\n        Args:\n            file (str): filename and location of the colvars config file.\n            toggle (str): on or off depending on whether used. \n\n        Attributes:\n            colvarlines (str): Config lines for colvars.\n        \"\"\"\n        self.colvarlines = f\"\"\"# Colvar options:\ncolvars         {toggle}\ncolvarsConfig   {file}\n\"\"\"\n    def set_startcoords(self, bincoor:str, ambercoor:str =\"../start.rst7\", parm:str =f\"../{globals.parmfile}\"):\n        \"\"\"\n        Controls the coordinate files\n        Args:\n            bincoor (str): coordinates to actully be used as start coodinates\n            ambercoor (str): coordinates related to amber parameters (Must be in amber format)\n            parm (str): AMBER parameter file \n\n        \"\"\"\n        self.bincoor = bincoor\n        self.ambercoor = ambercoor\n        self.parm = parm\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.BrensdenPressure","title":"<code>BrensdenPressure = 'off'</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.LJcorrection","title":"<code>LJcorrection = MMVars['LJcorrection']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.PME","title":"<code>PME = MMVars['PME']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.PMEGridSizeX","title":"<code>PMEGridSizeX = MMVars['PMEGridSizeX']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.PMEGridSizeY","title":"<code>PMEGridSizeY = MMVars['PMEGridSizeY']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.PMEGridSizeZ","title":"<code>PMEGridSizeZ = MMVars['PMEGridSizeZ']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.PMEInterpOrder","title":"<code>PMEInterpOrder = MMVars['PMEInterpOrder']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.PMETolerance","title":"<code>PMETolerance = MMVars['PMETolerance']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.ZeroMomentum","title":"<code>ZeroMomentum = MMVars['ZeroMomentum']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.amber","title":"<code>amber = MMVars['amber']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.ambercoor","title":"<code>ambercoor = MM.ambercoor</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.colvarlines","title":"<code>colvarlines = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.cutoff","title":"<code>cutoff = MM.CutOff</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.dcdfreq","title":"<code>dcdfreq = MM.TrajOut</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.exclude","title":"<code>exclude = MMVars['exclude']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.fullElectFrequency","title":"<code>fullElectFrequency = MMVars['fullElectFrequency']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.heating","title":"<code>heating = f'langevin            onlangevinDamping 5langevinTemp {MM.Temp}langevinHydrogen offtemperature {MM.Temp}'</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.nonBondedFreq","title":"<code>nonBondedFreq = MMVars['nonBondedFreq']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.outfile","title":"<code>outfile = Calc.Name</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.pairListDist","title":"<code>pairListDist = MMVars['pairListdist']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.parm","title":"<code>parm = MM.parmfile</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.qmForces","title":"<code>qmForces = MMVars['qmForces']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.qmLines","title":"<code>qmLines = f''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.readexclusions","title":"<code>readexclusions = MMVars['readexclusions']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.restfreq","title":"<code>restfreq = MM.RestOut</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.rigidBonds","title":"<code>rigidBonds = MM.Shake</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.rigidIterations","title":"<code>rigidIterations = MMVars['rigidIterations']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.rigidTolerance","title":"<code>rigidTolerance = MMVars['rigidTolerance']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.runtype","title":"<code>runtype = 'run'</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.scaling","title":"<code>scaling = MMVars['1-4scaling']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.scnb","title":"<code>scnb = MMVars['scnb']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.steps","title":"<code>steps = MM.Steps</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.stepspercycle","title":"<code>stepspercycle = MMVars['stepspercycle']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.switching","title":"<code>switching = MMVars['switching']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.timefreq","title":"<code>timefreq = MM.TimeOut</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.timestep","title":"<code>timestep = MM.TimeStep</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.watermodel","title":"<code>watermodel = MMVars['watermodel']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.__init__","title":"<code>__init__(Calc, MM)</code>","text":"<p>NAMD Class initialise. Requres some MD Parameters  Args:     Calc (CalcClass): for job name     MM (MMClass): for MD parameters.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>if unknown ensemble is provided (either min, heat, NVT or NVP)</p> <p>Attributes: parm (str): parameter file ambercoor (str): Amber coordinate file outfile (str): output filename dcdfreq (int): frequency to update trajectories restfreq (int): frequency to update restart file timefreq (int): frequency to print timing and performance information cutoff (float): non-bonded cutoff timestep (float): timestep for MD rigidBonds (str): whether to use shake steps (int): Number of steps  BrensdenPressure (str): Whether to control pressure of system heating (str): Heating information runtype (str): whether dynamics or minimisation</p> Source code in <code>Tools/classes.py</code> <pre><code>    def __init__(self, Calc: CalcClass, MM: MMClass,):\n        \"\"\"\n        NAMD Class initialise. Requres some MD Parameters \n        Args:\n            Calc (CalcClass): for job name\n            MM (MMClass): for MD parameters.\n\n        Raises:\n            AttributeError: if unknown ensemble is provided (either min, heat, NVT or NVP)\n\n        Attributes:\n        parm (str): parameter file\n        ambercoor (str): Amber coordinate file\n        outfile (str): output filename\n        dcdfreq (int): frequency to update trajectories\n        restfreq (int): frequency to update restart file\n        timefreq (int): frequency to print timing and performance information\n        cutoff (float): non-bonded cutoff\n        timestep (float): timestep for MD\n        rigidBonds (str): whether to use shake\n        steps (int): Number of steps \n        BrensdenPressure (str): Whether to control pressure of system\n        heating (str): Heating information\n        runtype (str): whether dynamics or minimisation\n        \"\"\"\n        self.parm = MM.parmfile\n        self.ambercoor = MM.ambercoor\n        # self.bincoor = bincoor\n        self.outfile = Calc.Name\n        self.dcdfreq = MM.TrajOut\n        self.restfreq = MM.RestOut\n        self.timefreq = MM.TimeOut\n        self.cutoff = MM.CutOff\n        self.timestep = MM.TimeStep\n        self.rigidBonds = MM.Shake\n        self.steps = MM.Steps\n        if MM.Ensemble == \"NVT\": # Formats NVT calculation\n            self.BrensdenPressure = \"off\"\n            self.heating = f\"\"\"langevin            on\nlangevinDamping     5\nlangevinTemp        {MM.Temp}\nlangevinHydrogen    off\ntemperature         {MM.Temp}\n\"\"\"\n            self.runtype = \"run\"\n        elif MM.Ensemble == \"NPT\": # Formats NPT calculation\n            self.BrensdenPressure = \"on\"\n            self.heating = f\"\"\"langevin            on\nlangevinDamping     5\nlangevinTemp        {MM.Temp}\nlangevinHydrogen    off\ntemperature         {MM.Temp}\n\"\"\"\n            self.runtype = \"run\"\n        elif \"heat\" in MM.Ensemble.casefold(): # Heat is classed as an ensemble \n            self.BrensdenPressure = \"off\"\n            self.heating = f\"\"\"temperature         0\nreassignFreq        {math.floor(MM.Steps/(MM.Temp/0.2))}\nreassignIncr        0.2\nreassignHold        {MM.Temp}\n\"\"\"\n            self.runtype = \"run\"\n        elif \"min\" in MM.Ensemble.casefold(): # Min is classed as an ensemble\n            self.BrensdenPressure = \"off\"\n            self.heating = \"\"\"temperature             0\nlangevin            off\"\"\"\n            self.runtype = \"minimize\"\n        else:\n            return AttributeError, f\"ERROR: {MM.Ensemble} not configured.\"\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.set_cellvectors","title":"<code>set_cellvectors(CellVector, CellShape='oct')</code>","text":"<p>Sorts out NAMD's cell shapes as it does not natively support octahedral. Args:     CellVector (float): first number from the .parm7 file     CellShape (str, optional): Shape of cell. Only supports octahedral. Defaults to \"oct\".</p> TODO <p>CellShape: Support other cell vectors</p> <p>Attributes:</p> Name Type Description <code>cellBasisVector1</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>cellBasisVector2</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>cellBasisVector3</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <code>cellOrigin</code> <code>str</code> <p>NAMD Variable (refer to manual)</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If any unit cell provided that is not curently supported (Only Oct at the moment.)</p> Source code in <code>Tools/classes.py</code> <pre><code>def set_cellvectors(self, CellVector: float, CellShape=\"oct\"): ### Currently only supports truncated Octahedron cells\n    \"\"\"\n    Sorts out NAMD's cell shapes as it does not natively support octahedral.\n    Args:\n        CellVector (float): first number from the .parm7 file\n        CellShape (str, optional): Shape of cell. Only supports octahedral. Defaults to \"oct\".\n\n    TODO:\n        CellShape: Support other cell vectors\n\n    Attributes:\n        cellBasisVector1 (str): NAMD Variable (refer to manual)\n        cellBasisVector2 (str): NAMD Variable (refer to manual)\n        cellBasisVector3 (str): NAMD Variable (refer to manual)\n        cellOrigin (str): NAMD Variable (refer to manual)\n\n    Raises:\n        AttributeError: If any unit cell provided that is not curently supported (Only Oct at the moment.)\n    \"\"\"\n    if CellShape.casefold() == \"oct\":\n        self.cellBasisVector1 = f\"{CellVector} 0.0 0.0\"\n        self.cellBasisVector2 = f\"{(-1/3)*CellVector} {(2/3)*np.sqrt(2)*CellVector} 0.0\"\n        self.cellBasisVector3 = f\"{(-1/3)*CellVector} {(-1/3)*np.sqrt(2)*CellVector} {(-1/3)*np.sqrt(6)*CellVector}\"\n        self.cellOrigin = \"0 0 0\"\n    else:\n        return AttributeError, \"Cell shape not supported currently, please add this functionality.\"\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.set_colvars","title":"<code>set_colvars(file, toggle='on')</code>","text":"<p>Sorts out collective variables for SMD and Umbrella Sampling</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>filename and location of the colvars config file.</p> required <code>toggle</code> <code>str</code> <p>on or off depending on whether used. </p> <code>'on'</code> <p>Attributes:</p> Name Type Description <code>colvarlines</code> <code>str</code> <p>Config lines for colvars.</p> Source code in <code>Tools/classes.py</code> <pre><code>    def set_colvars(self, file: str, toggle=\"on\"):\n        \"\"\"\n        Sorts out collective variables for SMD and Umbrella Sampling\n\n        Args:\n            file (str): filename and location of the colvars config file.\n            toggle (str): on or off depending on whether used. \n\n        Attributes:\n            colvarlines (str): Config lines for colvars.\n        \"\"\"\n        self.colvarlines = f\"\"\"# Colvar options:\ncolvars         {toggle}\ncolvarsConfig   {file}\n\"\"\"\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.set_pme","title":"<code>set_pme(val='off')</code>","text":"<p>Whether to use PME Args:     val (undefined): off or on Attributes:     PME (str): off or on</p> Source code in <code>Tools/classes.py</code> <pre><code>def set_pme(self, val=\"off\"):\n    \"\"\"\n    Whether to use PME\n    Args:\n        val (undefined): off or on\n    Attributes:\n        PME (str): off or on\n    \"\"\"\n    self.PME = val\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.set_qm","title":"<code>set_qm(Calc, QM, index=0)</code>","text":"<p>Initialises the QM section of the NAMD input file. </p> <p>Parameters:</p> Name Type Description Default <code>Calc</code> <code>CalcClass</code> <p>Required for number of cores</p> required <code>QM</code> <code>QMClass</code> <p>Contains QM information</p> required <code>index</code> <code>int</code> <p>For umbrella sampling. </p> <code>0</code> <p>Attributes:</p> Name Type Description <code>qmForces</code> <code>str</code> <p>Toggles QMMM</p> <code>qmLines</code> <code>str</code> <p>Variables required for QMMM</p> Source code in <code>Tools/classes.py</code> <pre><code>    def set_qm(self, Calc: CalcClass, QM: QMClass, index=0):\n        \"\"\"\n        Initialises the QM section of the NAMD input file. \n\n        Args:\n            Calc (CalcClass): Required for number of cores\n            QM (QMClass): Contains QM information\n            index (int): For umbrella sampling. \n\n        Attributes:\n            qmForces (str): Toggles QMMM\n            qmLines (str): Variables required for QMMM\n        \"\"\"\n        if Calc.QM == \"False\":\n            self.qmForces = \"off\"\n            self.qmLines = f\"\"\n        else:\n            self.qmForces = \"on\"\n#             self.qmLines = f\"\"\"\n# qmParamPDB              \"../syst-qm.pdb\"\n# qmColumn                \"beta\"\n# qmBondColumn            \"occ\"\n# QMsimsPerNode           1\n# QMElecEmbed             on\n# QMSwitching             on\n# QMSwitchingType         shift\n# QMPointChargeScheme     round\n# QMBondScheme            \"cs\"\n# qmBaseDir               \"/dev/shm/NAMD_{index}\"\n# qmConfigLine            \"! {QM.Method} {QM.Basis} EnGrad {QM.QMExtra}\"\n# qmConfigLine            \"%%output PrintLevel Mini Print\\[ P_Mulliken \\] 1 Print\\[P_AtCharges_M\\] 1 end\"\n# qmConfigLine            \"%PAL NPROCS {Calc.Threads} END\"\n# qmMult                  \"1 {QM.Spin}\"\n# qmCharge                \"1 {QM.Charge}\"\n# qmSoftware              \"orca\"\n# qmExecPath              \"{QM.QMpath}\"\n# QMOutStride             1\n# qmEnergyStride          1\n# QMPositionOutStride     1\n#\n# \"\"\"\n            self.qmLines = f\"\"\"\n            qmParamPDB              \"{QM.SelFile}\"\n            qmColumn                \"beta\"\n            qmBondColumn            \"occ\"\n            QMsimsPerNode           1\n            QMElecEmbed             on\n            QMSwitching             on\n            QMSwitchingType         shift\n            QMPointChargeScheme     round\n            QMBondScheme            \"cs\"\n            qmBaseDir               \"/dev/shm/RUNDIR_{index}\"\n            qmConfigLine            \"! {QM.Method} {QM.Basis} EnGrad {QM.QMExtra}\"\n            qmConfigLine            \"%%output PrintLevel Mini Print\\[ P_Mulliken \\] 1 Print\\[P_AtCharges_M\\] 1 end\"\n            qmConfigLine            \"%PAL NPROCS {Calc.Threads} END\"\n            qmMult                  \"1 {QM.Spin}\"\n            qmCharge                \"1 {QM.Charge}\"\n            qmSoftware              \"orca\"\n            qmExecPath              \"{QM.QMpath}\"\n            QMOutStride             1\n            qmEnergyStride          1\n            QMPositionOutStride     1\n\n            \"\"\"\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.NAMDClass.set_startcoords","title":"<code>set_startcoords(bincoor, ambercoor='../start.rst7', parm=f'../{globals.parmfile}')</code>","text":"<p>Controls the coordinate files Args:     bincoor (str): coordinates to actully be used as start coodinates     ambercoor (str): coordinates related to amber parameters (Must be in amber format)     parm (str): AMBER parameter file</p> Source code in <code>Tools/classes.py</code> <pre><code>def set_startcoords(self, bincoor:str, ambercoor:str =\"../start.rst7\", parm:str =f\"../{globals.parmfile}\"):\n    \"\"\"\n    Controls the coordinate files\n    Args:\n        bincoor (str): coordinates to actully be used as start coodinates\n        ambercoor (str): coordinates related to amber parameters (Must be in amber format)\n        parm (str): AMBER parameter file \n\n    \"\"\"\n    self.bincoor = bincoor\n    self.ambercoor = ambercoor\n    self.parm = parm\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass","title":"<code>ORCAClass</code>","text":"<p>Class for ORCA input information</p> <p>Attributes:</p> Name Type Description <code>dispersion</code> <code>str</code> <p>Any dispersion correction supported by ORCA</p> <code>restart</code> <code>str</code> <p>Whether to start from the .gbw restart file with ORCA</p> <code>path</code> <code>str</code> <p>path to the executable</p> <code>method</code> <code>str</code> <p>(DFT functional, or CCSD or HF)</p> <code>basis</code> <code>str</code> <p>Any basis set supported by ORCA</p> <code>cores</code> <code>int</code> <p>Number of CPU cores to use.</p> <code>convergence</code> <code>str</code> <p>Convergence threshold Threshold</p> <code>grid</code> <code>str</code> <p>ORCA grid size</p> <code>dificulty</code> <code>str</code> <p>NormalConv should work for most jobs. </p> <code>calculation</code> <code>str</code> <p>QM claculation type. </p> <code>extras</code> <code>str</code> <p>Any other commands to parse to the ORCA input.</p> Source code in <code>Tools/classes.py</code> <pre><code>class ORCAClass:\n    \"\"\"Class for ORCA input information\n\n    Attributes:\n        dispersion (str): Any dispersion correction supported by ORCA\n        restart (str): Whether to start from the .gbw restart file with ORCA\n        path (str): path to the executable\n        method (str): (DFT functional, or CCSD or HF)\n        basis (str): Any basis set supported by ORCA\n        cores (int): Number of CPU cores to use.\n        convergence (str): Convergence threshold Threshold\n        grid (str): ORCA grid size\n        dificulty (str): NormalConv should work for most jobs. \n        calculation (str): QM claculation type. \n        extras (str): Any other commands to parse to the ORCA input.\n    \"\"\"\n    dispersion = \"\"\n    restart = \"NOAUTOSTART\"\n    def __init__(self, path:str):\n        \"\"\"\n        Sets the path to ORCA\n        Args:\n            path (str): path to the executable\n\n        \"\"\"\n        self.path = path\n    def set_method(self, method:str):\n        \"\"\"\n        sets the ORCA QM method (DFT functional, or CCSD or HF)\n\n        Args:\n            method (str): (DFT functional, or CCSD or HF)\n\n        \"\"\"\n        self.method = method\n    def set_basis(self, basis:str):\n        \"\"\"\n        Sets the basis set to be used\n\n        Args:\n            basis (str): Any basis set supported by ORCA\n\n        \"\"\"\n        self.basis = basis\n    def set_dispersion(self, disp: str):\n        \"\"\"\n        Sets the dispersion correction\n\n        Args:\n            disp (str): Any dispersion correction supported by ORCA\n\n        \"\"\"\n        self.dispersion = disp\n    def set_cores(self, cores: int):\n        \"\"\"\n        Sorts out parallel calculations in ORCA\n\n        Args:\n            cores (int): Number of CPU cores to use.\n\n        \"\"\"\n        self.cores = cores\n    def set_convergence(self, conv: str):\n        \"\"\"Set the Convergence threshold\n\n        Args:\n            conv (str): Threshold\n        \"\"\"\n        self.convergence = conv\n    def change_autostart(self, restart: str):\n        \"\"\"Whether to use .gbw restart files\n\n        Args:\n            restart (str): AUTOSTART or NOAUTOSTART\n\n        \"\"\"\n        self.restart = restart\n    def set_grid(self, grid: str):\n        \"\"\"SCF grid to use\n\n        Args:\n            grid (str): ORCA grid size\n\n        \"\"\"\n        self.grid = grid\n    def set_dificulty(self, diff:str):\n        \"\"\"Sets how aggressive the SCF algorithm should be. \n\n        Args:\n            diff (str): NormalConv should work for most jobs. \n\n        \"\"\"\n        self.dificulty = diff\n    def set_type(self, caltype:str):\n        \"\"\"QM calculation type (SP, opt, force ect. )\n\n        Args:\n            caltype (str): QM claculation type. \n\n        \"\"\"\n        self.calculation = caltype\n    def set_extras(self, extras:str):\n        \"\"\"Any other things to parse to ORCA\n\n        Args:\n            extras (str): Any other commands to parse to the ORCA input.\n\n        \"\"\"\n        self.extras = extras\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.dispersion","title":"<code>dispersion = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.path","title":"<code>path = path</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.restart","title":"<code>restart = 'NOAUTOSTART'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.__init__","title":"<code>__init__(path)</code>","text":"<p>Sets the path to ORCA Args:     path (str): path to the executable</p> Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, path:str):\n    \"\"\"\n    Sets the path to ORCA\n    Args:\n        path (str): path to the executable\n\n    \"\"\"\n    self.path = path\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.change_autostart","title":"<code>change_autostart(restart)</code>","text":"<p>Whether to use .gbw restart files</p> <p>Parameters:</p> Name Type Description Default <code>restart</code> <code>str</code> <p>AUTOSTART or NOAUTOSTART</p> required Source code in <code>Tools/classes.py</code> <pre><code>def change_autostart(self, restart: str):\n    \"\"\"Whether to use .gbw restart files\n\n    Args:\n        restart (str): AUTOSTART or NOAUTOSTART\n\n    \"\"\"\n    self.restart = restart\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.set_basis","title":"<code>set_basis(basis)</code>","text":"<p>Sets the basis set to be used</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>str</code> <p>Any basis set supported by ORCA</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_basis(self, basis:str):\n    \"\"\"\n    Sets the basis set to be used\n\n    Args:\n        basis (str): Any basis set supported by ORCA\n\n    \"\"\"\n    self.basis = basis\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.set_convergence","title":"<code>set_convergence(conv)</code>","text":"<p>Set the Convergence threshold</p> <p>Parameters:</p> Name Type Description Default <code>conv</code> <code>str</code> <p>Threshold</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_convergence(self, conv: str):\n    \"\"\"Set the Convergence threshold\n\n    Args:\n        conv (str): Threshold\n    \"\"\"\n    self.convergence = conv\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.set_cores","title":"<code>set_cores(cores)</code>","text":"<p>Sorts out parallel calculations in ORCA</p> <p>Parameters:</p> Name Type Description Default <code>cores</code> <code>int</code> <p>Number of CPU cores to use.</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_cores(self, cores: int):\n    \"\"\"\n    Sorts out parallel calculations in ORCA\n\n    Args:\n        cores (int): Number of CPU cores to use.\n\n    \"\"\"\n    self.cores = cores\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.set_dificulty","title":"<code>set_dificulty(diff)</code>","text":"<p>Sets how aggressive the SCF algorithm should be. </p> <p>Parameters:</p> Name Type Description Default <code>diff</code> <code>str</code> <p>NormalConv should work for most jobs.</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_dificulty(self, diff:str):\n    \"\"\"Sets how aggressive the SCF algorithm should be. \n\n    Args:\n        diff (str): NormalConv should work for most jobs. \n\n    \"\"\"\n    self.dificulty = diff\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.set_dispersion","title":"<code>set_dispersion(disp)</code>","text":"<p>Sets the dispersion correction</p> <p>Parameters:</p> Name Type Description Default <code>disp</code> <code>str</code> <p>Any dispersion correction supported by ORCA</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_dispersion(self, disp: str):\n    \"\"\"\n    Sets the dispersion correction\n\n    Args:\n        disp (str): Any dispersion correction supported by ORCA\n\n    \"\"\"\n    self.dispersion = disp\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.set_extras","title":"<code>set_extras(extras)</code>","text":"<p>Any other things to parse to ORCA</p> <p>Parameters:</p> Name Type Description Default <code>extras</code> <code>str</code> <p>Any other commands to parse to the ORCA input.</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_extras(self, extras:str):\n    \"\"\"Any other things to parse to ORCA\n\n    Args:\n        extras (str): Any other commands to parse to the ORCA input.\n\n    \"\"\"\n    self.extras = extras\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.set_grid","title":"<code>set_grid(grid)</code>","text":"<p>SCF grid to use</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>str</code> <p>ORCA grid size</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_grid(self, grid: str):\n    \"\"\"SCF grid to use\n\n    Args:\n        grid (str): ORCA grid size\n\n    \"\"\"\n    self.grid = grid\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.set_method","title":"<code>set_method(method)</code>","text":"<p>sets the ORCA QM method (DFT functional, or CCSD or HF)</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>(DFT functional, or CCSD or HF)</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_method(self, method:str):\n    \"\"\"\n    sets the ORCA QM method (DFT functional, or CCSD or HF)\n\n    Args:\n        method (str): (DFT functional, or CCSD or HF)\n\n    \"\"\"\n    self.method = method\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ORCAClass.set_type","title":"<code>set_type(caltype)</code>","text":"<p>QM calculation type (SP, opt, force ect. )</p> <p>Parameters:</p> Name Type Description Default <code>caltype</code> <code>str</code> <p>QM claculation type.</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_type(self, caltype:str):\n    \"\"\"QM calculation type (SP, opt, force ect. )\n\n    Args:\n        caltype (str): QM claculation type. \n\n    \"\"\"\n    self.calculation = caltype\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass","title":"<code>QMCalcClass</code>","text":"<p>QM ORCA class for running standalone QM calculations in benchmarking, and containing its energies</p> <p>Attributes:</p> Name Type Description <code>SCFEnergy</code> <code>float</code> <p>ORCA SCF energy</p> <code>vdw</code> <code>float</code> <p>ORCA VdW energy</p> <code>TotalEnergy</code> <code>float</code> <p>ORCA Total energy</p> <code>molecule</code> <code>str</code> <p>Name of molecule</p> <code>method</code> <code>str</code> <p>QM Method</p> <code>basis</code> <code>str</code> <p>QM basis set</p> <code>dispersion</code> <code>str</code> <p>QM dispersion correction</p> <code>path</code> <code>str</code> <p>Path to the calculation</p> <code>time</code> <code>float</code> <p>Sets total calculation time</p> <code>reason</code> <code>str</code> <p>Reason for failed calculation</p> <code>runline</code> <code>str</code> <p>Line containing command to run the calculation.</p> Source code in <code>Tools/classes.py</code> <pre><code>class QMCalcClass:\n    \"\"\"QM ORCA class for running standalone QM calculations in benchmarking, and containing its energies\n\n    Attributes:\n        SCFEnergy (float): ORCA SCF energy\n        vdw (float): ORCA VdW energy\n        TotalEnergy (float): ORCA Total energy\n        molecule (str): Name of molecule\n        method (str): QM Method\n        basis (str): QM basis set\n        dispersion (str): QM dispersion correction\n        path (str): Path to the calculation\n        time (float): Sets total calculation time\n        reason (str): Reason for failed calculation\n        runline (str): Line containing command to run the calculation.\n    \"\"\"\n    SCFEnergy = 0\n    vdw = 0\n    TotalEnergy = 0\n    def __init__(self, molecule: str, method: str, basis: str, dispersion: str):\n        \"\"\"Initialises a calculation\n\n        Args:\n            molecule (str): Name of molecule\n            method (str): QM Method\n            basis (str): QM basis set\n            dispersion (str): QM dispersion correction\n\n        \"\"\"\n        self.molecule = molecule\n        self.functional = method\n        self.basis = basis\n        self.dispersion = dispersion\n    def set_path(self, path: str): \n        \"\"\"Path to the actual calculation\n\n        Args:\n            path (str): Path to the calculation\n        \"\"\"\n        self.path = path\n    def set_time(self, time:float):\n        \"\"\"Sets Calculation time\n\n        Args:\n            time (float): Sets total calculation time\n        \"\"\"\n        self.time = time\n    def set_scfenergy(self, scfenergy: float):\n        \"\"\"Gets the ORCA SCF energy\n\n        Args:\n            scfenergy (float): ORCA SCF energy\n        \"\"\"\n        self.SCFEnergy = scfenergy\n    def set_vdw(self, vdwenergy: float):\n        \"\"\"ORCA VdW energy\n\n        Args:\n            vdwenergy (str): ORCA VdW Energy\n        \"\"\"\n        self.vdw = vdwenergy\n    def set_TotalEnergy(self, totenergy:float):\n        \"\"\"Sets Total energy of calculation\n\n        Args:\n            totenergy (float): ORCA total energy calculation\n        \"\"\"\n        self.TotalEnergy = totenergy\n    def set_reason(self, reason:str):\n        \"\"\"Gets the reason for calculation failure\n\n        Args:\n            reason (str): Reason for failed calculation\n\n        \"\"\"\n        self.reason = reason\n    def set_runline(self, line: str):\n        \"\"\"Line that runs the calculation\n\n        Args:\n            line (str): Line containing command to run the calculation.\n\n        \"\"\"\n        self.runline = line\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.SCFEnergy","title":"<code>SCFEnergy = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.TotalEnergy","title":"<code>TotalEnergy = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.basis","title":"<code>basis = basis</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.dispersion","title":"<code>dispersion = dispersion</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.functional","title":"<code>functional = method</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.molecule","title":"<code>molecule = molecule</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.vdw","title":"<code>vdw = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.__init__","title":"<code>__init__(molecule, method, basis, dispersion)</code>","text":"<p>Initialises a calculation</p> <p>Parameters:</p> Name Type Description Default <code>molecule</code> <code>str</code> <p>Name of molecule</p> required <code>method</code> <code>str</code> <p>QM Method</p> required <code>basis</code> <code>str</code> <p>QM basis set</p> required <code>dispersion</code> <code>str</code> <p>QM dispersion correction</p> required Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, molecule: str, method: str, basis: str, dispersion: str):\n    \"\"\"Initialises a calculation\n\n    Args:\n        molecule (str): Name of molecule\n        method (str): QM Method\n        basis (str): QM basis set\n        dispersion (str): QM dispersion correction\n\n    \"\"\"\n    self.molecule = molecule\n    self.functional = method\n    self.basis = basis\n    self.dispersion = dispersion\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.set_TotalEnergy","title":"<code>set_TotalEnergy(totenergy)</code>","text":"<p>Sets Total energy of calculation</p> <p>Parameters:</p> Name Type Description Default <code>totenergy</code> <code>float</code> <p>ORCA total energy calculation</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_TotalEnergy(self, totenergy:float):\n    \"\"\"Sets Total energy of calculation\n\n    Args:\n        totenergy (float): ORCA total energy calculation\n    \"\"\"\n    self.TotalEnergy = totenergy\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.set_path","title":"<code>set_path(path)</code>","text":"<p>Path to the actual calculation</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the calculation</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_path(self, path: str): \n    \"\"\"Path to the actual calculation\n\n    Args:\n        path (str): Path to the calculation\n    \"\"\"\n    self.path = path\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.set_reason","title":"<code>set_reason(reason)</code>","text":"<p>Gets the reason for calculation failure</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>Reason for failed calculation</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_reason(self, reason:str):\n    \"\"\"Gets the reason for calculation failure\n\n    Args:\n        reason (str): Reason for failed calculation\n\n    \"\"\"\n    self.reason = reason\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.set_runline","title":"<code>set_runline(line)</code>","text":"<p>Line that runs the calculation</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>Line containing command to run the calculation.</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_runline(self, line: str):\n    \"\"\"Line that runs the calculation\n\n    Args:\n        line (str): Line containing command to run the calculation.\n\n    \"\"\"\n    self.runline = line\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.set_scfenergy","title":"<code>set_scfenergy(scfenergy)</code>","text":"<p>Gets the ORCA SCF energy</p> <p>Parameters:</p> Name Type Description Default <code>scfenergy</code> <code>float</code> <p>ORCA SCF energy</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_scfenergy(self, scfenergy: float):\n    \"\"\"Gets the ORCA SCF energy\n\n    Args:\n        scfenergy (float): ORCA SCF energy\n    \"\"\"\n    self.SCFEnergy = scfenergy\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.set_time","title":"<code>set_time(time)</code>","text":"<p>Sets Calculation time</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Sets total calculation time</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_time(self, time:float):\n    \"\"\"Sets Calculation time\n\n    Args:\n        time (float): Sets total calculation time\n    \"\"\"\n    self.time = time\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMCalcClass.set_vdw","title":"<code>set_vdw(vdwenergy)</code>","text":"<p>ORCA VdW energy</p> <p>Parameters:</p> Name Type Description Default <code>vdwenergy</code> <code>str</code> <p>ORCA VdW Energy</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_vdw(self, vdwenergy: float):\n    \"\"\"ORCA VdW energy\n\n    Args:\n        vdwenergy (str): ORCA VdW Energy\n    \"\"\"\n    self.vdw = vdwenergy\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMClass","title":"<code>QMClass</code>","text":"<p>Class containing QM information  Attributes:     SelFile (str): PDB file containing QM-Zone infrmation, (Should be generated by vmd)     QMpath (str): Path to the QM executable     QMSel (str): string containing vmd selection algebra of qm zone     Charge (int): Net charge of QM zone     Spin (int): Total spin of QM zone     Method (str): QM method supported by ORCA     Basis (str): QM basis set supported by ORCA     QMExtra (str): Any extra commands to provide to ORCA     SelFile (str): Selection file</p> Source code in <code>Tools/classes.py</code> <pre><code>class QMClass:\n    \"\"\" Class containing QM information \n    Attributes:\n        SelFile (str): PDB file containing QM-Zone infrmation, (Should be generated by vmd)\n        QMpath (str): Path to the QM executable\n        QMSel (str): string containing vmd selection algebra of qm zone\n        Charge (int): Net charge of QM zone\n        Spin (int): Total spin of QM zone\n        Method (str): QM method supported by ORCA\n        Basis (str): QM basis set supported by ORCA\n        QMExtra (str): Any extra commands to provide to ORCA\n        SelFile (str): Selection file\n    \"\"\"\n    SelFile=\"../syst-qm.pdb\"\n    def __init__(self, args: dict):\n        \"\"\"\n        QM Class init.\n\n        Args:\n            args (Namespace): ArgParse formatted user inputs.\n\n        Attributes:\n            QMpath (str): Path to the QM executable\n            QMSel (str): string containing vmd selection algebra of qm zone\n            Charge (int): Net charge of QM zone\n            Spin (int): Total spin of QM zone\n            Method (str): QM method supported by ORCA\n            Basis (str): QM basis set supported by ORCA\n            QMExtra (str): Any extra commands to provide to ORCA\n        \"\"\"\n        self.QMpath = args[\"QmPath\"]\n        self.QMSel = args[\"QmSelection\"]\n        self.Charge = args[\"QmCharge\"]\n        self.Spin = args[\"QmSpin\"]\n        self.Method = args[\"QmMethod\"]\n        self.Basis = args[\"QmBasis\"]\n        self.QMExtra = args[\"QmArgs\"]\n    def set_selfile(self, File: str):\n        \"\"\"\n        Sets the selection file\n\n        Args:\n            File (str): Name of file\n\n        Attribute:\n            SelFile (str): Selection file\n        \"\"\"\n        self.SelFile = File\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMClass.Basis","title":"<code>Basis = args['QmBasis']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMClass.Charge","title":"<code>Charge = args['QmCharge']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMClass.Method","title":"<code>Method = args['QmMethod']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMClass.QMExtra","title":"<code>QMExtra = args['QmArgs']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMClass.QMSel","title":"<code>QMSel = args['QmSelection']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMClass.QMpath","title":"<code>QMpath = args['QmPath']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMClass.SelFile","title":"<code>SelFile = '../syst-qm.pdb'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMClass.Spin","title":"<code>Spin = args['QmSpin']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMClass.__init__","title":"<code>__init__(args)</code>","text":"<p>QM Class init.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>ArgParse formatted user inputs.</p> required <p>Attributes:</p> Name Type Description <code>QMpath</code> <code>str</code> <p>Path to the QM executable</p> <code>QMSel</code> <code>str</code> <p>string containing vmd selection algebra of qm zone</p> <code>Charge</code> <code>int</code> <p>Net charge of QM zone</p> <code>Spin</code> <code>int</code> <p>Total spin of QM zone</p> <code>Method</code> <code>str</code> <p>QM method supported by ORCA</p> <code>Basis</code> <code>str</code> <p>QM basis set supported by ORCA</p> <code>QMExtra</code> <code>str</code> <p>Any extra commands to provide to ORCA</p> Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, args: dict):\n    \"\"\"\n    QM Class init.\n\n    Args:\n        args (Namespace): ArgParse formatted user inputs.\n\n    Attributes:\n        QMpath (str): Path to the QM executable\n        QMSel (str): string containing vmd selection algebra of qm zone\n        Charge (int): Net charge of QM zone\n        Spin (int): Total spin of QM zone\n        Method (str): QM method supported by ORCA\n        Basis (str): QM basis set supported by ORCA\n        QMExtra (str): Any extra commands to provide to ORCA\n    \"\"\"\n    self.QMpath = args[\"QmPath\"]\n    self.QMSel = args[\"QmSelection\"]\n    self.Charge = args[\"QmCharge\"]\n    self.Spin = args[\"QmSpin\"]\n    self.Method = args[\"QmMethod\"]\n    self.Basis = args[\"QmBasis\"]\n    self.QMExtra = args[\"QmArgs\"]\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.QMClass.set_selfile","title":"<code>set_selfile(File)</code>","text":"<p>Sets the selection file</p> <p>Parameters:</p> Name Type Description Default <code>File</code> <code>str</code> <p>Name of file</p> required Attribute <p>SelFile (str): Selection file</p> Source code in <code>Tools/classes.py</code> <pre><code>def set_selfile(self, File: str):\n    \"\"\"\n    Sets the selection file\n\n    Args:\n        File (str): Name of file\n\n    Attribute:\n        SelFile (str): Selection file\n    \"\"\"\n    self.SelFile = File\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass","title":"<code>ReactionClass</code>","text":"<p>Class containing reaction data for two step processes.  Attributes:     Reactant (str): Name of molecule 1     Reactant_Energy (float): Total energy corresponding to molecule 1     Product (str): Name of molecule 2     Product_Energy (float): Total energy corresponding to molecule 2     functional (str): QM Method     basis (str): QM Basis Set     dispersion (str): QM Dispersion correction     deltaE (float): energy2-energy1     Timing (float): Total time to calculate both molecules</p> Source code in <code>Tools/classes.py</code> <pre><code>class ReactionClass:\n    \"\"\" Class containing reaction data for two step processes. \n    Attributes:\n        Reactant (str): Name of molecule 1\n        Reactant_Energy (float): Total energy corresponding to molecule 1\n        Product (str): Name of molecule 2\n        Product_Energy (float): Total energy corresponding to molecule 2\n        functional (str): QM Method\n        basis (str): QM Basis Set\n        dispersion (str): QM Dispersion correction\n        deltaE (float): energy2-energy1\n        Timing (float): Total time to calculate both molecules\n    \"\"\"\n    def __init__(self, name1:str, energy1:float, name2:str, energy2:float, method:str, basis:str, dispersion:str):\n        \"\"\"Initialises with energies\n\n        Args:\n            name1 (str): Name of molecule 1\n            energy1 (float): Total energy corresponding to molecule 1\n            name2 (str): Name of molecule 2\n            energy2 (float): Total energy corresponding to molecule 2\n            method (str): QM Method\n            basis (str): QM Basis Set\n            dispersion (str): QM Dispersion correction\n\n        Attributes:\n            deltaE (float): energy2-energy1\n        \"\"\"\n        self.Reactant = name1\n        self.Reactant_Energy = energy1\n        self.Product = name2\n        self.Product_Energy = energy2\n        self.functional = method\n        self.basis = basis\n        self.dispersion = dispersion\n        self.deltaE = energy2 - energy1\n    def add_timings(self, Time1:float, Time2:float):\n        \"\"\" Calculates the total time for the reaction calculation\n\n        Args:\n            Time1 (float): Time to calculate molecule 1\n            Time2 (float): Time to calculate molecule 2\n\n        Attributes:\n            Timing (float): Total time to calculate both molecules\n        \"\"\"\n        self.Timing = Time1 + Time2\n    def add_Error(self, err:float):\n        \"\"\"\n        Adds the absolute error of the calculation to the data class\n\n        Args:\n            err (float): Absolute error.\n\n        \"\"\"\n        self.error = err\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass.Product","title":"<code>Product = name2</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass.Product_Energy","title":"<code>Product_Energy = energy2</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass.Reactant","title":"<code>Reactant = name1</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass.Reactant_Energy","title":"<code>Reactant_Energy = energy1</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass.basis","title":"<code>basis = basis</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass.deltaE","title":"<code>deltaE = energy2 - energy1</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass.dispersion","title":"<code>dispersion = dispersion</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass.functional","title":"<code>functional = method</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass.__init__","title":"<code>__init__(name1, energy1, name2, energy2, method, basis, dispersion)</code>","text":"<p>Initialises with energies</p> <p>Parameters:</p> Name Type Description Default <code>name1</code> <code>str</code> <p>Name of molecule 1</p> required <code>energy1</code> <code>float</code> <p>Total energy corresponding to molecule 1</p> required <code>name2</code> <code>str</code> <p>Name of molecule 2</p> required <code>energy2</code> <code>float</code> <p>Total energy corresponding to molecule 2</p> required <code>method</code> <code>str</code> <p>QM Method</p> required <code>basis</code> <code>str</code> <p>QM Basis Set</p> required <code>dispersion</code> <code>str</code> <p>QM Dispersion correction</p> required <p>Attributes:</p> Name Type Description <code>deltaE</code> <code>float</code> <p>energy2-energy1</p> Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, name1:str, energy1:float, name2:str, energy2:float, method:str, basis:str, dispersion:str):\n    \"\"\"Initialises with energies\n\n    Args:\n        name1 (str): Name of molecule 1\n        energy1 (float): Total energy corresponding to molecule 1\n        name2 (str): Name of molecule 2\n        energy2 (float): Total energy corresponding to molecule 2\n        method (str): QM Method\n        basis (str): QM Basis Set\n        dispersion (str): QM Dispersion correction\n\n    Attributes:\n        deltaE (float): energy2-energy1\n    \"\"\"\n    self.Reactant = name1\n    self.Reactant_Energy = energy1\n    self.Product = name2\n    self.Product_Energy = energy2\n    self.functional = method\n    self.basis = basis\n    self.dispersion = dispersion\n    self.deltaE = energy2 - energy1\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass.add_Error","title":"<code>add_Error(err)</code>","text":"<p>Adds the absolute error of the calculation to the data class</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>float</code> <p>Absolute error.</p> required Source code in <code>Tools/classes.py</code> <pre><code>def add_Error(self, err:float):\n    \"\"\"\n    Adds the absolute error of the calculation to the data class\n\n    Args:\n        err (float): Absolute error.\n\n    \"\"\"\n    self.error = err\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.ReactionClass.add_timings","title":"<code>add_timings(Time1, Time2)</code>","text":"<p>Calculates the total time for the reaction calculation</p> <p>Parameters:</p> Name Type Description Default <code>Time1</code> <code>float</code> <p>Time to calculate molecule 1</p> required <code>Time2</code> <code>float</code> <p>Time to calculate molecule 2</p> required <p>Attributes:</p> Name Type Description <code>Timing</code> <code>float</code> <p>Total time to calculate both molecules</p> Source code in <code>Tools/classes.py</code> <pre><code>def add_timings(self, Time1:float, Time2:float):\n    \"\"\" Calculates the total time for the reaction calculation\n\n    Args:\n        Time1 (float): Time to calculate molecule 1\n        Time2 (float): Time to calculate molecule 2\n\n    Attributes:\n        Timing (float): Total time to calculate both molecules\n    \"\"\"\n    self.Timing = Time1 + Time2\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass","title":"<code>SLURMClass</code>","text":"<p>Class for containing SLURM variables Attributes:     HostName (str): Hostname returned by socket.gethostname()     WallTime (int): Maximum calculation length hours     Cores (int): Number of cores     Memory (int): Ammount of memory     Partition (str): SLURM partition     NodeCores (int): Max cores per node     account (str): SLURM billing account     qos (str): SLURM QoS     Software (list): Lines containing software loading commands such as modules     dependency (str): SLURM Dependency line</p> Source code in <code>Tools/classes.py</code> <pre><code>class SLURMClass:\n    \"\"\"Class for containing SLURM variables\n    Attributes:\n        HostName (str): Hostname returned by socket.gethostname()\n        WallTime (int): Maximum calculation length hours\n        Cores (int): Number of cores\n        Memory (int): Ammount of memory\n        Partition (str): SLURM partition\n        NodeCores (int): Max cores per node\n        account (str): SLURM billing account\n        qos (str): SLURM QoS\n        Software (list): Lines containing software loading commands such as modules\n        dependency (str): SLURM Dependency line\n    \"\"\"\n    account = \"\"\n    qos = \"\"\n    dependency = \"\"\n    def __init__(self, args: dict):\n        \"\"\"inits slurm class\n\n        Args:\n            args (dict): User defined variables\n\n        Attributes:\n            HostName (str): Hostname returned by socket.gethostname()\n            WallTime (int): Maximum calculation length hours\n            Cores (int): Number of cores\n            Memory (int): Ammount of memory\n            Partition (str): SLURM partition\n            NodeCores (int): Max cores per node\n            account (str): SLURM billing account\n            qos (str): SLURM QoS\n            Software (list): Lines containing software loading commands such as modules\n\n        \"\"\"\n        self.HostName = args[\"HostName\"]\n        self.WallTime = args[\"MaxWallTime\"]\n        self.Cores = args[\"CoresPerJob\"]\n        self.Memory = args[\"MemoryPerJob\"]\n        # self.k = args[\"HostName\"]\n        self.Partition = args[\"Partition\"]\n        self.NodeCores = args[\"MaxCores\"]\n        if args[\"Account\"].casefold() != \"none\":\n            acc = args[\"Account\"]\n            self.account = f\"#SBATCH --account={acc}\"\n        if args[\"QualityofService\"].casefold() != \"none\":\n            qos = args[\"QualityofService\"]\n            self.qos = f\"#SBATCH --qos={qos}\"\n        self.Software = args[\"SoftwareLines\"]\n    def set_dependancy(self, ID:int):\n        \"\"\"\n        Can be used to chain slurm Calculations together.\n\n        Args:\n            ID (int): SLURM ID\n\n        Attributes:\n            dependency (str): SLURM Dependency line\n        \"\"\"\n        self.dependency = f\"#SBATCH --dependency=afterok:{ID}\"\n    def set_arrayJob(self, ArrayJob:str, Length:int):\n        \"\"\"\n        Hacky work around for HPC systems with Node exclusivity so you can run multiple jobs per node in a single calculation.\n\n        Args:\n            ArrayJob (str): yes or no\n            Length (int): Size of array\n\n        Attributes:\n            ArrayLength (int): Reduced array size\n            JobsPerNode (int): Number of mini jobs to be run as a single job.\n\n        \"\"\"\n        self.ArrayJob = ArrayJob\n        if \"archer\" in self.HostName.casefold():\n            sublength = math.ceil(Length/(self.NodeCores/self.Cores))\n            self.ArrayLength = sublength\n            self.JobsPerNode = math.floor(self.NodeCores/self.Cores)\n        else:\n            self.ArrayLength = Length\n            self.JobsPerNode = 1    # If Nodes arent exclusive, this can be set to 1 and it will run a normal array job.\n    # def set_software(self, Software:str):\n    #     self.Software = Software\n    def set_accountInfo(self, Qos:str, Account:str):\n        \"\"\"\n        sorts out the SLURM user account info. \n\n        Args:\n            Qos (str): SLURM QoS\n            Account (str): SLURM Account\n\n        \"\"\"\n        self.qos = Qos\n        self.account = Account\n    def set_IDNumber(self, ):\n        \"\"\"_summary_\n        Attribute:\n            ID_Number (int): \n        \"\"\"\n        if \"archer\" in self.HostName.casefold():\n            Number = 1\n        elif \"sulis\" in self.HostName.casefold():\n            Number = 4\n        elif \"ada\" in self.HostName.casefold():\n            Number = 4\n        else:\n            Number = 1\n            print(\"WARNING, The HPC that you are using is not in my database... \")\n            print(\"The runnner.sh script may not work as intended and so you may have to tune the sed command to grab the slurm ID\")\n        self.ID_Number = Number\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.Cores","title":"<code>Cores = args['CoresPerJob']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.HostName","title":"<code>HostName = args['HostName']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.Memory","title":"<code>Memory = args['MemoryPerJob']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.NodeCores","title":"<code>NodeCores = args['MaxCores']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.Partition","title":"<code>Partition = args['Partition']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.Software","title":"<code>Software = args['SoftwareLines']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.WallTime","title":"<code>WallTime = args['MaxWallTime']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.account","title":"<code>account = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.dependency","title":"<code>dependency = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.qos","title":"<code>qos = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.__init__","title":"<code>__init__(args)</code>","text":"<p>inits slurm class</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>dict</code> <p>User defined variables</p> required <p>Attributes:</p> Name Type Description <code>HostName</code> <code>str</code> <p>Hostname returned by socket.gethostname()</p> <code>WallTime</code> <code>int</code> <p>Maximum calculation length hours</p> <code>Cores</code> <code>int</code> <p>Number of cores</p> <code>Memory</code> <code>int</code> <p>Ammount of memory</p> <code>Partition</code> <code>str</code> <p>SLURM partition</p> <code>NodeCores</code> <code>int</code> <p>Max cores per node</p> <code>account</code> <code>str</code> <p>SLURM billing account</p> <code>qos</code> <code>str</code> <p>SLURM QoS</p> <code>Software</code> <code>list</code> <p>Lines containing software loading commands such as modules</p> Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, args: dict):\n    \"\"\"inits slurm class\n\n    Args:\n        args (dict): User defined variables\n\n    Attributes:\n        HostName (str): Hostname returned by socket.gethostname()\n        WallTime (int): Maximum calculation length hours\n        Cores (int): Number of cores\n        Memory (int): Ammount of memory\n        Partition (str): SLURM partition\n        NodeCores (int): Max cores per node\n        account (str): SLURM billing account\n        qos (str): SLURM QoS\n        Software (list): Lines containing software loading commands such as modules\n\n    \"\"\"\n    self.HostName = args[\"HostName\"]\n    self.WallTime = args[\"MaxWallTime\"]\n    self.Cores = args[\"CoresPerJob\"]\n    self.Memory = args[\"MemoryPerJob\"]\n    # self.k = args[\"HostName\"]\n    self.Partition = args[\"Partition\"]\n    self.NodeCores = args[\"MaxCores\"]\n    if args[\"Account\"].casefold() != \"none\":\n        acc = args[\"Account\"]\n        self.account = f\"#SBATCH --account={acc}\"\n    if args[\"QualityofService\"].casefold() != \"none\":\n        qos = args[\"QualityofService\"]\n        self.qos = f\"#SBATCH --qos={qos}\"\n    self.Software = args[\"SoftwareLines\"]\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.set_IDNumber","title":"<code>set_IDNumber()</code>","text":"<p>summary Attribute:     ID_Number (int):</p> Source code in <code>Tools/classes.py</code> <pre><code>def set_IDNumber(self, ):\n    \"\"\"_summary_\n    Attribute:\n        ID_Number (int): \n    \"\"\"\n    if \"archer\" in self.HostName.casefold():\n        Number = 1\n    elif \"sulis\" in self.HostName.casefold():\n        Number = 4\n    elif \"ada\" in self.HostName.casefold():\n        Number = 4\n    else:\n        Number = 1\n        print(\"WARNING, The HPC that you are using is not in my database... \")\n        print(\"The runnner.sh script may not work as intended and so you may have to tune the sed command to grab the slurm ID\")\n    self.ID_Number = Number\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.set_accountInfo","title":"<code>set_accountInfo(Qos, Account)</code>","text":"<p>sorts out the SLURM user account info. </p> <p>Parameters:</p> Name Type Description Default <code>Qos</code> <code>str</code> <p>SLURM QoS</p> required <code>Account</code> <code>str</code> <p>SLURM Account</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_accountInfo(self, Qos:str, Account:str):\n    \"\"\"\n    sorts out the SLURM user account info. \n\n    Args:\n        Qos (str): SLURM QoS\n        Account (str): SLURM Account\n\n    \"\"\"\n    self.qos = Qos\n    self.account = Account\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.set_arrayJob","title":"<code>set_arrayJob(ArrayJob, Length)</code>","text":"<p>Hacky work around for HPC systems with Node exclusivity so you can run multiple jobs per node in a single calculation.</p> <p>Parameters:</p> Name Type Description Default <code>ArrayJob</code> <code>str</code> <p>yes or no</p> required <code>Length</code> <code>int</code> <p>Size of array</p> required <p>Attributes:</p> Name Type Description <code>ArrayLength</code> <code>int</code> <p>Reduced array size</p> <code>JobsPerNode</code> <code>int</code> <p>Number of mini jobs to be run as a single job.</p> Source code in <code>Tools/classes.py</code> <pre><code>def set_arrayJob(self, ArrayJob:str, Length:int):\n    \"\"\"\n    Hacky work around for HPC systems with Node exclusivity so you can run multiple jobs per node in a single calculation.\n\n    Args:\n        ArrayJob (str): yes or no\n        Length (int): Size of array\n\n    Attributes:\n        ArrayLength (int): Reduced array size\n        JobsPerNode (int): Number of mini jobs to be run as a single job.\n\n    \"\"\"\n    self.ArrayJob = ArrayJob\n    if \"archer\" in self.HostName.casefold():\n        sublength = math.ceil(Length/(self.NodeCores/self.Cores))\n        self.ArrayLength = sublength\n        self.JobsPerNode = math.floor(self.NodeCores/self.Cores)\n    else:\n        self.ArrayLength = Length\n        self.JobsPerNode = 1    # If Nodes arent exclusive, this can be set to 1 and it will run a normal array job.\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.SLURMClass.set_dependancy","title":"<code>set_dependancy(ID)</code>","text":"<p>Can be used to chain slurm Calculations together.</p> <p>Parameters:</p> Name Type Description Default <code>ID</code> <code>int</code> <p>SLURM ID</p> required <p>Attributes:</p> Name Type Description <code>dependency</code> <code>str</code> <p>SLURM Dependency line</p> Source code in <code>Tools/classes.py</code> <pre><code>def set_dependancy(self, ID:int):\n    \"\"\"\n    Can be used to chain slurm Calculations together.\n\n    Args:\n        ID (int): SLURM ID\n\n    Attributes:\n        dependency (str): SLURM Dependency line\n    \"\"\"\n    self.dependency = f\"#SBATCH --dependency=afterok:{ID}\"\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass","title":"<code>UmbrellaClass</code>","text":"<p>Class for containing umbrella sampling information.</p> <p>Attributes:</p> Name Type Description <code>args</code> <code>dict</code> <p>ArgParse arguments to read in user defined variables</p> <code>Min</code> <code>float</code> <p>Minimum Umbrella value</p> <code>bins</code> <code>int</code> <p>Number of Umbrella bins</p> <code>Start</code> <code>float</code> <p>Current value of the colvar. (taken from the equilibrated start structure)</p> <code>Width</code> <code>float</code> <p>Width of the Umbrella bins, (Can be negative, if so Min =&gt; Max)</p> <code>atom1</code> <code>int</code> <p>Atom1 for colective variable (always required)</p> <code>atom2</code> <code>int</code> <p>Atom2 for colective variable (always required)</p> <code>atom3</code> <code>int</code> <p>Atom3 for colective variable (required if angle or dihedral) else 0</p> <code>atom4</code> <code>int</code> <p>Atom4 for colective variable (required if dihedral) else 0</p> <code>PullForce</code> <code>float</code> <p>Force to use when pulling to each lambda window</p> <code>ConstForce</code> <code>float</code> <p>Force to use when running constant Umbrella sampling.</p> <code>BinVals</code> <code>list</code> <p>List of Umbrella bin values</p> <code>StartBin</code> <code>int</code> <p>Bin closest to the starting value of the collective variable</p> Source code in <code>Tools/classes.py</code> <pre><code>class UmbrellaClass:\n    \"\"\"Class for containing umbrella sampling information.\n\n    Attributes:\n        args (dict): ArgParse arguments to read in user defined variables\n        Min (float): Minimum Umbrella value\n        bins (int): Number of Umbrella bins\n        Start (float): Current value of the colvar. (taken from the equilibrated start structure)\n        Width (float): Width of the Umbrella bins, (Can be negative, if so Min =&gt; Max)\n        atom1 (int): Atom1 for colective variable (always required)\n        atom2 (int): Atom2 for colective variable (always required)\n        atom3 (int): Atom3 for colective variable (required if angle or dihedral) else 0\n        atom4 (int): Atom4 for colective variable (required if dihedral) else 0\n        PullForce (float): Force to use when pulling to each lambda window\n        ConstForce (float): Force to use when running constant Umbrella sampling.\n        BinVals (list): List of Umbrella bin values\n        StartBin (int): Bin closest to the starting value of the collective variable\n\n    \"\"\"\n    def __init__(self, args: dict, Min: float, bins: int, Start:float, Width:float, ):\n        \"\"\"\n        Umbrella class Init. \n        Args:\n            args (Namespace): ArgParse arguments to read in user defined variables\n            Min (float): Minimum Umbrella value\n            bins (int): Number of Umbrella bins\n            Start (float): Current value of the colvar. (taken from the equilibrated start structure)\n            Width (float): Width of the Umbrella bins, (Can be negative, if so Min =&gt; Max)\n        Attributes:\n            atom1 (int): Atom1 for colective variable (always required)\n            atom2 (int): Atom2 for colective variable (always required)\n            atom3 (int): Atom3 for colective variable (required if angle or dihedral) else 0\n            atom4 (int): Atom4 for colective variable (required if dihedral) else 0\n            PullForce (float): Force to use when pulling to each lambda window\n            ConstForce (float): Force to use when running constant Umbrella sampling.\n        \"\"\"\n        self.atom1 = int(args[\"AtomMask\"].split(\",\")[0])\n        self.atom2 = int(args[\"AtomMask\"].split(\",\")[1])\n        self.atom3 = int(args[\"AtomMask\"].split(\",\")[2])\n        self.atom4 = int(args[\"AtomMask\"].split(\",\")[3])\n        self.Min = Min\n        self.Bins = bins\n        self.Start = Start\n        self.Width = Width\n        self.PullForce = args[\"PullForce\"]\n        self.ConstForce = args[\"ConstForce\"]\n    def add_bins(self, BinVals:list):\n        \"\"\"\n        Adds values to the Umbrella bins\n\n        Args:\n            BinVals (list): List of Umbrella bin values\n        \"\"\"\n        self.BinVals = BinVals\n    def add_start(self, StartBin:int):\n        \"\"\"\n        Defines which bin is the start bin (For use when pulling evenly.)\n\n        Args:\n            StartBin (int): Bin closest to the starting value of the collective variable\n        \"\"\"\n        self.StartBin = StartBin\n    def set_force(self, Force:float): ### To combine Umbrella for use in Standalone calculations\n        \"\"\"\n        Can change the force for Steered MD, Not used in Umbrella sampling\n\n        Args:\n            Force (float): Force to be applied for SMD\n        \"\"\"\n        self.PullForce = Force\n        self.ConstForce = Force\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.Bins","title":"<code>Bins = bins</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.ConstForce","title":"<code>ConstForce = args['ConstForce']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.Min","title":"<code>Min = Min</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.PullForce","title":"<code>PullForce = args['PullForce']</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.Start","title":"<code>Start = Start</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.Width","title":"<code>Width = Width</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.atom1","title":"<code>atom1 = int(args['AtomMask'].split(',')[0])</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.atom2","title":"<code>atom2 = int(args['AtomMask'].split(',')[1])</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.atom3","title":"<code>atom3 = int(args['AtomMask'].split(',')[2])</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.atom4","title":"<code>atom4 = int(args['AtomMask'].split(',')[3])</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.__init__","title":"<code>__init__(args, Min, bins, Start, Width)</code>","text":"<p>Umbrella class Init.  Args:     args (Namespace): ArgParse arguments to read in user defined variables     Min (float): Minimum Umbrella value     bins (int): Number of Umbrella bins     Start (float): Current value of the colvar. (taken from the equilibrated start structure)     Width (float): Width of the Umbrella bins, (Can be negative, if so Min =&gt; Max) Attributes:     atom1 (int): Atom1 for colective variable (always required)     atom2 (int): Atom2 for colective variable (always required)     atom3 (int): Atom3 for colective variable (required if angle or dihedral) else 0     atom4 (int): Atom4 for colective variable (required if dihedral) else 0     PullForce (float): Force to use when pulling to each lambda window     ConstForce (float): Force to use when running constant Umbrella sampling.</p> Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, args: dict, Min: float, bins: int, Start:float, Width:float, ):\n    \"\"\"\n    Umbrella class Init. \n    Args:\n        args (Namespace): ArgParse arguments to read in user defined variables\n        Min (float): Minimum Umbrella value\n        bins (int): Number of Umbrella bins\n        Start (float): Current value of the colvar. (taken from the equilibrated start structure)\n        Width (float): Width of the Umbrella bins, (Can be negative, if so Min =&gt; Max)\n    Attributes:\n        atom1 (int): Atom1 for colective variable (always required)\n        atom2 (int): Atom2 for colective variable (always required)\n        atom3 (int): Atom3 for colective variable (required if angle or dihedral) else 0\n        atom4 (int): Atom4 for colective variable (required if dihedral) else 0\n        PullForce (float): Force to use when pulling to each lambda window\n        ConstForce (float): Force to use when running constant Umbrella sampling.\n    \"\"\"\n    self.atom1 = int(args[\"AtomMask\"].split(\",\")[0])\n    self.atom2 = int(args[\"AtomMask\"].split(\",\")[1])\n    self.atom3 = int(args[\"AtomMask\"].split(\",\")[2])\n    self.atom4 = int(args[\"AtomMask\"].split(\",\")[3])\n    self.Min = Min\n    self.Bins = bins\n    self.Start = Start\n    self.Width = Width\n    self.PullForce = args[\"PullForce\"]\n    self.ConstForce = args[\"ConstForce\"]\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.add_bins","title":"<code>add_bins(BinVals)</code>","text":"<p>Adds values to the Umbrella bins</p> <p>Parameters:</p> Name Type Description Default <code>BinVals</code> <code>list</code> <p>List of Umbrella bin values</p> required Source code in <code>Tools/classes.py</code> <pre><code>def add_bins(self, BinVals:list):\n    \"\"\"\n    Adds values to the Umbrella bins\n\n    Args:\n        BinVals (list): List of Umbrella bin values\n    \"\"\"\n    self.BinVals = BinVals\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.add_start","title":"<code>add_start(StartBin)</code>","text":"<p>Defines which bin is the start bin (For use when pulling evenly.)</p> <p>Parameters:</p> Name Type Description Default <code>StartBin</code> <code>int</code> <p>Bin closest to the starting value of the collective variable</p> required Source code in <code>Tools/classes.py</code> <pre><code>def add_start(self, StartBin:int):\n    \"\"\"\n    Defines which bin is the start bin (For use when pulling evenly.)\n\n    Args:\n        StartBin (int): Bin closest to the starting value of the collective variable\n    \"\"\"\n    self.StartBin = StartBin\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.UmbrellaClass.set_force","title":"<code>set_force(Force)</code>","text":"<p>Can change the force for Steered MD, Not used in Umbrella sampling</p> <p>Parameters:</p> Name Type Description Default <code>Force</code> <code>float</code> <p>Force to be applied for SMD</p> required Source code in <code>Tools/classes.py</code> <pre><code>def set_force(self, Force:float): ### To combine Umbrella for use in Standalone calculations\n    \"\"\"\n    Can change the force for Steered MD, Not used in Umbrella sampling\n\n    Args:\n        Force (float): Force to be applied for SMD\n    \"\"\"\n    self.PullForce = Force\n    self.ConstForce = Force\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.WhamClass","title":"<code>WhamClass</code>","text":"<p>Class for controlling WHAM calculation information Attributes:     Name: Name of wham calculation     Force: Force for biasing windows     Type: discrete or continuous</p> Source code in <code>Tools/classes.py</code> <pre><code>class WhamClass:\n    \"\"\"Class for controlling WHAM calculation information\n    Attributes:\n        Name: Name of wham calculation\n        Force: Force for biasing windows\n        Type: discrete or continuous\n    \"\"\"\n    def __init__(self, Name: str, Force: float, type=\"discrete\"):\n        \"\"\"\n        Wham Class initialisation. Used for containing information about the wham calc. \n        Args:\n            Name (str): Name of wham calculation\n            Force (float): Force for biasing windows\n            type (str): discrete or continuous\n        \"\"\"\n        self.Name = Name\n        self.Force = Force\n        assert type == \"discrete\"  or type == \"periodic\", f\"ERROR: {type} Wham type not supported. Should be either discrete or continuous\"\n        self.Type = type\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.WhamClass.Force","title":"<code>Force = Force</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.WhamClass.Name","title":"<code>Name = Name</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.WhamClass.Type","title":"<code>Type = type</code>  <code>instance-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.classes.WhamClass.__init__","title":"<code>__init__(Name, Force, type='discrete')</code>","text":"<p>Wham Class initialisation. Used for containing information about the wham calc.  Args:     Name (str): Name of wham calculation     Force (float): Force for biasing windows     type (str): discrete or continuous</p> Source code in <code>Tools/classes.py</code> <pre><code>def __init__(self, Name: str, Force: float, type=\"discrete\"):\n    \"\"\"\n    Wham Class initialisation. Used for containing information about the wham calc. \n    Args:\n        Name (str): Name of wham calculation\n        Force (float): Force for biasing windows\n        type (str): discrete or continuous\n    \"\"\"\n    self.Name = Name\n    self.Force = Force\n    assert type == \"discrete\"  or type == \"periodic\", f\"ERROR: {type} Wham type not supported. Should be either discrete or continuous\"\n    self.Type = type\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.globals","title":"<code>globals</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.globals.DryRun","title":"<code>DryRun = True</code>  <code>module-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.globals.WorkDir","title":"<code>WorkDir = './'</code>  <code>module-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.globals.parmfile","title":"<code>parmfile = 'complex.parm7'</code>  <code>module-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.globals.verbosity","title":"<code>verbosity = 0</code>  <code>module-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.globals.init","title":"<code>init(v=0, wd='./', dr=True, parm='complex.parm7')</code>","text":"Source code in <code>Tools/globals.py</code> <pre><code>def init(v=0, wd=\"./\", dr=True, parm=\"complex.parm7\"):\n    global WorkDir    \n    global verbosity\n    global DryRun\n    global parmfile\n    verbosity=v\n    WorkDir=wd\n    DryRun=dr\n    parmfile=parm\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils","title":"<code>utils</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.kcal","title":"<code>kcal = 627.51</code>  <code>module-attribute</code>","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.ColVarPDB_Gen","title":"<code>ColVarPDB_Gen(Umbrella)</code>","text":"<p>tcl script to obtain the syst-col.pdb file. It is a requirement for SMD and Umbrella sampling.</p> Source code in <code>Tools/utils.py</code> <pre><code>def ColVarPDB_Gen(Umbrella: UmbrellaClass, ):\n    \"\"\"tcl script to obtain the syst-col.pdb file. It is a requirement for SMD and Umbrella sampling.\"\"\"\n    if Umbrella.atom3 == 0:\n        tcl = f\"\"\"mol new {globals.parmfile}\nmol addfile start.rst7\n\nset colPDB \"syst-col.pdb\"\n\nset sel [atomselect 0 all]\n$sel set beta 0\n$sel set occupancy 0\n\nset seltext \"(index {Umbrella.atom1})\"\n[atomselect 0 \"$seltext\"] set beta 1\n\nset seltext \"(index {Umbrella.atom2})\"\n[atomselect 0 \"$seltext\"] set beta 2\n\n$sel writepdb $colPDB\n\nquit\n\"\"\"\n    elif Umbrella.atom4 == 0:\n        tcl = f\"\"\"mol new {globals.parmfile}\nmol addfile start.rst7\n\nset colPDB \"syst-col.pdb\"\n\nset sel [atomselect 0 all]\n$sel set beta 0\n$sel set occupancy 0\n\nset seltext \"(index {Umbrella.atom1})\"\n[atomselect 0 \"$seltext\"] set beta 1\n\nset seltext \"(index {Umbrella.atom2})\"\n[atomselect 0 \"$seltext\"] set beta 2\n\nset seltext \"(index {Umbrella.atom3})\"\n[atomselect 0 \"$seltext\"] set beta 3\n\n\n\n$sel writepdb $colPDB\n\nquit\n\"\"\"\n    else:\n        tcl = f\"\"\"mol new {globals.parmfile}\nmol addfile start.rst7\n\nset colPDB \"syst-col.pdb\"\n\nset sel [atomselect 0 all]\n$sel set beta 0\n$sel set occupancy 0\n\nset seltext \"(index {Umbrella.atom1})\"\n[atomselect 0 \"$seltext\"] set beta 1\n\nset seltext \"(index {Umbrella.atom2})\"\n[atomselect 0 \"$seltext\"] set beta 2\n\nset seltext \"(index {Umbrella.atom3})\"\n[atomselect 0 \"$seltext\"] set beta 3\n\nset seltext \"(index {Umbrella.atom4})\"\n[atomselect 0 \"$seltext\"] set beta 4\n\n$sel writepdb $colPDB\n\nquit\n\"\"\"\n    file_write(f\"{globals.WorkDir}Colvar_prep.tcl\", [tcl])\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.QM_Gen","title":"<code>QM_Gen(qmzone)</code>","text":"<p>Creates a tcl script file for generating the syst-qm.pdb.</p> Source code in <code>Tools/utils.py</code> <pre><code>def QM_Gen(qmzone,):\n    \"\"\"Creates a tcl script file for generating the syst-qm.pdb.\"\"\"    \n    tcl = f\"\"\"\nmol new {globals.parmfile}\nmol addfile start.rst7\n\nset qmPDB \"syst-qm.pdb\"\nset qmPSF \"syst-qm.QMonly.parm7\"\nset idDictFileName \"syst-qm.idDict.txt\"\n\nset sel [atomselect 0 all]\n$sel set beta 0\n$sel set occupancy 0\n\nset seltext \"({qmzone})\"\n[atomselect 0 \"$seltext\"] set beta 1\n\nputs \"Initializing chain and QM region loops.\"\nset systemSegs [lsort -unique [[atomselect 0 \"protein or nucleic\"] get chain]]\nset systemQMregs [lsort -unique [[atomselect 0 \"(protein or nucleic) and beta &gt; 0\"] get beta]]\n\nputs \"Chains: $systemSegs\"\nputs \"QM Regions: $systemQMregs\"\n\nforeach seg $systemSegs {\"{\"}\n    foreach qmReg $systemQMregs {\"{\"}\n        puts \"\\nChecking QM region $qmReg in chain $seg\"\n        set qmmmm [atomselect 0 \"(protein and name CA) and beta == $qmReg and chain $seg\"]\n        set cter [lindex [lsort -unique -integer [[atomselect 0 \"chain $seg\"] get resid]] end]\n        set listqmmm [$qmmmm get resid]\n        puts \"Protein residues marked for QM this region in this chain: $listqmmm\"\n        list QM1bond\n        list QM2bond\n        puts \"Checking N-Terminal-direction QM-MM bonds...\"\n        foreach resTest $listqmmm {\"{\"}\n            if {\"{\"} [ lsearch $listqmmm [ expr $resTest -1 ] ] &lt; 0 {\"}\"} {\"{\"}\n                lappend QM1bond [ expr $resTest -1 ]\n            {\"}\"}\n        {\"}\"}\n        puts \"Checking C-terminal-direction QM-MM bonds...\"\n        foreach resTest $listqmmm {\"{\"}\n             if {\"{\"} $resTest == $cter{\"}\"} {\"{\"}\n                continue\n            {\"}\"}\n            if {\"{\"} [ lsearch $listqmmm [ expr $resTest +1 ] ] &lt; 0 {\"}\"} {\"{\"}\n                lappend QM2bond $resTest\n            {\"}\"}\n        {\"}\"}\n        puts \"Making changes...\"\n        if {\"{\"}[info exists QM2bond]{\"}\"} {\"{\"}\n            [atomselect 0 \"name CA C and (resid $QM2bond and chain $seg)\"] set occupancy 1\n            [atomselect 0 \"name C O and (resid $QM2bond and chain $seg)\"] set beta 0\n            unset QM2bond\n        {\"}\"}\n        if {\"{\"}[info exists QM1bond]{\"}\"} {\"{\"}\n            [atomselect 0 \"name CA C and (resid $QM1bond and chain $seg)\"] set occupancy 1\n            [atomselect 0 \"name C O and (resid $QM1bond and chain $seg)\"] set beta $qmReg\n            unset QM1bond\n        {\"}\"}\n       set qmmmm [atomselect 0 \"(nucleic and name P) and beta == $qmReg and chain $seg\"]\n        set fiveTer [lindex [lsort -unique -integer [[atomselect 0 \"chain $seg\"] get resid]] 0]\n        set listqmmm [$qmmmm get resid]\n        puts \"Nucleic residues marked for QM this region in this chain: $listqmmm\"\n\n        list QM1bond\n        list QM2bond\n        puts \"Checking 3'-Terminal-direction QM-MM bonds...\"\n        foreach resTest $listqmmm {\"{\"}\n            if {\"{\"}[ lsearch $listqmmm [ expr $resTest +1 ] ] &lt; 0 {\"}\"} {\"{\"}\n                lappend QM1bond [ expr $resTest +1 ]\n            {\"}\"}\n        {\"}\"}\n\n        puts \"Checking 5'-terminal-direction QM-MM bonds...\"\n        foreach resTest $listqmmm {\"{\"}\"{\"}\"}\n            if {\"{\"} $resTest == $fiveTer{\"}\"} {\"{\"}\n                continue\n            {\"}\"}\n            if {\"{\"} [ lsearch $listqmmm [ expr $resTest -1 ] ] &lt; 0 {\"}\"} {\"{\"}\n                lappend QM2bond $resTest\n            {\"}\"}\n        {\"}\"}\n\n       puts \"Making changes...\"\n        if {\"{\"}[info exists QM2bond]{\"}\"} {\"{\"}\n            [atomselect 0 \"name C4' C5' and (resid $QM2bond and chain $seg)\"] set occupancy 1\n            [atomselect 0 \"name P O1P O2P O5' C5' H5' H5'' and (resid $QM2bond and chain $seg)\"] set beta 0\n            unset QM2bond\n        {\"}\"}\n        if {\"{\"}[info exists QM1bond]{\"}\"} {\"{\"}\n            [atomselect 0 \"name C4' C5' and (resid $QM1bond and chain $seg)\"] set occupancy 1\n            [atomselect 0 \"name P O1P O2P O5' C5' H5' H5'' and (resid $QM1bond and chain $seg)\"] set beta $qmReg\n            unset QM1bond\n        {\"}\"}\n    {\"}\"}\n{\"}\"}\n\nputs \"Setting atom elements\"\n\npackage require topotools\n\ntopo guessatom element mass\n\nputs \"Elements guessed!\"\n\nforeach qmReg $systemQMregs {\"{\"}\n    set qmnum [[atomselect 0 \"beta == $qmReg\"] num]\n    set dummy [ [atomselect 0 \"beta == $qmReg and occupancy &gt; 0\"] num ]\n    puts \"QM Region $qmReg contains $qmnum QM atoms and $dummy dummy atoms\"\n{\"}\"}\n\n$sel writepdb $qmPDB\n\n[ atomselect 0 \"beta &gt; 0\" ] writepsf $qmPSF\n\nset qmsel [ atomselect 0 \"beta &gt; 0\" ]\n\nset indxs [ $qmsel get index ]\n\nset fileId [open $idDictFileName \"w\"]\n\nfor {\"{\"}set i 0{\"}\"} {\"{\"} $i &lt; [$qmsel num] {\"}\"} {\"{\"}incr i{\"}\"} {\"{\"}\n\n    set ID [lindex $indxs $i]\n\n    set data \"$i $ID\"\n\n    puts $fileId $data\n{\"}\"}\n\nclose $fileId\n\nquit\n\"\"\"\n    with open(f\"{globals.WorkDir}qm_prep.tcl\", \"w\") as f:\n        print(tcl, file=f)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.array_script","title":"<code>array_script(ntasks)</code>","text":"<p>Required for generating slurm array jobs.</p> Source code in <code>Tools/utils.py</code> <pre><code>def array_script(ntasks: int):\n    \"\"\"Required for generating slurm array jobs.\"\"\"\n    Script=f\"\"\"#!/bin/bash\nRUNLINE=$(cat $ARRAY_TASKFILE | head -n $(($SLURM_ARRAY_TASK_ID*{ntasks})) | tail -n {ntasks}))\neval \\\"$RUNLINE wait\\\"\"\"\"\n    file_write(\"./array_job.sh\", [Script])\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.batch_sub","title":"<code>batch_sub(nequil=4, nprod=16, ID_NUMBER=1)</code>","text":"<p>Generates a runner.sh script that can be run on a login node within a HPC. This can automate the linking of multiple dependant array jobs.</p> Source code in <code>Tools/utils.py</code> <pre><code>def batch_sub(nequil=4, nprod=16, ID_NUMBER=1): \n    \"\"\"Generates a runner.sh script that can be run on a login node within a HPC. This can automate the linking of multiple dependant array jobs.\"\"\"\n    script = f\"\"\"#!/bin/bash\n\"\"\"\n    script += f\"\"\"echo \\\"Submitting equil_1\\\"\ncp sub.sh run.sh\nsed -i \\\"s/NAME/equil_1/g\\\" run.sh\nID=$(sbatch run.sh | awk {\"{print $\"+str(ID_NUMBER)+\"}\"}'')\necho \\\"equil_1 ID is $ID\\\"\necho \\\"equil_1 ID is $ID\\\" &gt;&gt; SLURMID.dat\n\n    \"\"\"\n    for i in range(1, nequil):\n        script += f\"\"\"echo  \\\"Submitting equil_{i+1}\\\"\ncp sub.sh run.sh\nsed -i \\\"s/NAME/equil_{i+1}/g\\\" run.sh\nsed -i \\\"s/#dep/#SBATCH --dependency=afterok:$ID/g\\\" run.sh\nID=$(sbatch run.sh | awk '{\"{print $\"+str(ID_NUMBER)+\"}\"}'))\necho \\\"equil_{i+1} ID is $ID\\\"\necho \\\"equil_{i+1} ID is $ID\\\" &gt;&gt; SLURMID.dat\n\n\"\"\"\n    for i in range(nprod):\n        script += f\"\"\"echo  \\\"Submitting prod_{i+1}\\\"\ncp sub.sh run.sh\nsed -i \\\"s/NAME/prod_{i+1}/g\\\" run.sh\nsed -i \\\"s/#dep/#SBATCH --dependency=afterok:$ID/g\\\" run.sh\nID=$(sbatch run.sh | awk '{\"{print $\"+str(ID_NUMBER)+\"}\"}')\necho \\\"prod_{i+1} ID is $ID\\\"\necho \\\"prod_{i+1} ID is $ID\\\" &gt;&gt; SLURMID.dat\n\n\"\"\"\n    file_write(f\"{globals.WorkDir}/runner.sh\", [script])\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.colvar_gen","title":"<code>colvar_gen(Umbrella, i, type, force, relLoc='../')</code>","text":"<p>Generates collective variables and parses them into the Umbrella class. This also generates the colvar files.</p> Source code in <code>Tools/utils.py</code> <pre><code>def colvar_gen(Umbrella, i, type, force, relLoc=\"../\"):\n    \"\"\"Generates collective variables and parses them into the Umbrella class. This also generates the colvar files.\"\"\"\n    if type == \"pull\":\n        freq = 1\n        Stages = 100\n        if i &gt; Umbrella.StartBin:\n            prevBin = i - 1\n        elif i &lt; Umbrella.StartBin:\n            prevBin = i + 1\n        else:  # Sets initial pull value to actual start value rather than bin target. Allows for smoother pulls.\n            bins = Umbrella.BinVals\n            # print(bins)\n            # print(len(bins))\n            bins = numpy.append(bins, Umbrella.Start)\n            # print(bins)\n            # print(len(bins))\n            Umbrella.add_bins(bins)\n            prevBin = len(Umbrella.BinVals) -1\n            # print(prevBin)\n    else:\n        freq = 1\n        Stages = 0\n        prevBin = i\n    if Umbrella.atom3 == 0: ### Bond distance\n        print(\"Bond collective variable\")\n        # group1 {\"{\"} atomNumbers {Umbrella.atom1} {\"}\"}\n        # group2 {\"{\"} atomNumbers {Umbrella.atom2} {\"}\"}\n        file = f\"\"\"colvarsTrajFrequency     {freq}\n\ncolvar {\"{\"}\n    name length\n    distance {\"{\"}\n\n        group1 {\"{\"}  atomsFile {relLoc}syst-col.pdb\n                      atomsCol B\n                      atomsColValue 1.00\n               {\"}\"}\n        group2 {\"{\"}  atomsFile {relLoc}syst-col.pdb\n                      atomsCol B\n                      atomsColValue 2.00\n               {\"}\"}\n    {\"}\"}\n{\"}\"}\n\nharmonic {\"{\"}\n    name lenpot\n    colvars length\n    centers {Umbrella.BinVals[i]}\n    forceConstant {force}\n{\"}\"}\n\"\"\"\n    elif Umbrella.atom4 == 0: ### 3 Atom angle\n        print(\"Angle collective variable\")\n        file = f\"\"\"colvarsTrajFrequency     {freq}\n\ncolvar {\"{\"}\n    name angle\n    angle {\"{\"}\n        group1 {\"{\"} atomNumbers {Umbrella.atom1} {\"}\"}\n        group2 {\"{\"} atomNumbers {Umbrella.atom2} {\"}\"}\n        group3 {\"{\"} atomNumbers {Umbrella.atom3} {\"}\"}\n    {\"}\"}\n{\"}\"}\n\nharmonic {\"{\"}\n    name angpot\n    colvars angle\n    centers {Umbrella.BinVals[i]}\n    forceConstant {force}\n{\"}\"}\n\"\"\"\n    else:   ### Dihedral angle\n        print(\"Dihedral collective variable\")\n        file = f\"\"\"colvarsTrajFrequency     {freq}\n\n        colvar {\"{\"}\n            name dihedral\n            dihedral {\"{\"}\n                group1 {\"{\"}  atomsFile {relLoc}syst-col.pdb\n                              atomsCol B\n                              atomsColValue 1.00\n                       {\"}\"}\n                group2 {\"{\"}  atomsFile {relLoc}syst-col.pdb\n                              atomsCol B\n                              atomsColValue 2.00\n                       {\"}\"}\n                group3 {\"{\"}  atomsFile {relLoc}syst-col.pdb\n                              atomsCol B\n                              atomsColValue 3.00\n                       {\"}\"}\n                group4 {\"{\"}  atomsFile {relLoc}syst-col.pdb\n                              atomsCol B\n                              atomsColValue 4.00\n                       {\"}\"}\n            {\"}\"}\n        {\"}\"}\n\n        harmonic {\"{\"}\n            name dihedpot\n            colvars dihedral\n            centers {Umbrella.BinVals[prevBin]}\n            forceConstant {force}\n            targetCenters {Umbrella.BinVals[i]}\n            outputCenters on\n            targetNumSteps 50\n            outputAccumulatedWork on\n        {\"}\"}\n        \"\"\"\n    return file\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.convert","title":"<code>convert()</code>","text":"<p>Quick CLI tool to convert between units, currently only ps, fs and ns works.</p> Source code in <code>Tools/utils.py</code> <pre><code>def convert():\n    \"\"\"Quick CLI tool to convert between units, currently only ps, fs and ns works.\n    \"\"\"\n    inputs = input(\"Input value with units: \")\n    inpunit=\"\"\n    group=\"\"\n    val = inputs.split()[0]\n    output = input(\"What units do you want it in? \")\n    if \"fs\" in inputs.casefold():\n        inpunit = \"fs\"\n        group = \"time\"\n        if output.casefold() == \"fs\":\n            print(f\"{val} {inpunit} is {float(val)*1} fs\")\n        elif output.casefold() == \"ps\":\n            print(f\"{val} {inpunit} is {float(val)*0.001} ps\")\n        elif output.casefold() == \"ns\":\n            print(f\"{val} {inpunit} is {float(val)*0.000001} ns\")\n    elif  \"ps\"in inputs.casefold():\n        inpunit = \"ps\"\n        group = \"time\"\n        if output.casefold() == \"fs\":\n            print(f\"{val} {inpunit} is {float(val)*1000} fs\")\n        elif output.casefold() == \"ps\":\n            print(f\"{val} {inpunit} is {float(val)*1} ps\")\n        elif output.casefold() == \"ns\":\n            print(f\"{val} {inpunit} is {float(val)*0.001} ns\")\n    elif \"ns\"in inputs.casefold():\n        inpunit = \"ns\"\n        group = \"time\"\n        if output.casefold() == \"fs\":\n            print(f\"{val} {inpunit} is {float(val)*1000000} fs\")\n        elif output.casefold() == \"ps\":\n            print(f\"{val} {inpunit} is {float(val)*1000} ps\")\n        elif output.casefold() == \"ns\":\n            print(f\"{val} {inpunit} is {float(val)*1} ns\")        \n    print(f\"Have a good day! &lt;3\")\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.data_2d","title":"<code>data_2d(path)</code>","text":"<p>Reads in a 2D data file. This ignores lines starting with #</p> Source code in <code>Tools/utils.py</code> <pre><code>def data_2d(path):\n    \"\"\"Reads in a 2D data file. This ignores lines starting with # \"\"\"\n    data0 = file_read(path)\n    data = []\n    for i in data0:\n        if \"#\" not in i:\n           data.append(i)\n        if \" 4000 \" in i: ### For cutting down to 2 ps of data\n            break\n    col1 = numpy.zeros(len(data))\n    col2 = numpy.zeros(len(data))\n    for i in range(len(data)):\n        words = data[i].split()\n        col1[i] = words[0]\n        col2[i] = words[1]\n    return col1, col2\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.dict_read","title":"<code>dict_read(path)</code>","text":"<p>Reads a json dictionary and returns as a variable</p> Source code in <code>Tools/utils.py</code> <pre><code>def dict_read(path):\n    \"\"\"Reads a json dictionary and returns as a variable\"\"\"\n    with open(path, \"r\") as f:\n        data = json.load(f)\n    return data\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.dict_write","title":"<code>dict_write(path, dict)</code>","text":"<p>Writes a dictionary to a json file</p> Source code in <code>Tools/utils.py</code> <pre><code>def dict_write(path, dict):\n    \"\"\"Writes a dictionary to a json file\"\"\"\n    with open(path,\"w\") as f:\n        json.dump(dict, f)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.file_2dwrite","title":"<code>file_2dwrite(path, x, y, delim='\\t')</code>","text":"<p>Writes a 2D array as a delimited file</p> Source code in <code>Tools/utils.py</code> <pre><code>def file_2dwrite(path, x, y, delim=\"\\t\"):\n    \"\"\"Writes a 2D array as a delimited file\"\"\"\n    assert len(x) == len(y), f\"Column 1 length is {len(x)} but column 2 length is{len(y)}. They need to be equal to work\"\n    with open(path, 'w') as f:\n        for i in range(len(x)):\n            print(f\"{x[i]}{delim}{y[i]}\", file=f)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.file_read","title":"<code>file_read(path)</code>","text":"<p>Reads in the file in the path as a 1D array of lines</p> Source code in <code>Tools/utils.py</code> <pre><code>def file_read(path):\n    \"\"\"Reads in the file in the path as a 1D array of lines\"\"\"\n    with open(path, 'r') as file:\n        data = file.readlines()\n    return data\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.file_write","title":"<code>file_write(path, lines)</code>","text":"<p>Writes a 1D array of lines to a file in the path</p> Source code in <code>Tools/utils.py</code> <pre><code>def file_write(path, lines):\n    \"\"\"Writes a 1D array of lines to a file in the path\"\"\"\n    with open(path, 'w') as f:\n        for i in lines:\n            print(i,file=f)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.get_cellVec","title":"<code>get_cellVec(MM)</code>","text":"<p>Gets the cell vectors required by NAMD from the AMBER param file</p> Source code in <code>Tools/utils.py</code> <pre><code>def get_cellVec(MM: MMClass):\n    \"\"\"Gets the cell vectors required by NAMD from the AMBER param file\"\"\"\n    data = file_read(f\"{globals.WorkDir}{MM.ambercoor}\")\n    length = len(data) #Get the last line\n    words = data[length-1].split() # Split the final line.\n    # print(words)\n    return float(words[0]) # return the first number\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.init_bins","title":"<code>init_bins(num, step, start)</code>","text":"<p>Calculates the bins and their values for umbrella sampling</p> Source code in <code>Tools/utils.py</code> <pre><code>def init_bins(num, step, start):\n    \"\"\"Calculates the bins and their values for umbrella sampling\"\"\"\n    bins = np.zeros(num)\n    bins_min = np.zeros(num)\n    bins_max = np.zeros(num)\n    for i in range(num):\n        bins[i] = round(start + step * i,2)\n    return bins\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.print_attributes","title":"<code>print_attributes(argdict)</code>","text":"Source code in <code>Tools/utils.py</code> <pre><code>def print_attributes(argdict: dict):\n    for i in argdict:\n        print(f\"--{i} ({type(argdict[i])}):\")\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.utils.slurm_gen","title":"<code>slurm_gen(JobName, SLURM, Job, path)</code>","text":"<p>Generates the slurm file that is used by HPC's.</p> Source code in <code>Tools/utils.py</code> <pre><code>def slurm_gen(JobName, SLURM, Job, path):\n    \"\"\"Generates the slurm file that is used by HPC's.\"\"\"\n    SoftwareLines = \"\"\n    for i in SLURM.Software:\n        SoftwareLines=SoftwareLines+\"\\n\"+i\n    if SLURM.ArrayJob != None:\n        slurmScript = f\"\"\"#!/bin/bash\n#SBATCH --job-name={JobName}\n#SBATCH --time={SLURM.WallTime}:00:00\n#SBATCH --nodes=1\n#SBATCH --ntasks-per-node={SLURM.Cores}\n#SBATCH --cpus-per-task=1\n#SBATCH --mincpus={SLURM.Cores}\n#SBATCH --array=1-{SLURM.ArrayLength}\n\n#SBATCH --partition={SLURM.Partition}\n{SLURM.account}\n{SLURM.qos}\n\n#SBATCH --get-user-env\n#SBATCH --parsable\n\n#dep\n\n{SLURM.dependency}\n\n{SoftwareLines}\n\nexport SRUN_CPUS_PER_TASK=$SLURM_CPUS_PER_TASK\nexport OMP_NUM_THREADS=1\nexport OMP_PLACES=cores\n\nexport ARRAY_JOBFILE=array_job.sh\nexport ARRAY_TASKFILE={JobName}.txt\nexport ARRAY_NTASKS=$(cat $ARRAY_TASKFILE | wc -l)\n\n\nsh $ARRAY_JOBFILE\n\"\"\"\n        file_write(f\"{path}sub.sh\", [slurmScript])\n        arrayfile = f\"\"\"#!/bin/bash\nRUNLINE=$(cat $ARRAY_TASKFILE | head -n $(($SLURM_ARRAY_TASK_ID*{SLURM.JobsPerNode})) | tail -n {SLURM.JobsPerNode})\neval \"$RUNLINE wait\"\n\n\"\"\"\n        file_write(f\"{path}array_job.sh\",[arrayfile])\n    else:\n        slurmScript = f\"\"\"#!/bin/bash\n#SBATCH --job-name={JobName}\n#SBATCH --time={SLURM.WallTime}\n#SBATCH --nodes=1\n#SBATCH --ntasks-per-node={SLURM.Cores}\n#SBATCH --cpus-per-task=1\n#SBATCH --mincpus={SLURM.Cores}\n\n#SBATCH --partition={SLURM.Partition}\n{SLURM.account}\n{SLURM.qos}\n\n#SBATCH --get-user-env\n#SBATCH --parsable\n\n{SLURM.dependency}\n\n{SoftwareLines}\n\nexport SRUN_CPUS_PER_TASK=$SLURM_CPUS_PER_TASK\nexport OMP_NUM_THREADS=1\nexport OMP_PLACES=cores\n\n{Job}\n\"\"\"\n        file_write(f\"{path}sub.sh\", [slurmScript])\n</code></pre>"},{"location":"Umbrella/Inputs/","title":"User Inputs","text":"<p>User inputs can either be provided by commandline variables, or through the use of one or two inputfiles. </p> <p>We recommend the use of two input files, on being the QM input file that should contain the information regarding the QM zone. The other being the Umbrella input file that will contain all other information. </p> <p>This is because the QM zone should never change, so you can generate this once and retain it for all steps. The other variables may change between stages of the calculation however and so it is useful to separate these out into a different file. </p> <p>You can however use only one input file as either file can read in all user variables. It is important to note however that the Umbrella input file overwrites the QM input file, and that both input files overwrite any parsed commandline variables. </p>"},{"location":"Umbrella/Inputs/#user-inputs_1","title":"User Inputs","text":"<p>The default inputs can be found and edited in <code>UserVars/Defaultinputs.py</code></p> <p>Here is a list of the main variables that can be changed: Default User Inputs<pre><code>### General               \n    \"WorkDir\" : \"./\",# str: relative or absolute path to calculation\n    \"Verbosity\" : 0, # int: 0=Errors, 1=Warnings, 2=Info, 3=Debug\n    \"DryRun\" : True, # bool: Whether to actually run calculations\n#### Calcuation\n    \"CoresPerJob\" : 10, # int: Number of CPU cores for the calc.\n    \"MemoryPerJob\" : 10, # int: Ammount of RAM for the calc.\n    \"MaxStepsPerCalc\" : 1000, # int: Maximum number of steps per calculation\n#### QM\n    \"QM\" : False, # bool: To select the use of qmmm, requires the use of a qm file. \n    \"QmFile\" : \"None\", # str:  Name of qm file containing qm parms. \n    \"QmSelection\" : \"resname CTN POP MG\", # str: vmd selection algebra for the QM region\n    \"QmCharge\" : 1, # int: Net charge of QM system\n    \"QmSpin\" : 0, # int: Spin state of QM system\n    \"QmMethod\" : \"PBE\", # str: ORCA QM method\n    \"QmBasis\" : \"6-31+G*\", # str: ORCA QM basis set.\n    \"QmArgs\" : \"MINIPRINT D3BJ TightSCF CFLOAT\", # str: extra information to parse to ORCA\n#### Umbrella\n    \"Stage\" : \"inpfile\", # str: Stage of calculation\n    \"UmbrellaFile\" : \"None\", # str: file containing qm information.\n    \"UmbrellaMin\" : 1.3, # float: Minimum Umbrella distance.\n    \"UmbrellaWidth\" : 0.05, # float: Width of the umbrella bin in either Ang or Deg.\n    \"UmbrellaBins\" : 54, # int: Number of Umbrella bins. \n    \"PullForce\" : 5000, # float: Force to pull the variables to each bin\n    \"ConstForce\" : 300, # float: Force to restrain the colvar during Umbrella simulations\n    \"StartDistance\" : 1.4, # float: Current value for the colvar (From the equilibrated MD)\n    \"StartFile\" : \"start.rst7\", # str: Amber or NAMD coordinates, start coordinates for THIS simulation.\n    \"ParmFile\" : \"complex.parm7\", # str: Amber parameter file. This must be in the root directory!\n    \"AtomMask\" : \"0,0,0,0\", # str: Atom mask for SMD, comma delimited string of atoms. \n    \"AnalysisFile\" : \"prod\", # str: Variable to perform analysis on (i.e. if you only want to visualise pull files, use pull_1)\n    \"EquilLength\" : 1, # int: Length of equil in ps. eg 1 ps = 2000 steps at 0.5 fs timestep\n    \"ProdLength\" : 4, # int: Length of production in ps. 4 ps = 8000 steps at 0.5 fs timestep\n</code></pre></p>"},{"location":"Umbrella/Inputs/#software-paths","title":"Software paths","text":"<p>Software paths should be set up before running any calculations and these can be found in <code>UserVars/SoftwarePaths.py</code></p> Example structure of UserVars/SoftwarePaths.py<pre><code>#### ORCA path\n\n    \"ORCA_PATH\" : \"/PATH_TO_ORCA/5.0.4/orca\" # str: Path to the orca executable\n\n#### NAMD paths\n\n    \"NAMD_CPU\" : \"/PATH_TO_NAMD/NAMD_3.0b4_Linux-x86_64-multicore/namd3\" # str: Path to the cpu version of NAMD for QMMM\n    \"NAMD_GPU\" : \"/PATH_TO_NAMD/NAMD_3.0b4_Linux-x86_64-multicore-CUDA/namd3\" # str: Path to the GPU version of NAMD for MD\n</code></pre>"},{"location":"Umbrella/pyBrellaSampling/","title":"pyBrellaSampling","text":"<p>Welcome to the automated umbrella sampling script called pyBrellaSampling</p> <p>This code is designed to assist in the setup and running of Umbrella sampling when using NAMD and ORCA.  Specifically it is designed to help with running QM/MM Umbrella sampling simulations with collective variables being: </p> <ul> <li>Bond formation/breaking</li> <li>Bond angle changes </li> <li>Bond dihedral changes</li> </ul> <p>It should be noted that some of the functionality has not been tested and usage of the code is at the end users risk! We recommend running with <code>DryRun=True</code> and checking the input files generated when initiating any new calculations. </p> <p>Feedback and issues can be raised on github or via email to <code>ross.amory98@gmail.com</code></p> <p>Follow the usage guide to perform your first Umbrella sampling calculation, or if your feeling brave, go through the source code.</p>"},{"location":"Umbrella/usage/","title":"Usage","text":""},{"location":"Umbrella/usage/#setup","title":"Setup","text":"<p>To run an umbrella calculation, you need two key files: </p> <ul> <li><code>Parameter file</code> (default = complex.parm7) Can be changed using <code>pyBrella --ParmFile PARM</code></li> <li><code>Coordinate file</code> (default = start.rst7) Can be changed using <code>pyBrella --StartFile COORD</code></li> </ul> <p>These two files, along with other user defined variables are all you need in order to perform Umbrella Sampling. </p> <p>Users are recommended to follow the workflow provided below.</p>"},{"location":"Umbrella/usage/#workflow","title":"Workflow","text":"<pre><code>graph TB\nsubgraph Local\n direction LR\n A[Setup] --&gt; B[Minimize]\n B --&gt; C[Heat]\n C --&gt; D[Pull]\n D --&gt; G[Check strcutures]\n G --&gt;|If wrong, fix| D\n end\n Local --&gt;|If correct| HPC\n subgraph HPC\n direction LR\n E[Equilibrate] --&gt; F[Production]\n end</code></pre>"},{"location":"Umbrella/usage/#setup_1","title":"Setup","text":"<p>The setup stage performs the setup script</p> <p>This generates the <code>syst-col.pdb</code> and <code>syst-qm.pdb</code> files.</p> <ul> <li><code>syst-col.pdb</code>  tells NAMD which atoms are involved in the sampling.</li> <li><code>syst-qm.pdb</code> tells NAMD which atoms are involved in the QM zone.</li> </ul>"},{"location":"Umbrella/usage/#important-variables","title":"Important variables:","text":"<pre><code>\"Stage\" : Setup\n\"QmSelection\" : The VMD selection algebra for the QM zone\n\"AtomMask\" : The atomic index of the atoms involved in Umbrella sampling. \n    - This should be comma delimited, and contain 4 numbers. \n        All unused numbers should be zero e.g if bond: 20,21,0,0\n</code></pre>"},{"location":"Umbrella/usage/#run","title":"Run:","text":"Running the setup<pre><code>pyBrella -stg setup -dr False \n</code></pre> Warning <p>At this point, check that your syst-qm.pdb file has been generated correctly. It is a common bug (depending on your version of vmd) to not generate the column containing elements. (The final column should be the atomic elements.) If this does not exist, edit the file around the QM zone, the elements should be in columns 77/78.</p>"},{"location":"Umbrella/usage/#minimisation","title":"Minimisation","text":"<p>This step minimizes your system using traditional MD. The minimisation code is used to perform this.</p>"},{"location":"Umbrella/usage/#important-variables_1","title":"Important variables:","text":"<pre><code>\"Stage\" : min\n</code></pre>"},{"location":"Umbrella/usage/#run_1","title":"Run:","text":"Running a minimization<pre><code>pyBrella -stg min -dr False # (1)\n</code></pre> <ol> <li>It is important that the GPU version of NAMD is loaded and that the path has been defined.</li> </ol>"},{"location":"Umbrella/usage/#heating","title":"Heating","text":"<p>At this step, we heat the system to 300 k over 20 ps using the heat code. </p>"},{"location":"Umbrella/usage/#important-variables_2","title":"Important variables:","text":"<pre><code>\"Stage\" : heat\n</code></pre>"},{"location":"Umbrella/usage/#run_2","title":"Run:","text":"Heating the system<pre><code>pyBrella -stg heat -dr False\n</code></pre> Warning <p>Now that the standard MD steps have been performed, you should remove the GPU version of NAMD from your path, and load in the CPU version. You should also ensure that the path to ORCA is correctly defined. QM/MM requires a CPU version of NAMD. </p> <p>You can also start the calculation at this point however need to ensure that your input is named heat_1.0.restart.coor and is in NAMD format.</p>"},{"location":"Umbrella/usage/#pull","title":"Pull","text":"<p>This is the stage where you initiate the umbrella windows/bins. This uses the pull code From this point on it is recommended to be using an input file for all steps of the simulation. </p> <p>You first need to analyze the heated structure, and obtain the atom index's for the collective variable.</p> <ul> <li><code>\"at1,at2,0,0\"</code> : Bond colvar between atom 1 and atom 2</li> <li><code>\"at1,at2,at3,0\"</code> : Angle colvar between atoms 1, 2 and 3</li> <li><code>\"at1,at2,at3,at4\"</code> : Dihedral colvar between atoms 1, 2, 3 and 4 </li> </ul>"},{"location":"Umbrella/usage/#important-variables_3","title":"Important variables:","text":"<pre><code>\"Stage\" : pull\n\"QmSelection\" : \"VMD selection algebra for qm region\"\n\"QmCharge\" : Net charge of QM region\n\"QmSpin\" : Spin of QM system\n\"QmMethod\" : QM functional\n\"QmBasis\" : QM basis set\n\"QmArgs\" : Dispersion corrections ect.\n\n\"UmbrellaMin\" : Value of bin 0\n\"UmbrellaWidth\" : Width between each bin (can be negative)\n\"UmbrellaBins\" : Number of bins\n\"PullForce\" : Force to pull atoms\n\"ConstForce\" : Force used during umbrella simulations\n\"StartDistance\" : Current value in the __heat_1.0.restart.coor__ file\n\"AtomMask\" : The mask for the collective variable (see above)\n</code></pre>"},{"location":"Umbrella/usage/#run_3","title":"Run:","text":"Tip <p>At this point, you can either run the calculation locally or on a HPC. If you have a fast computer (12 or more cores), it is recommended that you do this locally as the pulls occur in serial and only need around 10 threads. This also makes life faster when checking the generated structures as you do not need to move files between computers.</p> Umbrella.inp<pre><code>QmSelection=resname RES\nQmCharge=0\nQmSpin=1\nQmMethod=PBE\nQmBasis=6-31+G*\nQmArgs=MINIPRINT D3BJ TightSCF\nUmbrellaMin=1.3\nUmbrellaWidth=0.05 # (1)\nUmbrellaBins=50\nPullForce=5000 # (2)\nConstForce=300\nStartDistance=1.4\nAtomMask=12,13,0,0 # (3)\n</code></pre> <ol> <li>Small window gap gives better umbrella sampling results. As its a bond, units in Angstroms.</li> <li>Pull force should be large so that the bins are linearly spaced</li> <li>Bond collective variable between atoms 12 and 13</li> </ol> Generating windows<pre><code>pyBrella -stg pull -dr False -i Umbrella.inp\n</code></pre> Warning <p>At this point, you should ALWAYS check the generated structures. You can do this quickly by using the visualization script which is called using :</p> <pre><code>pyBrella -stg vis -dr False -af pull_1\n</code></pre> <p>This will open up the final structure from each window as a new frame in a single trajectory in vmd. You can then use vmd to plot the collective variable against frame to ensure a linear distribution and that the collective variables are at the correct value.</p>"},{"location":"Umbrella/usage/#equilibration","title":"Equilibration","text":"<p>Once the structures are all setup, it is recommended to move everything onto a HPC. This will dramatically speed up the future stages of the simulation and make the calculation possible within reasonable time scales. </p> <p>Ensure that you have correctly setup the pyBrellaSampling environment on the HPC as the default paths to software ect. will likely be different.</p> <p>Once on the HPC, using the same <code>Umbrella.inp</code> file as used previously, you can initiate the equilibration files.</p> Setting up equilibration<pre><code>pyBrella -stg equil -dr True -i Umbrella.inp\n</code></pre> <p>This should initialize the equilibration input files for each window, at this point it is recommended that you check at least one of the windows to make sure the software paths are correct.</p> <p>The command also generates some SLURM files:</p> <pre><code>sub.sh # (1)\narray_job.sh # (2)\nrunner.sh # (3)\nequil_1.txt # (4)\n</code></pre> <ol> <li>Blank SLURM submission file that is used as a template by runner.sh. You can also manually use this to sumbit your equil scripts.</li> <li>File used by SLURM to run the array file. You shouldn't need to edit this.</li> <li>File used to link and submit all simulations to SLURM with dependencies... This may or may not work so use with caution. Also it will likely max out your maximum queue allowance so will have to comment lines out and run multiple times. Good Luck! </li> <li>Text file with each line being a self-contained command to run each window in the umbrella sampling simulation. This is used by SLURM as the array file which runs each line as an independent simulation. There will be multiple of these if you have set MaxStepsPerCalc &gt; 0 and they MUST be run in order. </li> </ol>"},{"location":"Umbrella/usage/#production","title":"Production","text":"<p>Running the production stage of Umbrella sampling is identical to the equilibration stage. </p> <p>It requires the same <code>Umbrella.inp</code> file and should be performed on a HPC. </p> Setting up production<pre><code>pyBrella -stg prod -dr True -i Umbrella.inp\n</code></pre> <p>Like the equilibration stage, this will generate the <code>prod_X.txt</code> files that contain commands for running each step in the production run. Submit them in order otherwise they will break!</p>"},{"location":"Umbrella/usage/#wham","title":"Wham","text":"<p>You can perform a WHAM calculation at any stage after the windows are pulled. This is done through the WHAM code. This is not the best way to run a WHAM calculation however, and convergence is a more robust implementation of this method.</p> <p>You can run a WHAM calculation using:</p> performing WHAM on the prod_1 stage of calculations<pre><code>pyBrella -stg wham -dr False -af Prod_1\n</code></pre> <p>Warning</p> <p>Ensure wham.sh is in the $PATH otherwise this will not work! This can be found here</p> <p>This will generate a sub-directory called WHAM. Within this, it generates:</p> <ul> <li><code>AnalysisFile</code>metadata.dat : Contains the list of files containing colvar values</li> <li><code>AnalysisFile</code>UmbrellaHist.dat : produces a histogram of the distribution of colvar values (can be plotted in LaTex using Tikz)</li> <li>PMF.dat : File containing PMF information</li> <li>PMF.eps : EPS plot of the PMF</li> <li>plot_free_energy.dat : data that can be plotted using xmgrace</li> <li>wham.sh : script file that runs the wham calculation.</li> </ul>"},{"location":"Umbrella/usage/#convergence","title":"Convergence","text":"<p>This is the better way of running the WHAM calculation. It iterates through each of the sub-steps, in order for you to understand how well your calculation is converging.</p> <p>To run a convergence calculation, run:</p> Running a convergence calculation<pre><code>pyBrella -stg convergence -dr False -af prod\n</code></pre> <p>The Convergence calculation outputs files to WHAM/Conv. For each of the sub-steps, it calculates the PMF using all previous sub-steps and outputs these to:</p> <ul> <li><code>sub-step</code>.dat : Raw PMF data</li> <li><code>sub-step</code>.eps : Plot of PMF data</li> </ul> Advanced error checking <p>If you have a complex potential energy surface, sometimes umbrella bins fail during the umbrella sampling simulation through moving to a different area along the potential energy surface. This can be problematic as it often causes a sudden shift in the relative energies of that bin. We have implemented an error checking tool that uses extra input files (See below) to identify know problematic structures. Use at your own risk! </p> <pre><code>BondErrors.dat # (1)\nDihedralErrors.dat # (2)\n</code></pre> <ol> <li>File containing known bonds that form when they shouldn't. It requires 4 colummns: Name, Atom1, Atom2, Value. The name is a pseudonym to identify the bond, the two atom columns are the atomic index' of the atoms in the bond, and the value is the standard bond length. If this new bond is formed during a bin, the bin shall be excluded from the WHAM calculation.</li> <li>File containing known problematic dihedral angles. tval1 is the acceptable dihedral angle, t2val is the problematic value. If the dihedral is closer to the problematic value then the bin will be ignored.</li> </ol> <p>BondErrors.dat</p> Name Atom1 Atom2 Value pseudonym index of atom1 index of atom2 Value that classes the bond as formed <p>DihedralErrors.dat </p> Name Atom1 Atom2 Atom3 Atom4 t1name t1val t2name t2val pseudonym index of atom1 index of atom2 index of atom3 index of atom4 pseudonym of accepted dihedral Accepted value pseudonym of problematic dihedral problematic value"},{"location":"Umbrella/usage/#analysis","title":"Analysis","text":"<p>Using further configuration files, you can also perform analysis and track other variables of the system throughout the simulation. This uses the analysis code and reads in data files to configure states to track. (See below)</p> Running analysis<pre><code>pyBrella -stg analysis -dr False\n</code></pre> <p>Bonds.dat</p> Name Atom1 Atom2 Value pseudonym index of atom1 index of atom2 Standard bond length <p>Dihedrals.dat </p> Name Atom1 Atom2 Atom3 Atom4 t1name t1val t2name t2val pseudonym index of atom1 index of atom2 index of atom3 index of atom4 pseudonym of state 1 central value pseudonym of state 2 central value <p>This code goes through the simulation trajectories, and tracks the states of the bonds and dihedrals provided. It then plots them as histogram plots to show the overall distribution of the bonds and dihedrals. It also generates 2D histograms to plot the distribution of bonds and dihedrals against the target colvar.</p>"},{"location":"coverage/","title":"Testing","text":""}]}
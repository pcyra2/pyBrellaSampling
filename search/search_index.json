{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to pyBrellaSampling WIKI","text":"<p>To access the source code, visit github.</p> <p>This is the wiki for all things pyBrellaSampling. The code is developed and maintained by Ross Amory at the University of Nottingham as part of a BBSRC sponsored PhD. </p>"},{"location":"#overview","title":"Overview","text":"<p>pyBrellaSampling can be grouped into 3 major components. Primarily it is a tool to help with the automation of QM/MM umbrella sampling and is called through the <code>pyBrella</code> command. This is due to the complexity of setting up these calculations and the lack of automatic tools that work with HPC systems.</p> <p>The code can however be used to run standalone MD and QM/MM simulations through the <code>Standalone</code> command. This was due to the backend of this process already being implemented for the Umbrella sampling code, and so adapting new functionality was relatively simple. </p> <p>Finally the code can be used to perform a QM benchmark in order to help chose which QM method to use when performing QM/MM umbrella sampling. It is called using the <code>Benchmark</code> command. Again there are few tools that exist that automate the process of performing a wide scope QM benchmark. </p>"},{"location":"setup/","title":"Installation process","text":""},{"location":"setup/#install","title":"Install","text":"<p>To install pyBrellaSampling, first clone the repo into a directory:</p> <pre><code>gh repo clone pcyra2/pyBrellaSampling\n</code></pre> <p>Then move some script files out of the source directory: <pre><code>cp pyBrellaSampling/setup.py .\ncp pyBrellaSampling/requirements.txt .\n</code></pre></p> <p>Next create the conda environment:</p> <pre><code>conda create -n pyBrellaSampling --file requirements.txt -c conda-forge\nconda activate pyBrellaSampling\n</code></pre> <p>Finally install the environment:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"setup/#configure","title":"Configure","text":"<p>It is important now to configure the default variables!  Go into the UserVars directory within the source.</p> <pre><code>cd pyBrellaSampling/UserVars\n</code></pre> <p>Here you MUST edit the HPC_Config.py and SoftwarePaths.py files.</p> <p>The <code>HPC_Config</code> file needs configuring so that your HPC variables like QoS are configured correctly. This allows for SLURM scripts to be generated correctly.</p> HPC_Config.py<pre><code>HPC_Config = {\n    \"None\" : {\n        \"HostName\" : \"\", # str: Hostname of the HPC\n        \"MaxWallTime\" : 0, # int: Maximum calculation time in hours\n        \"Partition\" : \"None\", # str: Partition to run calc on.\n        \"MaxCores\" : 0, # Maximum number of cores per node \n        \"QualityofService\" : \"None\", # str: Account QoS or None if not needed\n        \"Account\" : \"None\", # str: SLURM account or None if not needed\n        \"SoftwareLines\" : [\"\",], # list: List of lines required to set up environment\n    },\n    \"sulis\" : {\n        \"HostName\" : \"login01.sulis.hpc\", # str: Hostname of the HPC\n        \"MaxWallTime\" : 48, # int: Maximum calculation time in hours\n        \"Partition\" : \"compute\", # str: Partition to run calc on.\n        \"MaxCores\" : 128, # Maximum number of cores per node \n        \"QualityofService\" : \"None\", # str: Account QoS or None if not needed\n        \"Account\" : \"su120\", # str: SLURM account or None if not needed\n        \"SoftwareLines\" : [\"module load GCC/11.2.0\", \n                           \"module load OpenMPI/4.1.1\", \n                           \"module load ORCA/5.0.4\"], # list: List of lines required to set up environment\n    },\n}\n</code></pre> <p>The <code>SoftwarePaths</code> file needs the absolute paths of the ORCA executable, and CPU and GPU version of NAMD in order to run. </p> SoftwarePaths.py<pre><code># ORCA path\nORCA_PATH = \"/home/pcyra2/Software/ORCA/5.0.4/orca\" \n\n#NAMD paths\nNAMD_CPU = \"/home/pcyra2/Software/NAMD/NAMD_3.0b4_Linux-x86_64-multicore/namd3\"\n\nNAMD_GPU = \"/home/pcyra2/Software/NAMD/NAMD_3.0b4_Linux-x86_64-multicore-CUDA/namd3\"\n</code></pre> Other configs. <p>Here you can also edit the other files in the directory. This allows you to:</p> <pre><code>- Tune your MD parameters (MM_Variables.py)  \n- List available QM methods to ORCA for benchmarking (QM_Methods.py)\n- Change the Default inputs for each calculation type (if you always use the same QM method for example.) (Defaultinputs.py)\n</code></pre>"},{"location":"Standalone/CodeReference/","title":"Standalone","text":""},{"location":"Standalone/CodeReference/#pyBrellaSampling.Standalone.main","title":"<code>pyBrellaSampling.Standalone.main()</code>","text":"Source code in <code>Standalone.py</code> <pre><code>def main():\n    starttime = time.time()\n    args = input.StandaloneInput(sys.argv[1:],)\n    verbosity = args[\"Verbosity\"]\n    WorkDir = args[\"WorkDir\"]\n    dr = args[\"DryRun\"]\n    if dr == \"True\" or dr == True:\n        DryRun = True\n    elif dr == \"False\" or dr == False:\n        DryRun = False\n    parmfile = args[\"ParmFile\"]\n    assert path.isfile(f\"{WorkDir}{parmfile}\"), f\"ERROR: {parmfile} does not exist in the working directory!\"\n    globals.init(v=verbosity,wd=WorkDir,dr=DryRun, parm=parmfile)\n    Calc, MM, QM = calc_setup(args)\n    if globals.DryRun == False:\n        calc_run(Calc=Calc, MM=MM, QM=QM, )\n    endtime = time.time()\n    print(f\"Total time is {endtime - starttime}\")\n</code></pre>"},{"location":"Standalone/CodeReference/#pyBrellaSampling.Tools.InputParser.StandaloneInput","title":"<code>pyBrellaSampling.Tools.InputParser.StandaloneInput(sysargs)</code>","text":"<p>Controls the inputs of a standalone calculation. </p> <p>Parameters:</p> Name Type Description Default <code>sysargs</code> <code>list</code> <p>CLI inputs (see attributes)</p> required <p>Attributes:</p> Name Type Description <code>--WorkDir</code> <code>str</code> <p>Working Directory</p> <code>--Verbosity</code> <code>int</code> <p>Verbosity: 0 = none, 1 = info</p> <code>--DryRun</code> <code>str</code> <p>Indicates whether programs are executed or not</p> <code>--CoresPerJob</code> <code>int</code> <p>Number of cores per individual calculation</p> <code>--MemoryPerJob</code> <code>int</code> <p>Gb of memory per individual calculation</p> <code>--MDCPUPath</code> <code>str</code> <p>Path to NAMD CPU executable</p> <code>--MDGPUPath</code> <code>str</code> <p>Path to NAMD GPU executable</p> <code>--QmFile</code> <code>str</code> <p>Name of file containing QM information.</p> <code>--QmPath</code> <code>str</code> <p>Path to QM software</p> <code>--QmSelection</code> <code>str</code> <p>Selection algebra for QM atoms</p> <code>--QmCharge</code> <code>int</code> <p>Charge of QM region</p> <code>--QmSpin</code> <code>int</code> <p>Spin of QM region</p> <code>--QmMethod</code> <code>str</code> <p>Qm method</p> <code>--QmBasis</code> <code>str</code> <p>QM basis set</p> <code>--QmArgs</code> <code>str</code> <p>Extra arguments for ORCA calculation</p> <code>--HPC</code> <code>bool</code> <p>Whether to run on a HPC</p> <code>--MaxWallTime</code> <code>int</code> <p>Maximum wall time (Hours) for your jobs (either leave as node max, or set as job length)</p> <code>--HostName</code> <code>str</code> <p>HostName of the HPC</p> <code>--Partition</code> <code>str</code> <p>Calculation partition name</p> <code>--MaxCores</code> <code>int</code> <p>Maximum number of cores available to a node (For array splitting)</p> <code>--QualityofService</code> <code>str</code> <p>Slurm QoS, set to None if not relevant.</p> <code>--Account</code> <code>str</code> <p>Slurm account, (Not username), Set to None if not relevant</p> <code>--SoftwareLines</code> <code>list</code> <p>List of commands like \"module load XXX\" to load software. Keep each line surrounded by quotes.</p> <code>--MMFile</code> <code>str</code> <p>Name of input file containing MD information</p> <code>--Name</code> <code>str</code> <p>Name for the calculation</p> <code>--Ensemble</code> <code>str</code> <p>Ensemble for Calculation</p> <code>--QM</code> <code>bool</code> <p>Whether this is a QMMM calculation or not.</p> <code>--Steps</code> <code>int</code> <p>Number of simulation steps.</p> <code>--TimeStep</code> <code>float</code> <p>Time step for the simulation. We recommend 2 for MM, 0.5 for QMMM</p> <code>--ParmFile</code> <code>str</code> <p>Parameter file name</p> <code>--AmberCoordinates</code> <code>str</code> <p>Amber coordinate file name that relates to the parameter file</p> <code>--StartFile</code> <code>str</code> <p>Either Amber coordinates or NAMD coordinates. These are the coordinates that it starts from.</p> <code>--RestartOut</code> <code>int</code> <p>Frequency to generate a restart file</p> <code>--TrajOut</code> <code>int</code> <p>Frequency to add to the trajectory file</p> <code>--SMD</code> <code>bool</code> <p>Whether to use steered molecular dynamics</p> <code>--Force</code> <code>int</code> <p>Force for Steered MD</p> <code>--StartValue</code> <code>int</code> <p>Start value for SMD</p> <code>--EndValue</code> <code>int</code> <p>End value for SMD. MAKE == Start if wanting constant.</p> <code>--AtomMask</code> <code>str</code> <p>Mask for the restrained atoms.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown variable is parsed</p> <p>Returns:</p> Name Type Description <code>arg_dict</code> <code>dict</code> <p>Dictionary of user variables.</p> Source code in <code>Tools/InputParser.py</code> <pre><code>def StandaloneInput(sysargs: list):\n    \"\"\"\n    Controls the inputs of a standalone calculation. \n\n    Args:\n        sysargs (list): CLI inputs (see attributes)\n\n    Attributes:\n        --WorkDir (str): Working Directory\n        --Verbosity (int): Verbosity: 0 = none, 1 = info\n        --DryRun (str):  Indicates whether programs are executed or not\n        --CoresPerJob (int): Number of cores per individual calculation\n        --MemoryPerJob (int): Gb of memory per individual calculation\n        --MDCPUPath (str): Path to NAMD CPU executable\n        --MDGPUPath (str): Path to NAMD GPU executable\n        --QmFile (str): Name of file containing QM information.\n        --QmPath (str): Path to QM software\n        --QmSelection (str): Selection algebra for QM atoms\n        --QmCharge (int): Charge of QM region\n        --QmSpin (int): Spin of QM region\n        --QmMethod (str): Qm method\n        --QmBasis (str): QM basis set\n        --QmArgs (str): Extra arguments for ORCA calculation\n        --HPC (bool): Whether to run on a HPC\n        --MaxWallTime (int): Maximum wall time (Hours) for your jobs (either leave as node max, or set as job length)\n        --HostName (str): HostName of the HPC\n        --Partition (str): Calculation partition name\n        --MaxCores (int): Maximum number of cores available to a node (For array splitting)\n        --QualityofService (str): Slurm QoS, set to None if not relevant.\n        --Account (str): Slurm account, (Not username), Set to None if not relevant\n        --SoftwareLines (list): List of commands like \"module load XXX\" to load software. Keep each line surrounded by quotes.\n        --MMFile (str): Name of input file containing MD information\n        --Name (str): Name for the calculation\n        --Ensemble (str): Ensemble for Calculation\n        --QM (bool): Whether this is a QMMM calculation or not.\n        --Steps (int): Number of simulation steps.\n        --TimeStep (float): Time step for the simulation. We recommend 2 for MM, 0.5 for QMMM\n        --ParmFile (str): Parameter file name\n        --AmberCoordinates (str): Amber coordinate file name that relates to the parameter file\n        --StartFile (str): Either Amber coordinates or NAMD coordinates. These are the coordinates that it starts from.\n        --RestartOut (int): Frequency to generate a restart file\n        --TrajOut (int): Frequency to add to the trajectory file\n        --SMD (bool): Whether to use steered molecular dynamics\n        --Force (int): Force for Steered MD\n        --StartValue (int): Start value for SMD\n        --EndValue (int): End value for SMD. MAKE == Start if wanting constant.\n        --AtomMask (str): Mask for the restrained atoms.\n\n    Raises:\n        ValueError: If an unknown variable is parsed\n\n    Returns:\n        arg_dict (dict): Dictionary of user variables. \n    \"\"\"\n    HPC = \"None\"\n    HostName = socket.gethostname()\n    for alias, data in HPC_Config.items():\n        if HostName == data[\"HostName\"]:\n            HPC = alias\n            continue\n    defaults = UserVars.Standalone_Inp\n    HPC_Conf = HPC_Config[HPC]\n    parser = argparse.ArgumentParser(description=f\"\"\"Commandline arguments. This method of calculation input is being deprecated. Please do not use.\nIt is recommended to use -jt inpfile to generate input file templates with default values that you can then edit.\"\"\")\n    ### Core Job arguments\n    Core = parser.add_argument_group(\"Core Job Arguments\")\n    Core.add_argument('-wd', '--WorkDir', type=str,\n                        help=\"Home location for the calculations\", default=defaults[\"WorkDir\"])\n    Core.add_argument('-v', '--Verbosity', type=int,\n                        help=\"Verbosity: 0 = none, 1 = info\", default=defaults[\"Verbosity\"])\n    Core.add_argument('-dr', '--DryRun', type=str,\n                        help=\"Indicates whether programs are executed or not\", default=defaults[\"DryRun\"])\n\n    Compute = parser.add_argument_group(\"Compute Arguments\")\n    ### Compute Arguments\n    Compute.add_argument('-c', '--CoresPerJob', type=int,\n                        help=\"Number of cores per individual calculation\", default=defaults[\"CoresPerJob\"])\n    Compute.add_argument('-m','--MemoryPerJob', type=int,\n                        help=\"Gb of memory per individual calculation\", default=defaults[\"MemoryPerJob\"])\n\n    ### MM Arguments\n    MM = parser.add_argument_group(\"Molecular Dynamics Arguments\")\n    MM.add_argument('-MDcpu', '--MDCPUPath', type=str,\n                        help=\"Path to NAMD CPU executable\", default=NAMD_CPU)\n    MM.add_argument('-MDgpu', '--MDGPUPath', type=str,\n                        help=\"Path to NAMD GPU executable\", default=NAMD_GPU)\n\n    ### QM Arguments\n    QM = parser.add_argument_group(\"QM Arguments\")\n    QM.add_argument(\"-qf\", \"--QmFile\", type=str, default=defaults[\"QmFile\"],\n                    help=\"Name of file containing QM information.\")\n    QM.add_argument('-qp', '--QmPath', type=str,\n                        help=\"Path to QM software\", default=ORCA_PATH)\n    QM.add_argument('-qsel', '--QmSelection', type=str,\n                        help=\"Selection algebra for QM atoms\", default=defaults[\"QmSelection\"])\n    QM.add_argument('-qc', '--QmCharge', type=int,\n                        help=\"Charge of QM region\", default=defaults[\"QmCharge\"])\n    QM.add_argument('-qspin', '--QmSpin', type=int,\n                        help=\"Spin of QM region\", default=defaults[\"QmSpin\"])\n    QM.add_argument('-qm', '--QmMethod', type=str,\n                        help=\"Qm method\", default=defaults[\"QmMethod\"])\n    QM.add_argument('-qb', '--QmBasis', type=str,\n                        help=\"QM basis set\", default=defaults[\"QmBasis\"])\n    QM.add_argument('-qargs', '--QmArgs', type=str, \n                    help=\"Extra arguments for ORCA calculation\", default=defaults[\"QmArgs\"])\n\n    ### HPC Arguments\n    HPC = parser.add_argument_group(\"HPC/SLURM arguments\")\n    HPC.add_argument(\"--HPC\", type=bool, default=defaults[\"HPC\"], help=\"Whether to run on a HPC\")\n    HPC.add_argument(\"-MaxTime\", \"--MaxWallTime\", type=int,\n                     help=\"Maximum wall time (Hours) for your jobs (either leave as node max, or set as job length)\",\n                     default=HPC_Conf[\"MaxWallTime\"])\n    HPC.add_argument(\"-Host\", \"--HostName\", type=str,\n                     help=\"HostName of the HPC\", default=HPC_Conf[\"HostName\"])\n    HPC.add_argument(\"--Partition\", type=str, help=\"Calculation partition name\",\n                     default=HPC_Conf[\"Partition\"])\n    HPC.add_argument(\"--MaxCores\", type=int,\n                     help=\"Maximum number of cores available to a node (For array splitting)\", default=HPC_Conf[\"MaxCores\"])\n    HPC.add_argument(\"-QoS\", \"--QualityofService\", type=str,\n                     help=\"Slurm QoS, set to None if not relevant.\", default=HPC_Conf[\"QualityofService\"])\n    HPC.add_argument(\"--Account\", type=str,\n                     help=\"Slurm account, (Not username), Set to None if not relevant\", default=HPC_Conf[\"Account\"])\n    HPC.add_argument(\"-Software\", \"--SoftwareLines\", type=str,\n                    help=\"List of commands like \\\"module load XXX\\\" to load software. Keep each line surrounded by quotes.\",\n                    default=HPC_Conf[\"SoftwareLines\"], nargs=\"*\")\n\n    Standalone = parser.add_argument_group(\"Standalone Job arguments\")\n    Standalone.add_argument(\"-i\", \"--MMFile\", type=str, default=defaults[\"MMFile\"],\n                            help=\"Name of input file containing MD information\")\n    Standalone.add_argument(\"--Name\", type=str,\n                            default=defaults[\"Name\"], help=\"Name for the calculation\")\n    Standalone.add_argument(\"--Ensemble\", type=str,\n                            choices=[\"min\", \"heat\", \"NVT\", \"NPT\"],\n                            help=\"Ensemble for Calculation\", default=defaults[\"Ensemble\"])\n    Standalone.add_argument(\"--QM\", type=str, choices=[\"True\", \"False\"],\n                            default=defaults[\"QM\"], help=\"Whether this is a QMMM calculation or not.\")\n    Standalone.add_argument(\"-st\", \"--Steps\", type=int,\n                            default=defaults[\"Steps\"], help=\"Number of simulation steps.\")\n    Standalone.add_argument(\"-dt\", \"--TimeStep\", type=float,\n                            default=float(defaults[\"TimeStep\"]), help=\"Time step for the simulation. We recommend 2 for MM, 0.5 for QMMM\")\n    Standalone.add_argument(\"--ParmFile\", type=str,\n                            default=defaults[\"ParmFile\"], help=\"Parameter file name\")\n    Standalone.add_argument(\"--AmberCoordinates\", type=str,\n                            default=defaults[\"AmberCoordinates\"], help=\"Amber coordinate file name that relates to the parameter file\")\n    Standalone.add_argument(\"--StartFile\", type=str, default=defaults[\"StartFile\"], \n                            help=\"Either Amber coordinates or NAMD coordinates. These are the coordinates that it starts from.\")\n    Standalone.add_argument(\"--RestartOut\", type=int, default=defaults[\"RestartOut\"], \n                            help=\"Frequency to generate a restart file\")\n    Standalone.add_argument(\"--TrajOut\", type=int, default=defaults[\"TrajOut\"], \n                            help=\"Frequency to add to the trajectory file\")\n    Standalone.add_argument(\"--SMD\", type=str, choices=[\"True\", \"False\"], default=defaults[\"SMD\"], \n                            help=\"Wheter to use steered molecular dynamics\")\n    Standalone.add_argument(\"--Force\", type=float, default=defaults[\"Force\"], \n                            help=\"Force for Steered MD\")\n    Standalone.add_argument(\"--StartValue\", type=float, default=defaults[\"StartValue\"], \n                            help=\"Start value for SMD\")\n    Standalone.add_argument(\"--EndValue\", type=float, default=defaults[\"EndValue\"], \n                            help=\"End value for SMD. MAKE == Start if wanting constant.\")\n    Standalone.add_argument('-mask', '--AtomMask', type=str,\n                        help=\"Mask for the restrained atoms.\", default=defaults[\"AtomMask\"])\n    args = parser.parse_args(sysargs)\n    arg_dict = vars(args)\n    workdir = arg_dict[\"WorkDir\"]\n    qmfile = arg_dict[\"QmFile\"]\n    mmfile = arg_dict[\"MMFile\"]\n    # print(arg_dict[\"DryRun\"])\n    if arg_dict[\"QmFile\"] != \"None\":\n        qm_input = utils.file_read(f\"{workdir}{qmfile}\")\n        for i in qm_input:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\") # removes random spaces.\n            val = val.replace(\"\\n\",\"\") # removes newline errors/\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {qmfile}\")\n    if arg_dict[\"MMFile\"] != \"None\":\n        mm_input = utils.file_read(f\"{workdir}{mmfile}\")\n        for i in mm_input:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\")\n            val = val.replace(\"\\n\",\"\")\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {mmfile}\")\n    # utils.print_attributes(arg_dict) # Prints out all vars for use in docstring generation\n    return arg_dict\n</code></pre>"},{"location":"Standalone/CodeReference/#pyBrellaSampling.Standalone.Class_init","title":"<code>pyBrellaSampling.Standalone.Class_init(args)</code>","text":"<p>Initialises some of the main classes used by the calculation. </p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>dict</code> <p>User defined variables.</p> required <p>Returns:</p> Name Type Description <code>Calc</code> <code>CalcClass</code> <p>Generic calculation info</p> <code>MM</code> <code>MMClass</code> <p>MM Variables</p> <code>QM</code> <code>QMClas</code> <p>QM variables, if == False : No QMMM</p> <code>Umbrella</code> <code>UmbrellaClass</code> <p>Umbrella variables for restraint information.</p> Source code in <code>Standalone.py</code> <pre><code>def Class_init(args: dict):\n    \"\"\"Initialises some of the main classes used by the calculation. \n\n    Args:\n        args (dict): User defined variables.\n\n    Returns:\n        Calc (CalcClass): Generic calculation info\n        MM (MMClass): MM Variables\n        QM (QMClas): QM variables, if == False : No QMMM\n        Umbrella (UmbrellaClass): Umbrella variables for restraint information.\n    \"\"\"\n    Calc = CalcClass(args=args)\n    MM = MMClass()\n    Calc.Job_Name(Name=args[\"Name\"])\n    Calc.Set_OutFile(OutFile=args[\"Name\"])\n    Calc.Set_Id(0)\n    MM.Set_Length(Steps=args[\"Steps\"], TimeStep=args[\"TimeStep\"])\n    MM.Set_Ensemble(Ensemble=args[\"Ensemble\"])\n    MM.Set_Files(parm=args[\"ParmFile\"], ambercoor=args[\"AmberCoordinates\"])\n    MM.Set_Outputs(TimeOut=args[\"TrajOut\"], RestOut=args[\"RestartOut\"], \n                   TrajOut=args[\"TrajOut\"]) ### Output timings when trajectory is printed.\n    args[\"PullForce\"] = args[\"Force\"]\n    args[\"ConstForce\"] = args[\"Force\"]\n    Umbrella = UmbrellaClass(args, Min=float(args[\"StartValue\"]), bins=0,\n                            Start=float(args[\"StartValue\"]),\n                            Width=(float(args[\"EndValue\"]) - float(args[\"StartValue\"])))\n    Umbrella.add_start(0)\n    Umbrella.set_force(args[\"Force\"])\n    Umbrella.add_bins([str(args[\"EndValue\"])])\n    bincoor = args[\"StartFile\"]\n    if bincoor == \"None\" or bincoor == \"\" or bincoor == MM.ambercoor:\n                bincoor = None\n    if \".ncrst\" in str(bincoor) or \".rst7\" in str(bincoor):\n        print(\"WARNING: Your Binary Coordinates look like amber coordinates... They should be NAMD coodinates (.coor). This may cause issues...\\n\" if globals.verbosity &gt;= 1 else \"\", end=\"\")\n    if args[\"QM\"] == True or args[\"QM\"] == \"True\":\n        print(\"INFO: Running a QMMM calculation \\n\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n        QM = QMClass(args=args)\n        QM.set_selfile(\"syst-qm.pdb\")\n    else:\n        QM = False\n    if MM.TimeStep &gt; 1:\n        print(\"WARNING: TimeStep is greater than 1 fs. Setting Rattle to True\\n\" if globals.verbosity &gt;=1 else \"\", end=\"\")\n        MM.Set_Shake(\"all\")\n    NAMD = NAMDClass(Calc=Calc, MM=MM)\n    return Calc, MM, QM, Umbrella, NAMD\n</code></pre>"},{"location":"Standalone/CodeReference/#pyBrellaSampling.Standalone.calc_setup","title":"<code>pyBrellaSampling.Standalone.calc_setup(args)</code>","text":"<p>Generates the input file, including any syst-*.pdb files.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>dict</code> <p>User defined variables</p> required <p>Returns:</p> Name Type Description <code>Calc</code> <code>CalcClass</code> <p>Calculation variables</p> <code>MM</code> <code>MMClass</code> <p>Required for knowing how to run the calculation (With or without GPU ect. )</p> <code>QM</code> <code>QMClass</code> <p>Again required for knowing how to run the calculation.</p> Source code in <code>Standalone.py</code> <pre><code>def calc_setup(args: dict):\n    \"\"\"\n    Generates the input file, including any syst-*.pdb files.\n\n    Args:\n        args (dict): User defined variables\n\n    Returns:\n        Calc (CalcClass): Calculation variables\n        MM (MMClass): Required for knowing how to run the calculation (With or without GPU ect. )\n        QM (QMClass): Again required for knowing how to run the calculation.\n    \"\"\"\n    Calc, MM, QM, Umbrella, NAMD = Class_init(args) # inits classes\n    MM.CellVec = utils.get_cellVec(MM) # Obtains the cell vectors from the parm file. \n    NAMD.set_cellvectors(MM.CellVec)\n    NAMD.set_startcoords(args[\"StartFile\"], ambercoor=MM.ambercoor, parm=MM.parmfile)\n    if QM != False:\n        print(\"INFO: Setting up a QMMM calculation\\n\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n        NAMD.set_qm(Calc=Calc, QM=QM, index=\"QMMM\")\n        utils.QM_Gen(QM.QMSel, globals.WorkDir)\n        if globals.DryRun == False:\n            print(\"INFO: Setting up the QM pdb file.\\n\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n            logfile = subprocess.run([\"vmd\", \"-dispdev\", \"text\", \"-e\", \"qm_prep.tcl\"],\n                                     text = True, capture_output = True) # Generates sys-qm.pdb using vmd\n            with open(f\"{globals.WorkDir}tcl-qm.log\",\"w\") as f:\n                print(logfile, file=f)\n    else:\n        NAMD.set_pme(\"on\")\n        # pass\n    if args[\"SMD\"].casefold() == \"true\":\n        print(f\"WARNING: SMD method is currently untested... \" if globals.verbosity &gt;=1 else \"\", end=\"\")\n        NAMD = init_SMD(NAMD=NAMD,Umbrella=Umbrella )\n        utils.ColVarPDB_Gen(Umbrella)\n        if globals.DryRun == False:\n            print(\"INFO: Setting up the Colvar pdb file.\\n\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n            logfile = subprocess.run([\"vmd\", \"-dispdev\", \"text\", \"-e\", \"Colvar_prep.tcl\"],\n                                     text = True, capture_output = True) # Generates sys-col.pdb using vmd. \n            with open(f\"{globals.WorkDir}tcl-colvar.log\",\"w\") as f:\n                print(logfile, file=f)\n    print(\"INFO: Setting up the conf file\\n\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n    file = FileGen.Namd_File(NAMD)\n    utils.file_write(f\"{globals.WorkDir}{Calc.Name}.conf\", [file]) # Outputs the calculation file for namd. \n    return Calc, MM, QM\n</code></pre>"},{"location":"Standalone/CodeReference/#pyBrellaSampling.Standalone.calc_run","title":"<code>pyBrellaSampling.Standalone.calc_run(Calc, MM, QM)</code>","text":"<p>Handles the running of the calculations. Choosing the right version of NAMD Args:     Calc (CalcClass): Gets the name of the calculation     MM (MMClass): Gets the path to executables     QM (QMClass): Gets wheter to use the GPU.</p> Source code in <code>Standalone.py</code> <pre><code>def calc_run(Calc: CalcClass, MM: MMClass, QM: QMClass):\n    \"\"\"\n    Handles the running of the calculations. Choosing the right version of NAMD\n    Args:\n        Calc (CalcClass): Gets the name of the calculation\n        MM (MMClass): Gets the path to executables\n        QM (QMClass): Gets wheter to use the GPU.\n\n    \"\"\"\n    print(f\"INFO: Running the {Calc.Name} Calculation.\\n\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n    if  QM == False:\n        print(f\"INFO: {MM.GPUNamd} +oneWthPerCore +setcpuaffinity +devices 0 +cs {globals.WorkDir}{Calc.Name}.conf &gt; {globals.WorkDir}{Calc.Name}_1.0.out\\n\" \n              if globals.verbosity &gt;=2 else \"\", end=\"\")\n        subprocess.run([MM.GPUNamd +\n                        f\" +oneWthPerCore +setcpuaffinity +devices 0 +cs {globals.WorkDir}{Calc.Name}.conf &gt; {globals.WorkDir}{Calc.Name}_1.0.out\"],\n                       shell=True, capture_output=True)\n    else:\n        subprocess.run([\"mkdir /dev/shm/NAMD_QMMM\"], shell=True)\n        subprocess.run([MM.CPUNamd +\n                        f\" +p1 {globals.WorkDir}{Calc.Name}.conf &gt; {globals.WorkDir}{Calc.Name}_1.0.out\"],\n                       shell=True, capture_output=True)\n        subprocess.run([\"rm -r /dev/shm/NAMD_QMMM\"], shell=True)\n</code></pre>"},{"location":"Standalone/Examples/","title":"Some example input files","text":""},{"location":"Standalone/Examples/#minimsation","title":"Minimsation","text":""},{"location":"Standalone/Examples/#heat","title":"Heat","text":""},{"location":"Standalone/Examples/#setup","title":"Setup:","text":""},{"location":"Standalone/Examples/#pre-requisit-files","title":"Pre-requisit files:","text":"<ul> <li>min_1.0.restart.coor</li> <li>start.rst7</li> <li>complex.parm7</li> </ul>"},{"location":"Standalone/Examples/#input-file-heatinp","title":"Input file: (heat.inp)","text":"<pre><code># Heat file, heats to 300 k over 300 ps.\nStartFile=min_1.0.restart.coor\nEnsemble=heat\nSteps=150000\nDryRun=False\nName=heat\nRestartOut=100\nTrajOut=500 # Generates 300 trajectory frames\n</code></pre>"},{"location":"Standalone/Examples/#run","title":"Run:","text":""},{"location":"Standalone/Examples/#command","title":"Command:","text":"<p><code>Standalone -i heat.inp</code></p>"},{"location":"Standalone/Examples/#outputs","title":"Outputs:","text":"<ul> <li>heat_1.0.out</li> <li>heat_1.0.coor</li> <li>heat_1.0.dcd</li> <li>heat_1.0.out</li> <li>heat_1.0.restart.coor</li> <li>heat_1.0.restart.vel</li> <li>heat_1.0.restart.xsc</li> <li>heat_1.0.vel</li> <li>heat_1.0.xsc</li> <li>heat.conf</li> </ul>"},{"location":"Standalone/Examples/#equilibration","title":"Equilibration","text":""},{"location":"Standalone/usage/","title":"Usage","text":""},{"location":"Standalone/usage/#setup","title":"Setup","text":"<p>To run a standalone simulation, you need some key initial files:</p> <ul> <li><code>Parameter file</code> (default = complex.parm7) Can be changed using <code>pyBrella --ParmFile PARM</code></li> <li><code>Coordinate file</code> (default = start.rst7) Can be changed using <code>pyBrella --StartFile COORD</code></li> <li><code>Amber Coordinate file</code> (default = start.rst7) Can be changed using <code>pyBrella --AmberCoordinates COORD</code>, This needs to be an amber file to link with amber parameters</li> </ul> <p>You also have cli variables that tune the calculation. They are handled by the input parser</p>"},{"location":"Standalone/usage/#running-recommended","title":"Running (recommended)","text":"<p>To run a Standalone calculation, we recommend generating an input file, defining any variables that differ from those in the default variables</p> <p>The code can then be executed using: <code>standalone -i INPUTFILE</code></p> <p>INPUTFILE must be in the format:</p> <pre><code># Lines starting with '#' will be ignored\n# All inputs should be on a new line\nKEYWORD1=VARIABLE1\nKEYWORD2=VARIABLE2\n</code></pre>"},{"location":"Standalone/usage/#running-not-recommended","title":"Running (not recommended)","text":"<p>You can also run a simulation directly from the command line. All user variables can be parsed and this is handled by the input parser</p>"},{"location":"Standalone/usage/#user-inputs","title":"User Inputs","text":"<p>The default inputs can be found and edited in <code>UserVars/Defaultinputs.py</code>, </p> <p>Here is a list of the main variables that can be changed:</p>"},{"location":"Standalone/usage/#general","title":"General","text":"<pre><code>\"WorkDir\" : \"./\",# str: relative or absolute path to calculation\n\"Verbosity\" : 0, # int: 0=Errors, 1=Warnings, 2=Info, 3=Debug\n\"DryRun\" : True, # bool: Whether to actually run calculations\n</code></pre>"},{"location":"Standalone/usage/#calculation","title":"Calculation","text":"<pre><code>\"CoresPerJob\" : 4, # int: Number of CPU cores for the calc.\n\"MemoryPerJob\" : 4, # int: Ammount of RAM for the calc.\n\"Name\" : \"Name\", # str: Name of calculation.\n\"Ensemble\" : \"min\", # str: min, heat, NVT, NVP\n</code></pre>"},{"location":"Standalone/usage/#qm","title":"QM","text":"<pre><code>\"QM\" : False, # bool: To select the use of qmmm, requires the use of a qm file. \n\"QmFile\" : \"None\", # str:  Name of qm file containing qm parms. \n\"QmSelection\" : \"resname CTN POP MG\", # str: vmd selection algebra for the QM region\n\"QmCharge\" : 1, # int: Net charge of QM system\n\"QmSpin\" : 0, # int: Spin state of QM system\n\"QmMethod\" : \"PBE\", # str: ORCA QM method\n\"QmBasis\" : \"6-31+G*\", # str: ORCA QM basis set.\n\"QmArgs\" : \"MINIPRINT D3BJ TightSCF CFLOAT\", # str: extra information to parse to ORCA\n</code></pre>"},{"location":"Standalone/usage/#mm","title":"MM","text":"<pre><code>\"MMFile\" : \"None\", # str: file containing qm information.\n\"Steps\" : 1000, # int: Number of steps to simulate.\n\"TimeStep\" : 2, # float: timestep in fs. if &gt;1, shake will be turned on. \n\"ParmFile\" : \"complex.parm7\", # str: parameter file. Currently only amber params supported.\n\"AmberCoordinates\" : \"start.rst7\", # str: amber coordinate file for use with the parameter files.\n\"StartFile\" : \"start.rst7\", # str: Amber or NAMD coordinates, start coordinates for THIS simulation.\n\"RestartOut\" : 10, # int: frequency of updating the restart file.\n\"TrajOut\" : 50, # int: frequency of updating the trajectory file.\n\"SMD\" : False, # bool: Whether to use Steered MD.\n\"SMDFile\" : None, # str: Name of file containing SMD parms\n\"Force\" : 0, # float: Force to perform SMD\n\"StartValue\" : 0, # float: start value for SMD\n\"EndValue\" : 0, # float: end value for SMD\n\"AtomMask\" : \"0,0,0,0\", # str: Atom mask for SMD, comma delimited string of atoms. \n\"HPC\" : False, # bool: Run using a SLURM Scheduler.\n</code></pre>"},{"location":"Umbrella/CodeReference/","title":"Code","text":""},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.main","title":"<code>pyBrellaSampling.pyBrella.main()</code>","text":"<p>Main Umbrella sampling executable. This deals with everything and can be run from the command line.</p> Source code in <code>pyBrella.py</code> <pre><code>def main():\n    \"\"\"Main Umbrella sampling executable. This deals with everything and can be run from the command line. \n    \"\"\"\n    starttime = time.time()\n    args = input.UmbrellaInput(sys.argv[1:],) \n    verbosity = args[\"Verbosity\"]\n    assert type(verbosity) is int, f\"ERROR: verbosity statement must be an integer, not {verbosity}\"\n    WorkDir = args[\"WorkDir\"]\n    assert path.isdir(f\"{WorkDir}\"), f\"ERROR: User defined working directory: {WorkDir} Does not exist!\"\n    dr = args[\"DryRun\"]   \n    if dr == \"True\" or dr == True:\n        DryRun = True\n    elif dr == \"False\" or dr == False: # pragma: no cover\n        DryRun = False\n    assert type(DryRun) is bool, f\"ERROR: DryRun must be a boolean, not {DryRun}!\"\n    parmfile = args[\"ParmFile\"]\n    assert path.isfile(f\"{WorkDir}{parmfile}\"), f\"ERROR: {parmfile} does not exist in the working directory!\"\n    globals.init(v=verbosity, wd=WorkDir,dr=DryRun, parm=parmfile)\n    Calc, MM, QM, Umbrella, SLURM = class_init(args)\n    equil_length = int(args[\"EquilLength\"])*2000 # Number of steps to equilibrate each window. converts from ps to steps in 0.5 fs timsteps\n    prod_length = int(args[\"ProdLength\"])*2000 # Number of steps to run production for each window.\n    assert type(equil_length) is int, f\"ERROR: equil length must be an integer. Cant do half steps... {equil_length}\"\n    assert type(prod_length) is int, f\"ERROR: prod length must be an integer, cant do half steps {prod_length}\"\n    AnalIgnore = [] # Bins to ignore for analysis... Use with caution.\n    if args[\"Stage\"].casefold() == \"setup\":\n        setup(QM, Umbrella)\n    if args[\"Stage\"].casefold() == \"min\":\n        min(MM, Calc, args[\"StartFile\"])\n    if args[\"Stage\"].casefold() == \"heat\":\n        heat(MM, Calc)\n    if args[\"Stage\"].casefold() == \"pull\":\n        pull(Umbrella, MM, QM, Calc)\n    if args[\"Stage\"].casefold() == \"equil\":\n        MM.Set_Ensemble(\"NVT\")\n        Calc.Job_Name(\"equil\")\n        MM.Set_Length(equil_length, 0.5)  # 2000 steps at 0.5 fs = 1 ps ~ 1 day\n        MM.Set_Outputs(100, 100, 80)\n        const(MM, QM, Calc, Umbrella, \"pull_1\")\n        SLURM.set_arrayJob(\"equil_1.txt\", Umbrella.Bins)\n        utils.slurm_gen(\"NAME\", SLURM, \"sh array_job.sh\", globals.WorkDir)\n        utils.batch_sub(5,20, )\n    if args[\"Stage\"].casefold() == \"prod\":\n        Calc.Job_Name(\"prod\")\n        MM.Set_Ensemble(\"NVT\")\n        MM.Set_Length(prod_length, 0.5)  # 8000 steps at 0.5 fs = 4 ps, ~ 3.5 days\n        MM.Set_Outputs(100, 100, 80)  # Timings, Restart, Trajectory\n        if Calc.MaxSteps == 0:\n            num = 1\n        else:\n            num = math.ceil(equil_length/Calc.MaxSteps)\n        const(MM, QM, Calc, Umbrella, f\"equil_{num}\")\n    if args[\"Stage\"].casefold() == \"wham\":\n        if Calc.MaxSteps == 0:\n            NumJobs = 1\n        else:\n            if \"prod\" in args[\"AnalFile\"].casefold():\n                steps = prod_length\n            elif \"equil\" in args[\"AnalFile\"].casefold():\n                steps = equil_length\n            else:\n                steps = 0\n            NumJobs = math.ceil(steps / Calc.MaxSteps)\n        if \"_\" not in args[\"AnalysisFile\"].casefold():\n            if globals.verbosity &gt;= 1:\n                print(f\"Number of steps to glue together is {NumJobs}\")\n            Anal.glue_stick(Umbrella, NumJobs=NumJobs, file=args[\"AnalFile\"])\n        if Umbrella.atom3 != 0:\n            periodicity = \"periodic\"\n        else:\n            periodicity = \"discrete\"\n        wham = WhamClass(args[\"AnalysisFile\"], Umbrella.ConstForce, periodicity)\n        Wham.Init_Wham(Umbrella, wham, WhamIgnore=AnalIgnore)\n        Wham.Run_Wham(Umbrella, WhamIgnore=AnalIgnore)\n    if args[\"Stage\"].casefold() == \"analysis\": # pragma: no cover\n        Anal.analysis()\n    if args[\"Stage\"].casefold() == \"convergence\":\n        Wham.convergence(Calc, args[\"AnalysisFile\"], equil_length, prod_length, Umbrella)\n    if args[\"Stage\"].casefold() == \"vis\":\n        VisInit( Umbrella, args[\"AnalysisFile\"])\n        if globals.DryRun == \"False\":\n            VisLoad(args[\"AnalysisFile\"])\n    endtime = time.time()\n    print(f\"Total time is {endtime - starttime}\")\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.Tools.InputParser.UmbrellaInput","title":"<code>pyBrellaSampling.Tools.InputParser.UmbrellaInput(sysargs)</code>","text":"<p>Description of UmbrellaInput</p> <p>Parameters:</p> Name Type Description Default <code>sysargs</code> <code>list</code> <p>CLI user variables</p> required <p>Returns:</p> Name Type Description <code>arg_dict</code> <code>dict</code> <p>User variables parsed as a dictionary.</p> Source code in <code>Tools/InputParser.py</code> <pre><code>def UmbrellaInput(sysargs):\n    \"\"\"\n    Description of UmbrellaInput\n\n    Args:\n        sysargs (list): CLI user variables\n\n    Returns:\n        arg_dict (dict): User variables parsed as a dictionary.\n\n    \"\"\"\n    HPC = \"None\"\n    HostName = socket.gethostname()\n    for alias, data in HPC_Config.items():\n        if HostName == data[\"HostName\"]:\n            HPC = alias\n            continue\n    defaults = UserVars.Umbrella_Inp\n    HPC_Conf = HPC_Config[HPC]\n    parser = argparse.ArgumentParser(description=f\"\"\"Commandline arguments. This method of calculation input is being deprecated. Please do not use.\nIt is recommended to use --Stage inpfile to generate input file templates with default values that you can then edit.\"\"\")\n    ### Core Job arguments\n    Core = parser.add_argument_group(\"Core Job Arguments\")\n    Core.add_argument('-wd', '--WorkDir', type=str,\n                        help=\"Home location for the calculations\", default=defaults[\"WorkDir\"])\n    Core.add_argument('-i', '--Input', type=str, default=\"None\",\n                      help=\"Global input file, This will overwrite all other variables and input files.\")\n    Core.add_argument('-v', '--Verbosity', type=int,\n                        help=\"Verbosity: 0 = none, 1 = info\", default=defaults[\"Verbosity\"])\n    Core.add_argument('-dr', '--DryRun', type=str,\n                        help=\"Indicates whether programs are executed or not\", default=defaults[\"DryRun\"])\n\n    Compute = parser.add_argument_group(\"Compute Arguments\")\n    ### Compute Arguments\n    Compute.add_argument('-cores', '--CoresPerJob', type=int,\n                        help=\"Number of cores per individual calculation\", default=defaults[\"CoresPerJob\"])\n    Compute.add_argument('-mem','--MemoryPerJob', type=int,\n                        help=\"Gb of memory per individual calculation\", default=defaults[\"MemoryPerJob\"])\n    Compute.add_argument('-MaxCalc', '--MaxStepsPerCalc', type=int,\n                         help=\"The maximum number of steps per calculation. splits jobs into sub-steps. useful for short wall times. 0 == No cap.\",\n                         default=defaults[\"MaxStepsPerCalc\"])\n\n    ### MM Arguments\n    MM = parser.add_argument_group(\"Molecular Dynamics Arguments\")\n    MM.add_argument('-MDcpu', '--MDCPUPath', type=str,\n                        help=\"Path to NAMD CPU executable\", default=NAMD_CPU)\n    MM.add_argument('-MDgpu', '--MDGPUPath', type=str,\n                        help=\"Path to NAMD GPU executable\", default=NAMD_GPU)\n\n    ### QM Arguments\n    QM = parser.add_argument_group(\"QM Arguments\")\n    QM.add_argument(\"--QM\", type=str, choices=[\"True\", \"False\"], default=defaults[\"QM\"],\n                    help=\"Whether to use QMMM Umbrella Sampling\")\n    QM.add_argument(\"-qf\", \"--QmFile\", type=str, default=defaults[\"QmFile\"],\n                        help=\"Name of file containing QM information.\")\n    QM.add_argument('-qp', '--QmPath', type=str,\n                        help=\"Path to QM software\", default=ORCA_PATH)\n    QM.add_argument('-qsel', '--QmSelection', type=str,\n                        help=\"Selection algebra for QM atoms\", default=defaults[\"QmSelection\"])\n    QM.add_argument('-qc', '--QmCharge', type=int,\n                        help=\"Charge of QM region\", default=defaults[\"QmCharge\"])\n    QM.add_argument('-qspin', '--QmSpin', type=int,\n                        help=\"Spin of QM region\", default=defaults[\"QmSpin\"])\n    QM.add_argument('-qm', '--QmMethod', type=str,\n                        help=\"Qm method\", default=defaults[\"QmMethod\"])\n    QM.add_argument('-qb', '--QmBasis', type=str,\n                        help=\"QM basis set\", default=defaults[\"QmBasis\"])\n    QM.add_argument('-qargs', '--QmArgs', type=str, help=\"Extra arguments for ORCA calculation\", default=defaults[\"QmArgs\"])\n\n    ### Umbrella Arguments\n    Umbrella = parser.add_argument_group(\"Umbrella Sampling arguments\")\n    Umbrella.add_argument(\"--UmbrellaFile\", type=str, default=defaults[\"UmbrellaFile\"],\n                        help=\"Name of file containing Umbrella information.\")\n    Umbrella.add_argument('-min', '--UmbrellaMin', type=float,\n                        help=\"Minimum Umbrella distance\", default=defaults[\"UmbrellaMin\"])\n    Umbrella.add_argument('-width', '--UmbrellaWidth', type=float,\n                        help=\"Umbrella bin width in Angstroms or degrees\", default=defaults[\"UmbrellaWidth\"])\n    Umbrella.add_argument('-bins', '--UmbrellaBins', type=int,\n                        help=\"Number of umbrella bins\", default=defaults[\"UmbrellaBins\"])\n    Umbrella.add_argument('-pf', '--PullForce', type=float,\n                        help=\"Force for pulls in KCal A-2\", default=defaults[\"PullForce\"])\n    Umbrella.add_argument('-f', '--ConstForce', type=float,\n                        help=\"Force for standard Umbrella runs\", default=defaults[\"ConstForce\"]) ### NAMD uses 1/2 k rather than just k\n    Umbrella.add_argument('-sd', '--StartDistance', type=float,\n                        help=\"Distance of initial simulation\", default=defaults[\"StartDistance\"])\n    Umbrella.add_argument('-mask', '--AtomMask', type=str,\n                        help=\"Mask for the restrained atoms.\", default=defaults[\"AtomMask\"])\n    Umbrella.add_argument('-stg', '--Stage', type=str,\n                        help=\"Stage of umbrella simulation\", default=defaults[\"Stage\"])\n    Umbrella.add_argument('-af', '--AnalysisFile', type=str,\n                        help=\"Name prefix to perform custom analysis.(XXX.i.colvars.traj\", default=defaults[\"AnalysisFile\"])\n    Umbrella.add_argument(\"--StartFile\", default=defaults[\"StartFile\"], type=str, help=\"Initial coordinate file if not starting from \\\"start.rst7\\\"\")\n    Umbrella.add_argument(\"--ParmFile\", default=defaults[\"ParmFile\"], type=str, \n                              help=\"Amber parameter file\")\n    Umbrella.add_argument(\"--EquilLength\", default=defaults[\"EquilLength\"], type=int, \n                          help=\"Length of equilibration in ps (per window)\")\n    Umbrella.add_argument(\"--ProdLength\", type=int, default=defaults[\"ProdLength\"],\n                          help=\"Length of production umbrellasampling per window in ps.\")\n    if HPC != \"None\":\n    ### HPC Arguments\n        HPC = parser.add_argument_group(\"HPC/SLURM arguments\")\n        HPC.add_argument(\"-MaxTime\", \"--MaxWallTime\", type=int,\n                        help=\"Maximum wall time (Hours) for your jobs (either leave as node max, or set as job length)\",\n                        default=HPC_Conf[\"MaxWallTime\"])\n        HPC.add_argument(\"-Host\", \"--HostName\", type=str,\n                        help=\"HostName of the HPC\", default=HPC_Conf[\"HostName\"])\n        HPC.add_argument(\"--Partition\", type=str, help=\"Calculation partition name\",\n                        default=HPC_Conf[\"Partition\"])\n        HPC.add_argument(\"--MaxCores\", type=int,\n                        help=\"Maximum number of cores available to a node (For array splitting)\", default=HPC_Conf[\"MaxCores\"])\n        HPC.add_argument(\"-QoS\", \"--QualityofService\", type=str,\n                        help=\"Slurm QoS, set to None if not relevant.\", default=HPC_Conf[\"QualityofService\"])\n        HPC.add_argument(\"--Account\", type=str,\n                        help=\"Slurm account, (Not username), Set to None if not relevant\", default=HPC_Conf[\"Account\"])\n        HPC.add_argument(\"-Software\", \"--SoftwareLines\", type=str,\n                        help=\"List of commands like \\\"module load XXX\\\" to load software. Keep each line surrounded by quotes.\",\n                        default=HPC_Conf[\"SoftwareLines\"], nargs=\"*\")\n    args = parser.parse_args(sysargs)\n    arg_dict = vars(args)\n    if HPC == \"None\":\n        arg_dict = arg_dict | HPC_Conf\n    workdir = arg_dict[\"WorkDir\"]\n    qmfile = arg_dict[\"QmFile\"]\n    umbfile = arg_dict[\"UmbrellaFile\"]\n    inpfile = arg_dict[\"Input\"]\n    if arg_dict[\"Stage\"].casefold() == \"inpfile\": # Generates an Umbrella.inp file in the work directory using default values\n        utils.file_2dwrite(f\"{workdir}Umbrella.inp\", x=list(defaults.keys()), y=list(defaults.values()), delim=\"=\" )\n    if arg_dict[\"QmFile\"] != \"None\":\n        qm_input = utils.file_read(f\"{workdir}{qmfile}\")\n        for i in qm_input:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\") # removes random spaces.\n            val = val.replace(\"\\n\",\"\") # removes newline errors.\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {qmfile}\")\n    if arg_dict[\"UmbrellaFile\"] != \"None\":\n        umb_input = utils.file_read(f\"{workdir}{umbfile}\")\n        for i in umb_input:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\")\n            val = val.replace(\"\\n\",\"\")\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {umbfile}\")\n    if arg_dict[\"Input\"] != \"None\":\n        inp = utils.file_read(f\"{workdir}{inpfile}\")\n        for i in inp:\n            if \"#\" in i: # ignore comment lines.\n                continue\n            var, val = i.split(\"=\")\n            var = var.replace(\" \", \"\")\n            val = val.replace(\"\\n\",\"\")\n            if var in arg_dict:\n                arg_dict[var] = val\n            else:\n                raise ValueError(f\"ERROR: Unknown variable: {var} provided in {inpfile}\")\n    return arg_dict\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.class_init","title":"<code>pyBrellaSampling.pyBrella.class_init(args)</code>","text":"<p>Initialises some key dictionary</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>dict</code> <p>User inputs and variables</p> required <p>Returns:</p> Name Type Description <code>Calc</code> <code>CalcClass</code> <p>Class containing calculation variables</p> <code>MM</code> <code>MMClass</code> <p>Class containing MD variables</p> <code>QM</code> <code>QMClass</code> <p>Class containing QM variables</p> <code>Umbrella</code> <code>UmbrellaClass</code> <p>Class containing Umbrella variables</p> <code>SLURM</code> <code>SLURMClass</code> <p>Class containing Slurm variables for HPC usage</p> Source code in <code>pyBrella.py</code> <pre><code>def class_init(args: dict):\n    \"\"\" Initialises some key dictionary\n\n    Args:\n        args (dict): User inputs and variables\n\n    Returns:\n        Calc (CalcClass): Class containing calculation variables\n        MM (MMClass): Class containing MD variables\n        QM (QMClass): Class containing QM variables\n        Umbrella (UmbrellaClass): Class containing Umbrella variables\n        SLURM (SLURMClass): Class containing Slurm variables for HPC usage\n    \"\"\"\n    Umbrella = UmbrellaClass(args,args[\"UmbrellaMin\"], args[\"UmbrellaBins\"],\n                             args[\"StartDistance\"], args[\"UmbrellaWidth\"],)\n    Calc = CalcClass(args)\n    MM = MMClass()\n    QM = QMClass(args)\n    bins = utils.init_bins(Umbrella.Bins, Umbrella.Width, Umbrella.Min)\n    Umbrella.add_bins(bins)\n    SLURM = SLURMClass(args)\n    SLURM.set_IDNumber()\n    return Calc, MM, QM, Umbrella, SLURM\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.setup","title":"<code>pyBrellaSampling.pyBrella.setup(QM, Umbrella)</code>","text":"<p>Generates a setup directory and creates the syst-*.pdb files</p> <p>Parameters:</p> Name Type Description Default <code>QM</code> <code>QMClass</code> <p>QM class containing QM section</p> required <code>Umbrella</code> <code>UmbrellaClass</code> <p>Umbrella Class containing colvar information</p> required Source code in <code>pyBrella.py</code> <pre><code>def setup(QM: QMClass, Umbrella: UmbrellaClass):\n    \"\"\"\n    Generates a setup directory and creates the syst-*.pdb files\n\n    Args:\n        QM (QMClass): QM class containing QM section\n        Umbrella (UmbrellaClass): Umbrella Class containing colvar information\n    \"\"\"\n    if path.isdir(f\"{globals.WorkDir}setup\") == False: ### Make setup directory. Not essential but makes dirs cleaner\n        print(\"INFO: Making the setup directory\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n        os.mkdir(f\"{globals.WorkDir}setup\")\n    utils.QM_Gen(QM.QMSel)\n    if globals.DryRun == False: \n        print(\"INFO: Setting up the syst-qm.pdb file.\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n        logfile = subprocess.run([\"vmd\", \"-dispdev\", \"text\", \"-e\", \"qm_prep.tcl\"],\n                                     text = True, capture_output = True)\n        with open(f\"{globals.WorkDir}setup/tcl-qm.log\",\"w\") as f:\n            print(logfile, file=f)\n    utils.ColVarPDB_Gen(Umbrella)\n    if globals.DryRun == False:\n        print(\"INFO: Setting up the Colvar pdb file.\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n        logfile = subprocess.run([\"vmd\", \"-dispdev\", \"text\", \"-e\", \"Colvar_prep.tcl\"],\n                                    text = True, capture_output = True)\n        print(logfile)\n        with open(f\"{globals.WorkDir}setup/tcl-colvar.log\",\"w\") as f:\n            print(logfile, file=f)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.min","title":"<code>pyBrellaSampling.pyBrella.min(MM, Calc, StartFile)</code>","text":"<p>sets up and runs the initial minimisation run (Pure MD)</p> <p>Parameters:</p> Name Type Description Default <code>MM</code> <code>MMClass</code> <p>Class containing dynamics information</p> required <code>Calc</code> <code>CalcClass</code> <p>Class containing calculation information</p> required <code>StartFile</code> <code>str</code> <p>Start coordinates pre minimisation.</p> required Source code in <code>pyBrella.py</code> <pre><code>def min(MM: MMClass, Calc: CalcClass, StartFile: str):    \n    \"\"\"sets up and runs the initial minimisation run (Pure MD)\n\n    Args:\n        MM (MMClass): Class containing dynamics information\n        Calc (CalcClass): Class containing calculation information\n        StartFile (str): Start coordinates pre minimisation.\n    \"\"\"\n    print(globals.WorkDir)\n    MM.Set_Ensemble(\"min\")\n    MM.Set_Outputs(1000, 100, 0)\n    MM.Set_Length(10000)\n    Calc.Job_Name(\"min\")\n    NAMD = NAMDClass(Calc, MM)\n    NAMD.set_pme(\"on\")\n    if StartFile == \"start.rst7\":\n        NAMD.set_startcoords(None, ambercoor=\"start.rst7\", parm=globals.parmfile)\n    else:\n        NAMD.set_startcoords(bincoor=StartFile, ambercoor=\"start.rst7\", parm=globals.parmfile)\n    NAMD.set_cellvectors(MM.CellVec)\n    file = FileGen.Namd_File(NAMD)\n    utils.file_write(f\"{globals.WorkDir}min.conf\", [file])\n    print(f\"{globals.WorkDir}min.conf\")\n    if globals.DryRun == False: # pragma: no cover\n        print(\"INFO: Running the minimisation script\" if globals.verbosity &gt;=2 else\"\", end=\"\" )\n        subprocess.run([MM.GPUNamd + f\" +oneWthPerCore +setcpuaffinity +devices 0 min.conf &gt; min_1.0.out\"],\n                       shell=True, capture_output=True)\n        print(\"INFO: Minimisation complete, cleaning up directory\" if globals.verbosity &gt;=2 else\"\", end=\"\" )\n        output = subprocess.run([\"mv min* ./setup\", \"cp ./setup/min_1.0.restart.coor .\",\n                    \"cp ./setup/min_1.0.out .\", \"cp ./setup/min.conf .\"],\n                   shell=True, capture_output=True)\n        output = subprocess.run([\"cp ./setup/min_1.0.restart.coor .\", ],\n                   shell=True, capture_output=True)\n        output = subprocess.run([\"cp ./setup/min_1.0.out .\"],\n                   shell=True, capture_output=True)\n        output = subprocess.run([\"cp ./setup/min.conf .\"],\n                   shell=True, capture_output=True)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.heat","title":"<code>pyBrellaSampling.pyBrella.heat(MM, Calc)</code>","text":"<p>Sets up and runs the heating calculation Args:     MM (MMClass): Class containing dynamics information     Calc (CalcClass): Class containing calculation information</p> Source code in <code>pyBrella.py</code> <pre><code>def heat(MM: MMClass, Calc: CalcClass):\n    \"\"\"\n    Sets up and runs the heating calculation\n    Args:\n        MM (MMClass): Class containing dynamics information\n        Calc (CalcClass): Class containing calculation information\n    \"\"\"\n    MM.Set_Ensemble(\"heat\")\n    MM.Set_Outputs(200, 10, 100)\n    MM.Set_Length(10000)\n    Calc.Job_Name(\"heat\")\n    NAMD = NAMDClass(Calc, MM)\n    NAMD.set_pme(\"on\")\n    NAMD.set_startcoords(\"min_1.0.restart.coor\", ambercoor=\"start.rst7\", parm=globals.parmfile)\n    NAMD.set_cellvectors(MM.CellVec)\n    file = FileGen.Namd_File(NAMD)\n    utils.file_write(f\"{globals.WorkDir}heat.conf\", [file])\n    if globals.DryRun == False: # pragma: no cover\n        print(\"INFO: Running the heat calculation\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n        subprocess.run([MM.GPUNamd + f\" +oneWthPerCore +setcpuaffinity +devices 0 heat.conf &gt; heat_1.0.out\"],\n                       shell=True, capture_output=True)\n        subprocess.run([\"mv heat* ./setup\", ],\n                   shell=True, capture_output=True)\n        subprocess.run([\"cp ./setup/heat_1.0.restart.coor .\", ],\n                    shell=True, capture_output=True)\n        subprocess.run([\"cp ./setup/heat_1.0.out .\", ],\n                    shell=True, capture_output=True)\n        subprocess.run([\"cp ./setup/heat.conf .\"],\n                    shell=True, capture_output=True)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.pull","title":"<code>pyBrellaSampling.pyBrella.pull(Umbrella, MM, QM, Calc)</code>","text":"Source code in <code>pyBrella.py</code> <pre><code>def pull(Umbrella: UmbrellaClass, MM: MMClass, QM: QMClass, Calc: CalcClass):\n    make_umbrellaDirs(Umbrella)\n    print(\"INFO: Setting up pulls\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n    MM.Set_Ensemble(\"NVT\")\n    MM.Set_Length(50,0.5)\n    MM.Set_Outputs(5,1,10)\n    MM.Set_Shake(\"none\")\n    MM.Set_Force(Umbrella.PullForce)\n    Calc.Job_Name(\"pull\")\n    Calc.Set_OutFile(\"pull\")\n    NAMD = NAMDClass(Calc, MM)\n    NAMD.set_cellvectors(MM.CellVec)\n    Joblist = [None]*Umbrella.Bins\n    for i in range(Umbrella.Bins):\n       if abs(Umbrella.BinVals[i] - Umbrella.Start) &lt; abs(Umbrella.Width * 0.5):\n           Umbrella.add_start(i)\n    for i in range(Umbrella.Bins):\n        if i &lt; Umbrella.StartBin:\n            prevPull = f\"../{i + 1}/pull_1.{i + 1}.restart.coor\"\n        elif i &gt; Umbrella.StartBin:\n            prevPull = f\"../{i-1}/pull_1.{i-1}.restart.coor\"\n        elif i == Umbrella.StartBin:\n            prevPull = f\"../heat_1.0.restart.coor\"#\n            print(f\"Pull starts from directory {i}\")\n        NAMD.set_qm(Calc, QM, i)\n        NAMD.set_startcoords(prevPull)\n        NAMD.set_colvars(\"colvars.pull.conf\")\n        file = FileGen.Namd_File(NAMD, window=i)\n        utils.file_write(f\"{globals.WorkDir}{i}/pull.conf\", [file])\n        colvarfile = utils.colvar_gen(Umbrella, i, \"pull\", Umbrella.PullForce )\n        utils.file_write(f\"{globals.WorkDir}{i}/colvars.pull.conf\", [colvarfile])\n        Joblist[i] = f\"mkdir /dev/shm/NAMD_{i} ; cd ./{i} ; {MM.CPUNamd} pull.conf &gt; pull_1.{i}.out ; cd ../ ; rm -r /dev/shm/NAMD_{i}\"\n    utils.file_write(f\"{globals.WorkDir}pull.txt\",Joblist)\n    make_runfile(Umbrella, Joblist)\n    if globals.DryRun == False: # pragma: no cover\n        print(\"INFO: Running serial pulls.\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n        run_out = subprocess.run([f\"sh {globals.WorkDir}pull.sh\"], shell=True, capture_output=True)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.const","title":"<code>pyBrellaSampling.pyBrella.const(MM, QM, Calc, Umbrella, PreviousJob)</code>","text":"Source code in <code>pyBrella.py</code> <pre><code>def const(MM: MMClass, QM: QMClass, Calc: CalcClass, Umbrella: UmbrellaClass, PreviousJob:str):\n    MM.Set_Force(Umbrella.ConstForce)\n    if Calc.MaxSteps == 0:\n        NumJobs = 1\n        MM.Set_Length(MM.Steps, MM.TimeStep)\n    else:\n        NumJobs = math.ceil(MM.Steps/Calc.MaxSteps)\n        MM.Set_Length(Calc.MaxSteps, MM.TimeStep)\n    NAMD = NAMDClass(Calc, MM)\n    NAMD.set_pme(\"off\")\n    NAMD.set_cellvectors(MM.CellVec)\n    NAMD.set_colvars(\"colvars.const.conf\")\n    JobList = [None] * Umbrella.Bins * NumJobs\n    for i in range(Umbrella.Bins):\n        colvar = utils.colvar_gen(Umbrella, i, \"constant\", Umbrella.ConstForce)\n        utils.file_write(f\"{globals.WorkDir}{i}/colvars.const.conf\",[colvar])\n        for j in range(NumJobs):\n            place = j * Umbrella.Bins + i\n            JobList[place] = f\"sleep 2 ; ( mkdir /dev/shm/RUNDIR_{i} ; cd ./{i} ; {MM.CPUNamd} {Calc.Name}_{j+1}.conf &gt; {Calc.Name}_{j+1}.{i}.out ; cd ../ ; rm -r /dev/shm/RUNDIR_{i} ) &amp;\"\n            NAMD.set_qm(Calc, QM, i)\n            if j == 0:\n                NAMD.set_startcoords(f\"{PreviousJob}.{i}.restart.coor\")\n                file = FileGen.Namd_File(NAMD, j+1, i)\n                utils.file_write(f\"{globals.WorkDir}{i}/{Calc.Name}_{j + 1}.conf\",\n                                 [file])\n            else:\n                NAMD.set_startcoords(f\"{Calc.Name}_{j}.{i}.restart.coor\")\n                file = FileGen.Namd_File(NAMD, j + 1, i)\n                utils.file_write(f\"{globals.WorkDir}{i}/{Calc.Name}_{j + 1}.conf\",\n                                 [file])\n    for i in range(NumJobs):\n        lines = i * Umbrella.Bins\n        utils.file_write(f\"{globals.WorkDir}{Calc.Name}_{i + 1}.txt\",\n                         JobList[lines : lines + Umbrella.Bins])\n    if globals.DryRun == False:\n        print(\"ERROR: Local umbrella run is not currently supported. We recommend you submit to a HPC\")\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.make_umbrellaDirs","title":"<code>pyBrellaSampling.pyBrella.make_umbrellaDirs(Umbrella)</code>","text":"<p>Makes the directory structure for umbrella calculation</p> <p>Parameters:</p> Name Type Description Default <code>Umbrella</code> <code>UmbrellaClass</code> <p>Contains information about bins.</p> required Source code in <code>pyBrella.py</code> <pre><code>def make_umbrellaDirs(Umbrella: UmbrellaClass):\n    \"\"\"Makes the directory structure for umbrella calculation\n\n    Args:\n        Umbrella (UmbrellaClass): Contains information about bins.\n    \"\"\"\n    print(\"INFO: Making umbrella directories\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n    for i in range(Umbrella.Bins):\n        dir_path = str(globals.WorkDir) + str(i)\n        if path.exists(dir_path):\n            print(f\"INFO: {str(i)} exists. Deleting!\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n            try:\n                os.rmdir(dir_path)\n            except OSError:\n                print(f\"INFO: {i} directory not empty, deletion failed...\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n                pass\n        try:\n            os.mkdir(dir_path)\n        except FileExistsError:\n            print(f\"INFO: {i} directory exists, Skipping making new directory\" if globals.verbosity &gt;= 2 else \"\", end=\"\")\n            pass\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.make_runfile","title":"<code>pyBrellaSampling.pyBrella.make_runfile(Umbrella, Joblist)</code>","text":"<p>Generates the pull.sh file to be run either locally or on the HPC</p> <p>Parameters:</p> Name Type Description Default <code>Umbrella</code> <code>UmbrellaClass</code> <p>Contains bin information</p> required <code>Joblist</code> <code>list</code> <p>List of jobs to run.</p> required Source code in <code>pyBrella.py</code> <pre><code>def make_runfile(Umbrella: UmbrellaClass, Joblist: list):\n    \"\"\"Generates the pull.sh file to be run either locally or on the HPC\n\n    Args:\n        Umbrella (UmbrellaClass): Contains bin information\n        Joblist (list): List of jobs to run.\n    \"\"\"\n    print(\"INFO: Generating pull.sh script.\" if globals.verbosity &gt;=2 else \"\", end=\"\")\n    with open(f\"{globals.WorkDir}pull.sh\", 'w') as f:\n        print(\"#!/bin/bash\", file=f)\n        for i in range(Umbrella.StartBin, Umbrella.Bins):\n            print(Joblist[i], file=f)\n        for i in range(0, Umbrella.StartBin):\n            print(Joblist[Umbrella.StartBin - i - 1], file=f)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.VisInit","title":"<code>pyBrellaSampling.pyBrella.VisInit(Umbrella, File, extension='restart.coor')</code>","text":"<p>Initialises a tcl script to allow the opening of a stage of the calculation as a single trajectory..</p> <p>Parameters:</p> Name Type Description Default <code>Umbrella</code> <code>UmbrellaClass</code> <p>UmbrellaClass containing directory structure information</p> required <code>File</code> <code>str</code> <p>name of stage eg equil_1</p> required <code>extension</code> <code>str</code> <p>File extenstion of the structures. Loads NAMD restart files but could be adapted. Defaults to \"restart.coor\".</p> <code>'restart.coor'</code> Source code in <code>pyBrella.py</code> <pre><code>def VisInit(Umbrella: UmbrellaClass, File: str, extension=\"restart.coor\"):\n    \"\"\"Initialises a tcl script to allow the opening of a stage of the calculation as a single trajectory..\n\n    Args:\n        Umbrella (UmbrellaClass): UmbrellaClass containing directory structure information\n        File (str): name of stage eg equil_1\n        extension (str, optional): File extenstion of the structures. Loads NAMD restart files but could be adapted. Defaults to \"restart.coor\".\n    \"\"\"\n    Lines = [None] * (Umbrella.Bins + 1)\n    Lines[0] = f\"mol new {globals.parmfile}\"\n    for i in range(Umbrella.Bins):\n        Lines[i+1] = f\"mol addfile ./{i}/{File}.{i}.{extension}\"\n    utils.file_write(f\"{globals.WorkDir}/{File}_load.tcl\", lines=Lines)\n</code></pre>"},{"location":"Umbrella/CodeReference/#pyBrellaSampling.pyBrella.VisLoad","title":"<code>pyBrellaSampling.pyBrella.VisLoad(File)</code>","text":"<p>Loads up a tcl script into vmd</p> <p>Parameters:</p> Name Type Description Default <code>File</code> <code>str</code> <p>file name of step trying to visualise eg. equil_1</p> required Source code in <code>pyBrella.py</code> <pre><code>def VisLoad(File:str): # pragma: no cover\n    \"\"\"Loads up a tcl script into vmd\n\n    Args:\n        File (str): file name of step trying to visualise eg. equil_1\n    \"\"\"\n    subprocess.run([f\"vmd -e {File}_load.tcl\"], shell=True, capture_output=True)\n</code></pre>"},{"location":"Umbrella/Inputs/","title":"User Inputs","text":"<p>User inputs can either be provided by commandline variables, or through the use of one or two inputfiles. </p> <p>We recommend the use of two input files, on being the QM input file that should contain the information regarding the QM zone. The other being the Umbrella input file that will contain all other information. </p> <p>This is because the QM zone should never change, so you can generate this once and retain it for all steps. The other variables may change between stages of the calculation however and so it is useful to separate these out into a different file. </p> <p>You can however use only one input file as either file can read in all user variables. It is important to note however that the Umbrella input file overwrites the QM input file, and that both input files overwrite any parsed commandline variables. </p>"},{"location":"Umbrella/Inputs/#user-inputs_1","title":"User Inputs","text":"<p>The default inputs can be found and edited in <code>UserVars/Defaultinputs.py</code></p> <p>Here is a list of the main variables that can be changed: Default User Inputs<pre><code>### General               \n    \"WorkDir\" : \"./\",# str: relative or absolute path to calculation\n    \"Verbosity\" : 0, # int: 0=Errors, 1=Warnings, 2=Info, 3=Debug\n    \"DryRun\" : True, # bool: Whether to actually run calculations\n#### Calcuation\n    \"CoresPerJob\" : 10, # int: Number of CPU cores for the calc.\n    \"MemoryPerJob\" : 10, # int: Ammount of RAM for the calc.\n    \"MaxStepsPerCalc\" : 1000, # int: Maximum number of steps per calculation\n#### QM\n    \"QM\" : False, # bool: To select the use of qmmm, requires the use of a qm file. \n    \"QmFile\" : \"None\", # str:  Name of qm file containing qm parms. \n    \"QmSelection\" : \"resname CTN POP MG\", # str: vmd selection algebra for the QM region\n    \"QmCharge\" : 1, # int: Net charge of QM system\n    \"QmSpin\" : 0, # int: Spin state of QM system\n    \"QmMethod\" : \"PBE\", # str: ORCA QM method\n    \"QmBasis\" : \"6-31+G*\", # str: ORCA QM basis set.\n    \"QmArgs\" : \"MINIPRINT D3BJ TightSCF CFLOAT\", # str: extra information to parse to ORCA\n#### Umbrella\n    \"Stage\" : \"inpfile\", # str: Stage of calculation\n    \"UmbrellaFile\" : \"None\", # str: file containing qm information.\n    \"UmbrellaMin\" : 1.3, # float: Minimum Umbrella distance.\n    \"UmbrellaWidth\" : 0.05, # float: Width of the umbrella bin in either Ang or Deg.\n    \"UmbrellaBins\" : 54, # int: Number of Umbrella bins. \n    \"PullForce\" : 5000, # float: Force to pull the variables to each bin\n    \"ConstForce\" : 300, # float: Force to restrain the colvar during Umbrella simulations\n    \"StartDistance\" : 1.4, # float: Current value for the colvar (From the equilibrated MD)\n    \"StartFile\" : \"start.rst7\", # str: Amber or NAMD coordinates, start coordinates for THIS simulation.\n    \"ParmFile\" : \"complex.parm7\", # str: Amber parameter file. This must be in the root directory!\n    \"AtomMask\" : \"0,0,0,0\", # str: Atom mask for SMD, comma delimited string of atoms. \n    \"AnalysisFile\" : \"prod\", # str: Variable to perform analysis on (i.e. if you only want to visualise pull files, use pull_1)\n    \"EquilLength\" : 1, # int: Length of equil in ps. eg 1 ps = 2000 steps at 0.5 fs timestep\n    \"ProdLength\" : 4, # int: Length of production in ps. 4 ps = 8000 steps at 0.5 fs timestep\n</code></pre></p>"},{"location":"Umbrella/Inputs/#software-paths","title":"Software paths","text":"<p>Software paths should be set up before running any calculations and these can be found in <code>UserVars/SoftwarePaths.py</code></p> Example structure of UserVars/SoftwarePaths.py<pre><code>#### ORCA path\n\n    \"ORCA_PATH\" : \"/PATH_TO_ORCA/5.0.4/orca\" # str: Path to the orca executable\n\n#### NAMD paths\n\n    \"NAMD_CPU\" : \"/PATH_TO_NAMD/NAMD_3.0b4_Linux-x86_64-multicore/namd3\" # str: Path to the cpu version of NAMD for QMMM\n    \"NAMD_GPU\" : \"/PATH_TO_NAMD/NAMD_3.0b4_Linux-x86_64-multicore-CUDA/namd3\" # str: Path to the GPU version of NAMD for MD\n</code></pre>"},{"location":"Umbrella/pyBrellaSampling/","title":"pyBrellaSampling","text":"<p>Welcome to the automated umbrella sampling script called pyBrellaSampling</p> <p>This code is designed to assist in the setup and running of Umbrella sampling when using NAMD and ORCA.  Specifically it is designed to help with running QM/MM Umbrella sampling simulations with collective variables being: </p> <ul> <li>Bond formation/breaking</li> <li>Bond angle changes </li> <li>Bond dihedral changes</li> </ul> <p>It should be noted that some of the functionality has not been tested and usage of the code is at the end users risk! We recommend running with <code>DryRun=True</code> and checking the input files generated when initiating any new calculations. </p> <p>Feedback and issues can be raised on github or via email to <code>ross.amory98@gmail.com</code></p>"},{"location":"Umbrella/usage/","title":"Usage","text":""},{"location":"Umbrella/usage/#setup","title":"Setup","text":"<p>To run an umbrella calculation, you need two key files: </p> <ul> <li><code>Parameter file</code> (default = complex.parm7) Can be changed using <code>pyBrella --ParmFile PARM</code></li> <li><code>Coordinate file</code> (default = start.rst7) Can be changed using <code>pyBrella --StartFile COORD</code></li> </ul> <p>These two files, along with other user defined variables are all you need in order to perform Umbrella Sampling. </p> <p>Users are recommended to follow the workflow provided below.</p>"},{"location":"Umbrella/usage/#workflow","title":"Workflow","text":"<pre><code>graph TB\nsubgraph Local\n direction LR\n A[Setup] --&gt; B[Minimize]\n B --&gt; C[Heat]\n C --&gt; D[Pull]\n D --&gt; G[Check strcutures]\n G --&gt;|If wrong, fix| D\n end\n Local --&gt;|If correct| HPC\n subgraph HPC\n direction LR\n E[Equilibrate] --&gt; F[Production]\n end</code></pre>"},{"location":"Umbrella/usage/#setup_1","title":"Setup","text":"<p>The setup stage performs the setup script</p> <p>This generates the <code>syst-col.pdb</code> and <code>syst-qm.pdb</code> files.</p> <ul> <li><code>syst-col.pdb</code>  tells NAMD which atoms are involved in the sampling.</li> <li><code>syst-qm.pdb</code> tells NAMD which atoms are involved in the QM zone.</li> </ul>"},{"location":"Umbrella/usage/#important-variables","title":"Important variables:","text":"<pre><code>\"Stage\" : Setup\n\"QmSelection\" : The VMD selection algebra for the QM zone\n\"AtomMask\" : The atomic index of the atoms involved in Umbrella sampling. \n    - This should be comma delimited, and contain 4 numbers. \n        All unused numbers should be zero e.g if bond: 20,21,0,0\n</code></pre>"},{"location":"Umbrella/usage/#run","title":"Run:","text":"Running the setup<pre><code>pyBrella -stg setup -dr False \n</code></pre> Warning <p>At this point, check that your syst-qm.pdb file has been generated correctly. It is a common bug (depending on your version of vmd) to not generate the column containing elements. (The final column should be the atomic elements.) If this does not exist, edit the file around the QM zone, the elements should be in columns 77/78.</p>"},{"location":"Umbrella/usage/#minimisation","title":"Minimisation","text":"<p>This step minimizes your system using traditional MD. The minimisation code is used to perform this.</p>"},{"location":"Umbrella/usage/#important-variables_1","title":"Important variables:","text":"<pre><code>\"Stage\" : min\n</code></pre>"},{"location":"Umbrella/usage/#run_1","title":"Run:","text":"Running a minimisation<pre><code>pyBrella -stg min -dr False # (1)\n</code></pre> <ol> <li>It is important that the GPU version of NAMD is loaded and that the path has been defined.</li> </ol>"},{"location":"Umbrella/usage/#heating","title":"Heating","text":"<p>At this step, we heat the system to 300 k over 20 ps using the heat code. </p>"},{"location":"Umbrella/usage/#important-variables_2","title":"Important variables:","text":"<pre><code>\"Stage\" : heat\n</code></pre>"},{"location":"Umbrella/usage/#run_2","title":"Run:","text":"Heating the system<pre><code>pyBrella -stg heat -dr False\n</code></pre> Warning <p>Now that the standard MD steps have been performed, you should remove the GPU version of NAMD from your path, and load in the CPU version. You should also ensure that the path to ORCA is correctly defined. QM/MM requires a CPU version of NAMD. </p> <p>You can also start the calculation at this point however need to ensure that your input is named heat_1.0.restart.coor and is in NAMD format.</p>"},{"location":"Umbrella/usage/#pull","title":"Pull","text":"<p>This is the stage where you initiate the umbrella windows/bins. This uses the pull code From this point on it is recommended to be using an input file for all steps of the simulation. </p> <p>You first need to analyze the heated structure, and obtain the atom index's for the collective variable.</p> <ul> <li><code>\"at1,at2,0,0\"</code> : Bond colvar between atom 1 and atom 2</li> <li><code>\"at1,at2,at3,0\"</code> : Angle colvar between atoms 1, 2 and 3</li> <li><code>\"at1,at2,at3,at4\"</code> : Dihedral colvar between atoms 1, 2, 3 and 4 </li> </ul>"},{"location":"Umbrella/usage/#important-variables_3","title":"Important variables:","text":"<pre><code>\"Stage\" : pull\n\"QmSelection\" : \"VMD selection algebra for qm region\"\n\"QmCharge\" : Net charge of QM region\n\"QmSpin\" : Spin of QM system\n\"QmMethod\" : QM functional\n\"QmBasis\" : QM basis set\n\"QmArgs\" : Dispersion corrections ect.\n\n\"UmbrellaMin\" : Value of bin 0\n\"UmbrellaWidth\" : Width between each bin (can be negative)\n\"UmbrellaBins\" : Number of bins\n\"PullForce\" : Force to pull atoms\n\"ConstForce\" : Force used during umbrella simulations\n\"StartDistance\" : Current value in the __heat_1.0.restart.coor__ file\n\"AtomMask\" : The mask for the collective variable (see above)\n</code></pre>"},{"location":"Umbrella/usage/#run_3","title":"Run:","text":"Tip <p>At this point, you can either run the calculation locally or on a HPC. If you have a fast computer (12 or more cores), it is recommended that you do this locally as the pulls occur in serial and only need around 10 threads. This also makes life faster when checking the generated structures as you do not need to move files between computers.</p> Umbrella.inp<pre><code>QmSelection=resname RES\nQmCharge=0\nQmSpin=1\nQmMethod=PBE\nQmBasis=6-31+G*\nQmArgs=MINIPRINT D3BJ TightSCF\nUmbrellaMin=1.3\nUmbrellaWidth=0.05 # (1)\nUmbrellaBins=50\nPullForce=5000 # (2)\nConstForce=300\nStartDistance=1.4\nAtomMask=12,13,0,0 # (3)\n</code></pre> <ol> <li>Small window gap gives better umbrella sampling results. As its a bond, units in Angstroms.</li> <li>Pull force should be large so that the bins are linearly spaced</li> <li>Bond collective variable between atoms 12 and 13</li> </ol> Generating windows<pre><code>pyBrella -stg pull -dr False -i Umbrella.inp\n</code></pre> Warning <p>At this point, you should ALWAYS check the generated structures. You can do this quickly by using the visualisation script which is called using :</p> <pre><code>pyBrella -stg vis -dr False -af pull_1\n</code></pre> <p>This will open up the final structure from each window as a new frame in a single trajectory in vmd. You can then use vmd to plot the collective variable against frame to ensure a linear distribution and that the collective variables are at the correct value.</p>"},{"location":"Umbrella/usage/#equilibration","title":"Equilibration","text":"<p>Once the structures are all setup, it is recommended to move everything onto a HPC. This will dramatically speed up the future stages of the simulation and make the calculation possible within reasonable time scales. </p> <p>Ensure that you have correctly setup the pyBrellaSampling environment on the HPC as the default paths to software ect. will likely be different.</p> <p>Once on the HPC, using the same <code>Umbrella.inp</code> file as used previously, you can initiate the equilibration files.</p> Setting up equilibration<pre><code>pyBrella -stg equil -dr True -i Umbrella.inp\n</code></pre> <p>This should initialize the equilibration input files for each window, at this point it is recommended that you check at least one of the windows to make sure the software paths are correct.</p> <p>The command also generates some SLURM files:</p> <pre><code>sub.sh # (1)\narray_job.sh # (2)\nrunner.sh # (3)\nequil_1.txt # (4)\n</code></pre> <ol> <li>Blank SLURM submission file that is used as a template by runner.sh. You can also manually use this to sumbit your equil scripts.</li> <li>File used by SLURM to run the array file. You shouldnt need to edit this.</li> <li>File used to link and submit all simulations to SLURM with dependancies... This may or may not work so use with caution. Also it will likely max out your maximum queue allowance so will have to comment lines out and run multiple times. Good Luck! </li> <li>Text file with each line being a self-contained command to run each window in the umbrella sampling simulation. This is used by SLURM as the array file which runs each line as an independent simulation. There will be multiple of these if you have set MaxStepsPerCalc &gt; 0 and they MUST be run in order. </li> </ol>"},{"location":"Umbrella/usage/#production","title":"Production","text":"<p>Running the production stage of Umbrella sampling is identical to the equilibration stage. </p> <p>It requires the same <code>Umbrella.inp</code> file and should be performed on a HPC. </p> Setting up production<pre><code>pyBrella -stg prod -dr True -i Umbrella.inp\n</code></pre> <p>Like the equilibration stage, this will generate the <code>prod_X.txt</code> files that contain commands for running each step in the production run. Submit them in order otherwise they will break!</p>"},{"location":"coverage/","title":"Testing","text":""}]}